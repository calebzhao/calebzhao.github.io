---
title: 基于SpringBoot的Environment源码理解实现分散配置
date: 2019-12-31 09:32:37
tags: 
- spring boot
- envionment
categories: spring boot
---



# 前言

`org.springframework.core.env.Environment`是当前应用运行环境的公开接口，主要包括应用程序运行环境的两个关键方面：配置文件(profiles)和属性(properties)。`Environment`继承自接口`PropertyResolver`，而`PropertyResolver`提供了属性访问的相关方法。这篇文章从源码的角度分析`Environment`的存储容器和加载流程，然后基于源码的理解给出一个生产级别的扩展。

# 哪里创建的Environment?

学习过springboot的都知道，在Springboot的main入口函数中调用SpringApplication.run(DemoApplication.class,args)函数便可以启用SpringBoot应用程序，跟踪一下SpringApplication源码可以发现，最终还是调用了SpringApplication的动态run函数。



我们在编写一个spring boot应用时通常启动的方式是通过```SpringApplication.run(xxx.class, args)```来启动的，

```java
@SpringBootApplication
public class ClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(ClientApplication.class, args);
    }
}
```

```SpringApplication```源码如下：

```java
public class SpringApplication{
    
    ...省略与Environment无关的代码

    public SpringApplication(Class<?>... primarySources) {
        this(null, primarySources);
    }

    public static ConfigurableApplicationContext run(Class<?> primarySource, String... args) {
        return run(new Class<?>[] { primarySource }, args);
    }

    public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
        return new SpringApplication(primarySources).run(args);
    }

    public ConfigurableApplicationContext run(String... args) {
        ...省略与Environment无关的代码

        try {
			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
            
             // 与Environment相关的关键代码
			ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
            
            ...省略与Environment无关的代码
        }
        catch (Throwable ex) {
			handleRunFailure(context, ex, exceptionReporters, listeners);
			throw new IllegalStateException(ex);
		}
        
        ...省略与Environment无关的代码
    }
    
    private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,
			ApplicationArguments applicationArguments) {
		// 关键代码：获取ConfigurableEnvironment， 如果不存在就创建
		ConfigurableEnvironment environment = getOrCreateEnvironment();
		configureEnvironment(environment, applicationArguments.getSourceArgs());
		ConfigurationPropertySources.attach(environment);
		listeners.environmentPrepared(environment);
		bindToSpringApplication(environment);
		if (!this.isCustomEnvironment) {
			environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,
					deduceEnvironmentClass());
		}
		ConfigurationPropertySources.attach(environment);
		return environment;
	}
    
    // 根据应用类型创建相应的ConfigurableEnvironment
    private ConfigurableEnvironment getOrCreateEnvironment() {
		if (this.environment != null) {
			return this.environment;
		}
		switch (this.webApplicationType) {
		case SERVLET:
             // servlet应用
			return new StandardServletEnvironment();
		case REACTIVE:
             // reactive反应式应用
			return new StandardReactiveWebEnvironment();
		default:
             // 非reactive， 非web， 也就是标准java应用
			return new StandardEnvironment();
		}
	}
    
    ...省略与Environment无关的代码
}

```

可以看到```SpringApplication```类中最终会根据应用类型(```WebApplicationType```枚举类)创建相应的```ConfigurableEnvironment```的具体实现实例对象，另外关于SpringApplication这个类的具体执行流程另一篇博客已有详细的源码分析，这里不再赘述，参见[Spring Boot启动流程分析](https://calebzhao.github.io/2019/12/30/Spring%20Boot启动流程分析/)

下面以web环境的```StandardServletEnvironment```为例进行分析

# Environment类体系

![](https://cdn.jsdelivr.net/gh/calebzhao/cdn/img/20191231093757.png)

- `PropertyResolver`：用于针对任何基础源解析属性的接口，提供属性访问功能
- `ConfigurablePropertyResolver`：继承自`PropertyResolver`，额外提供属性类型转换(基于`org.springframework.core.convert.ConversionService`)功能
- `Environment`：继承自`PropertyResolver`，额外提供访问和判断profiles的功能
- `ConfigurableEnvironment`：继承自`ConfigurablePropertyResolver`和`Environment`，并且提供设置激活的profile和默认的profile的功能。
- `ConfigurableWebEnvironment`：继承自`ConfigurableEnvironment`，并且提供配置`Servlet`上下文和`Servlet`参数的功能。
- `AbstractEnvironment`：实现了`ConfigurableEnvironment`接口，默认属性和存储容器的定义，并且实现了`ConfigurableEnvironment`中的方法，并且为子类预留可重写的扩展方法。
- `StandardEnvironment`：继承自`AbstractEnvironment`，非`Servlet`(Web)环境下的标准`Environment`实现。
- `StandardServletEnvironment`：继承自`StandardEnvironment`，`Servlet`(Web)环境下的标准`Environment`实现。
- `MockEnvironment`: `ConfigurableEnvironment`的简单实现，出于测试的目的，用于暴露`setProperty(String, String)` 及 `withProperty(String, String)`方法
- ```AbstractPropertyResolver```：抽象基类，用于根据任何基础源解析属性， ```conversionService```的默认实现使用```DefaultConversionService```创建。
- ```PropertySourcesPropertyResolver```：```PropertyResolver```的实现，可以针对一组基础的```PropertySource```解析属性值

reactive相关的暂时不研究。



# Environment提供的方法

一般情况下，我们在SpringMVC项目中启用到的是`StandardServletEnvironment`，它的父接口是`ConfigurableWebEnvironment`，我们可以查看此接口提供的方法：

<img src="https://cdn.jsdelivr.net/gh/calebzhao/cdn/img/20191231100908.png" style="zoom: 80%;" />



- ```PropertyResolover```：从接口提供的方法可以看到```PropertyResolover```接口提供的方法都是获取属性相关的get方法或者求值(resolve)方法，不涉及set操作
- ```ConfigurablePropertyResolover```：扩展了```PropertyResolover```接口提供的方法, 额外提供了访问属性转换(```ConfigurableConversionService```)的get/set方法，及属性占位符```placheholder```的get/set方法，即该类的目的是提供写操作(set)的相关方法
- ```Environment```：从提供的方法可以看到全部是与profile相关的访问，获取当前默认的profile及已激活的profile， 只有get操作
- ```ConfigurableEnvironment```：从类名就知道提供的对```Environment```写操作相关的方法，包括设置默认profile、设置当前激活哪个profile、获取系统属性、合并另一个```ConfigurableEnvironment```的属性
- ```ConfigurableWebEnvironment```：只提供了```initPropertySources```方法, 从参数就可以看出来是提供配置`ServletContext`上下文和`ServletConfig`参数的功能

因此从每个类提供的方法可以看到Environment相关的接口的思想是一层层抽象出标准环境、web环境、可配置的标准环境、可配置的web环境，将读操作和写操作分离、web环境和非web环境分离



# Environment的存储容器

从```SpringApplication.getOrCreateEnvironment()```方法可以看到最终返回的```ConfigurableEnvironment```就是```StandardServletEnvironment``` 或```StandardEnvironment```或者```StandardReactiveWebEnvironment```

```java
// 根据应用类型创建相应的ConfigurableEnvironment
private ConfigurableEnvironment getOrCreateEnvironment() {
    if (this.environment != null) {
        return this.environment;
    }
    switch (this.webApplicationType) {
        case SERVLET:
            // servlet应用
            return new StandardServletEnvironment();
        case REACTIVE:
            // reactive反应式应用
            return new StandardReactiveWebEnvironment();
        default:
            // 非reactive， 非web， 也就是标准java应用
            return new StandardEnvironment();
    }
}
```

下面从StandardServletEnvironment开始分析。

new StandardServletEnvironment()会执行StandardServletEnvironment的的构造方法，会发现这个类没有提供构造方法，只重写了```customizePropertySources```及```initPropertySources```这2个方法，这2个类后续分析。

我们继续看```StandardServletEnvironment```的父类```StandardEnvironment```的实现，发现```StandardEnvironment```也是非常简单，只重写了```customizePropertySources()```这个方法，暂且不管，继续看它的父类```AbstractEnvironment```，会发现这个类做了很多事情，定义了propertySources及profile相关属性，下面具体分析```AbstractEnvironment```这个类。

## PropertySource

要分析AbstractEnvironment这个类先看```PropertySource```

```java
public abstract class AbstractEnvironment implements ConfigurableEnvironment {
	...省略代码

	private final MutablePropertySources propertySources = new MutablePropertySources();

    ...省略代码
    
    public AbstractEnvironment() {
		customizePropertySources(this.propertySources);
	}
    
    protected void customizePropertySources(MutablePropertySources propertySources) {
        
	}
}
```

上面的```propertySources```属性就是用来存放`PropertySource`列表的，再看```MutablePropertySources```这个类的实现：

```java
public class MutablePropertySources implements PropertySources {

	private final List<PropertySource<?>> propertySourceList = new CopyOnWriteArrayList<>();
    
    ...省略代码
}
```

可以看到其中维护了PropertySource这个类的集合propertySourceList属性，这个就是最底层的存储容器。继续跟进看PropertySource的源码实现。

```java
public abstract class PropertySource<T> {

    protected final String name;

    protected final T source;

    public PropertySource(String name, T source) {
        Assert.hasText(name, "Property source name must contain at least one character");
        Assert.notNull(source, "Property source must not be null");
        this.name = name;
        this.source = source;
    }

    public PropertySource(String name) {
        this(name, (T) new Object());
    }

    public String getName() {
        return this.name;
    }

    public T getSource() {
        return this.source;
    }

    public boolean containsProperty(String name) {
        return (getProperty(name) != null);
    }

    @Nullable
    public abstract Object getProperty(String name);

    @Override
    public boolean equals(@Nullable Object other) {
        return (this == other || (other instanceof PropertySource &&
                                  ObjectUtils.nullSafeEquals(this.name, ((PropertySource<?>) other).name)));
    }

    @Override
    public int hashCode() {
        return ObjectUtils.nullSafeHashCode(this.name);
    }

    //省略其他方法和内部类的源码 
}
```

源码相对简单，预留了一个`getProperty`抽象方法给子类实现，**重点需要关注的是重写了的`equals`和`hashCode`方法，实际上只和`name`属性相关，这一点很重要，说明一个PropertySource实例绑定到一个唯一的name，这个name有点像HashMap里面的key**，部分移除、判断方法都是基于name属性。`PropertySource`的最常用子类是`MapPropertySource`、`PropertiesPropertySource`、`ResourcePropertySource`、`StubPropertySource`、`ComparisonPropertySource`。

- `MapPropertySource`：source指定为Map类型的`PropertySource`实现。

  ```java
  public class MapPropertySource extends EnumerablePropertySource<Map<String, Object>> {
  
  	public MapPropertySource(String name, Map<String, Object> source) {
  		super(name, source);
  	}
  
  
  	@Override
  	@Nullable
  	public Object getProperty(String name) {
  		return this.source.get(name);
  	}
  
  	@Override
  	public boolean containsProperty(String name) {
  		return this.source.containsKey(name);
  	}
  
  	@Override
  	public String[] getPropertyNames() {
  		return StringUtils.toStringArray(this.source.keySet());
  	}
  
  }
  ```

  

- `PropertiesPropertySource`：source指定为```Properties```类型的`PropertySource`实现，`PropertiesPropertySource` 继承了```MapPropertySource```，说明```Properties```这个类本身是集合```Map```的子类， 查看```Properties```类的源码可以发现```Properties```这个类继承了```Hashtable```, 而```HashTable```又实现了```Map```接口，所以`PropertiesPropertySource`是`MapPropertySource`的特殊化类型实现。

  ```java
  public class PropertiesPropertySource extends MapPropertySource {
  
  	@SuppressWarnings({"rawtypes", "unchecked"})
  	public PropertiesPropertySource(String name, Properties source) {
  		super(name, (Map) source);
  	}
  
  	protected PropertiesPropertySource(String name, Map<String, Object> source) {
  		super(name, source);
  	}
      
      @Override
  	public String[] getPropertyNames() {
  		synchronized (this.source) {
  			return super.getPropertyNames();
  		}
  	}
  }
  ```

  

- `ResourcePropertySource`：继承自`PropertiesPropertySource`，source指定为通过`Resource`实例转化为`Properties`再转换为Map实例。

  ```java
  public class ResourcePropertySource extends PropertiesPropertySource {
      
      @Nullable
  	private final String resourceName;
      
      public ResourcePropertySource(String name, EncodedResource resource) throws IOException {
  		super(name, PropertiesLoaderUtils.loadProperties(resource));
  		this.resourceName = getNameForResource(resource.getResource());
  	}
      
      ...省略其他代码
  }
  ```

- `StubPropertySource`：`PropertySource`的一个内部类，source设置为null，实际上就是空实现。

  ```java
  public abstract class PropertySource<T> {
      
      protected final String name;
  
  	protected final T source;
      
      public PropertySource(String name, T source) {
  		Assert.hasText(name, "Property source name must contain at least one character");
  		Assert.notNull(source, "Property source must not be null");
  		this.name = name;
  		this.source = source;
  	}
      
      ...省略代码
      
      public static class StubPropertySource extends PropertySource<Object> {
  
  		public StubPropertySource(String name) {
  			super(name, new Object());
  		}
  
  		
  		@Override
  		@Nullable
  		public String getProperty(String name) {
  			return null;
  		}
  	}
  }
  ```

  

- `ComparisonPropertySource`：继承自`ComparisonPropertySource`，所有属性访问方法强制抛出异常，作用就是一个不可访问属性的空实现。

  ```java
  public abstract class PropertySource<T> {	
      
       protected final String name;
  
  	protected final T source;
      
      ...省略代码
          
      static class ComparisonPropertySource extends StubPropertySource {
          
          private static final String USAGE_ERROR =
  				"ComparisonPropertySource instances are for use with collection comparison only";
          
          public ComparisonPropertySource(String name) {
  			super(name);
  		}
          
          @Override
  		public Object getSource() {
  			throw new UnsupportedOperationException(USAGE_ERROR);
  		}
  
  		@Override
  		public boolean containsProperty(String name) {
  			throw new UnsupportedOperationException(USAGE_ERROR);
  		}
  
  		@Override
  		@Nullable
  		public String getProperty(String name) {
  			throw new UnsupportedOperationException(USAGE_ERROR);
  		}
      }
  }
  ```

  



## StandardServletEnvironment

```java
public class StandardServletEnvironment extends StandardEnvironment implements ConfigurableWebEnvironment {
    
    /** Servlet context init parameters property source name: {@value}. */
	public static final String SERVLET_CONTEXT_PROPERTY_SOURCE_NAME = "servletContextInitParams";

	/** Servlet config init parameters property source name: {@value}. */
	public static final String SERVLET_CONFIG_PROPERTY_SOURCE_NAME = "servletConfigInitParams";

	/** JNDI property source name: {@value}. */
	public static final String JNDI_PROPERTY_SOURCE_NAME = "jndiProperties";
}
```



