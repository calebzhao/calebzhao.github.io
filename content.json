{"meta":{"title":"calebzhao的博客","subtitle":"","description":"","author":"calebzhao","url":"https://calebzhao.github.io","root":"/"},"pages":[{"title":"","date":"2020-01-10T04:43:18.135Z","updated":"2020-01-10T04:43:18.135Z","comments":true,"path":"404.html","permalink":"https://calebzhao.github.io/404.html","excerpt":"","text":"404 | JerryC !(function(e, a, t, n, g, c, o) { (e.GoogleAnalyticsObject = g), (e.ga = e.ga || function() { (e.ga.q = e.ga.q || []).push(arguments); }), (e.ga.l = 1 * new Date()), (c = a.createElement(t)), (o = a.getElementsByTagName(t)[0]), (c.async = 1), (c.src = \"https://www.google-analytics.com/analytics.js\"), o.parentNode.insertBefore(c, o); })(window, document, \"script\", 0, \"ga\"), ga(\"create\", \"UA-120653953-1\", \"auto\"), ga(\"send\", \"pageview\"); @import url(\"https://fonts.googleapis.com/css?family=Titillium+Web\"); @-moz-keyframes rocket-movement { 100% { -moz-transform: translate(1200px, -600px); } } @-webkit-keyframes rocket-movement { 100% { -webkit-transform: translate(1200px, -600px); } } @keyframes rocket-movement { 100% { transform: translate(1200px, -600px); } } @-moz-keyframes spin-earth { 100% { -moz-transform: rotate(-360deg); transition: transform 20s; } } @-webkit-keyframes spin-earth { 100% { -webkit-transform: rotate(-360deg); transition: transform 20s; } } @keyframes spin-earth { 100% { -webkit-transform: rotate(-360deg); transform: rotate(-360deg); transition: transform 20s; } } @-moz-keyframes move-astronaut { 100% { -moz-transform: translate(-160px, -160px); } } @-webkit-keyframes move-astronaut { 100% { -webkit-transform: translate(-160px, -160px); } } @keyframes move-astronaut { 100% { -webkit-transform: translate(-160px, -160px); transform: translate(-160px, -160px); } } @-moz-keyframes rotate-astronaut { 100% { -moz-transform: rotate(-720deg); } } @-webkit-keyframes rotate-astronaut { 100% { -webkit-transform: rotate(-720deg); } } @keyframes rotate-astronaut { 100% { -webkit-transform: rotate(-720deg); transform: rotate(-720deg); } } @-moz-keyframes glow-star { 40% { -moz-opacity: 0.3; } 90%, 100% { -moz-opacity: 1; -moz-transform: scale(1.2); } } @-webkit-keyframes glow-star { 40% { -webkit-opacity: 0.3; } 90%, 100% { -webkit-opacity: 1; -webkit-transform: scale(1.2); } } @keyframes glow-star { 40% { -webkit-opacity: 0.3; opacity: 0.3; } 90%, 100% { -webkit-opacity: 1; opacity: 1; -webkit-transform: scale(1.2); transform: scale(1.2); border-radius: 999999px; } } .spin-earth-on-hover { transition: ease 200s !important; transform: rotate(-3600deg) !important; } html, body { margin: 0; width: 100%; height: 100%; font-family: 'Titillium Web',Lato,PingFang SC,Hiragino Sans GB,\"Microsoft JhengHei\",\"Microsoft YaHei\",Helvetica Neue,Helvetica,Arial,sans-serif; font-weight: 300; -webkit-user-select: none; /* Safari 3.1+ */ -moz-user-select: none; /* Firefox 2+ */ -ms-user-select: none; /* IE 10+ */ user-select: none; /* Standard syntax */ } .bg-purple { background: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN/404/bg_purple.png); background-repeat: repeat-x; background-size: cover; background-position: left top; height: 100%; overflow: hidden; position: fixed; } .custom-navbar { padding-top: 15px; position: absolute; top: 0; z-index: 99; padding: 10px 36px; width: 100%; border: none; font-size: 18px; -webkit-transition: all .2s ease-in-out; -moz-transition: all .2s ease-in-out; -o-transition: all .2s ease-in-out; -ms-transition: all .2s ease-in-out; transition: all .2s ease-in-out; } .navbar-links { display: inline-block; float: right; margin-top: 5px; margin-right: 55px; text-transform: uppercase; } ul { list-style-type: none; margin: 0; padding: 0; /* overflow: hidden;*/ display: flex; align-items: center; } li { float: left; padding: 0px 15px; } li a { display: block; color: white; text-align: center; text-decoration: none; letter-spacing: 2px; font-size: 14px; text-shadow: 0.1rem 0.1rem 0.2rem rgba(0,0,0,.15); font-weight: 700; color: white; -webkit-transition: all 0.3s ease-in; -moz-transition: all 0.3s ease-in; -ms-transition: all 0.3s ease-in; -o-transition: all 0.3s ease-in; transition: all 0.3s ease-in; } li a:hover { color: #ffcb39; } .btn-request { padding: 10px 25px; border: 1px solid #ffcb39; border-radius: 100px; font-weight: 400; } .btn-request:hover { background-color: #ffcb39; color: #fff; transform: scale(1.05); box-shadow: 0px 20px 20px rgba(0, 0, 0, 0.1); } .btn-go-home { position: relative; z-index: 200; margin: 15px auto; width: 100px; padding: 10px 15px; border: 1px solid #ffcb39; border-radius: 100px; font-weight: 400; display: block; color: white; text-align: center; text-decoration: none; letter-spacing: 2px; font-size: 11px; -webkit-transition: all 0.3s ease-in; -moz-transition: all 0.3s ease-in; -ms-transition: all 0.3s ease-in; -o-transition: all 0.3s ease-in; transition: all 0.3s ease-in; } .btn-go-home:hover { background-color: #ffcb39; color: #fff; transform: scale(1.05); box-shadow: 0px 20px 20px rgba(0, 0, 0, 0.1); } .central-body { padding: 17% 5% 10% 5%; text-align: center; } .objects img { z-index: 90; pointer-events: none; } .object_rocket { z-index: 95; position: absolute; transform: translateX(-50px); top: 75%; pointer-events: none; animation: rocket-movement 200s linear infinite both running; } .object_earth { position: absolute; top: 20%; left: 15%; z-index: 90; } .object_moon { position: absolute; top: 12%; left: 25%; } .object_astronaut { animation: rotate-astronaut 200s infinite linear both alternate; } .box_astronaut { z-index: 110 !important; position: absolute; top: 60%; right: 20%; will-change: transform; animation: move-astronaut 50s infinite linear both alternate; } .image-404 { position: relative; z-index: 100; pointer-events: none; } .stars { background: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN/404/overlay_stars.svg); background-repeat: repeat; background-size: contain; background-position: left top; } .glowing_stars .star { position: absolute; border-radius: 100%; background-color: #fff; width: 3px; height: 3px; opacity: 0.3; will-change: opacity; } .glowing_stars .star:nth-child(1) { top: 80%; left: 25%; animation: glow-star 2s infinite ease-in-out alternate 1s; } .glowing_stars .star:nth-child(2) { top: 20%; left: 40%; animation: glow-star 2s infinite ease-in-out alternate 3s; } .glowing_stars .star:nth-child(3) { top: 25%; left: 25%; animation: glow-star 2s infinite ease-in-out alternate 5s; } .glowing_stars .star:nth-child(4) { top: 75%; left: 80%; animation: glow-star 2s infinite ease-in-out alternate 7s; } .glowing_stars .star:nth-child(5) { top: 90%; left: 50%; animation: glow-star 2s infinite ease-in-out alternate 9s; } .brand-title{ float: left; } .brand-title a { text-shadow: 0.1rem 0.1rem 0.2rem rgba(0,0,0,.15); font-weight: 700; color: white; text-decoration: none; } @media only screen and (max-width: 768px) { .navbar-links { display: none; } .custom-navbar { padding: 10px 20px; } .box_astronaut { top: 70%; } .central-body { padding-top: 25%; } } JerryC 回到地球"},{"title":"关于自己","date":"2018-06-07T06:07:54.000Z","updated":"2020-01-10T04:43:18.143Z","comments":false,"path":"about/index.html","permalink":"https://calebzhao.github.io/about/index.html","excerpt":"","text":"Never put off till tomorrow what you can do today.—— Thomas Jefferson Code1234Name: calebzhaoAddress: 武汉Github: https://github.com/calebzhaoBlog: https://calebzhao.github.io"},{"title":"分类","date":"2018-06-07T14:17:49.000Z","updated":"2020-01-10T04:43:18.143Z","comments":false,"path":"categories/index.html","permalink":"https://calebzhao.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2020-01-10T04:43:18.143Z","comments":true,"path":"link/index.html","permalink":"https://calebzhao.github.io/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-04-14T10:30:38.000Z","updated":"2020-01-10T04:43:18.143Z","comments":true,"path":"messageboard/index.html","permalink":"https://calebzhao.github.io/messageboard/index.html","excerpt":"","text":"有什么想的？ 有什么想问的？ 有什么想吐槽的？ 可以在下面留言..."},{"title":"那些年，听过的音乐","date":"2018-07-17T09:23:06.000Z","updated":"2020-01-10T04:43:18.143Z","comments":false,"path":"music/index.html","permalink":"https://calebzhao.github.io/music/index.html","excerpt":"","text":"聆听这个世界 OH MY GIRL"},{"title":"記錄這世界","date":"2019-10-24T14:23:55.000Z","updated":"2020-01-10T04:43:18.143Z","comments":false,"path":"photos/index.html","permalink":"https://calebzhao.github.io/photos/index.html","excerpt":"","text":""},{"title":"RSS","date":"2018-07-22T17:05:11.000Z","updated":"2020-01-10T04:43:18.143Z","comments":true,"path":"rss/index.html","permalink":"https://calebzhao.github.io/rss/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-06-07T14:15:37.000Z","updated":"2020-01-10T04:43:18.143Z","comments":false,"path":"tags/index.html","permalink":"https://calebzhao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring Boot之logback日志最佳实践","slug":"Spring Boot之logback日志最佳实践","date":"2020-01-10T04:43:18.135Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2020/01/10/Spring Boot之logback日志最佳实践/","link":"","permalink":"https://calebzhao.github.io/2020/01/10/Spring%20Boot%E4%B9%8Blogback%E6%97%A5%E5%BF%97%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"惊讶！我定的日志规范被CTO在全公司推广了 打印日志是一门艺术，但长期被开发同学所忽视。日志就像车辆保险，没人愿意为保险付钱，但是一旦出了问题都又想有保险可用。我们打印日志的时候都很随意，可是用的时候会吐槽各种 SB 包括自己！写好每一条日志吧，与君共勉！ 1. 日志1.1 日志是什么？日志，维基百科的定义是记录服务器等电脑设备或软件的运作。 日志文件提供精确的系统记录，根据日志最终定位到错误详情和根源。日志的特点是，它描述一些离散的（不连续的）事件。例如：应用通过一个滚动的文件输出 INFO 或 ERROR 信息，并通过日志收集系统，存储到一些存储引擎（Elasticsearch）中方便查询。 1.2 日志有什么用？在上文中我们解释了日志的作用是提供精准的系统记录方便根因分析。那么具体在哪些具体方面它可以发挥作用？ 打印调试：即可以用日志来记录变量或者某一段逻辑。记录程序运行的流程，即程序运行了哪些代码，方便排查逻辑问题。 问题定位：程序出异常或者出故障时快速的定位问题，方便后期解决问题。因为线上生产环境无法 debug，在测试环境去模拟一套生产环境，费时费力。所以依靠日志记录的信息定位问题，这点非常重要。还可以记录流量，后期可以通过 ELK（包括 EFK 进行流量统计）。 用户行为日志：记录用户的操作行为，用于大数据分析，比如监控、风控、推荐等等。这种日志，一般是给其他团队分析使用，而且可能是多个团队，因此一般会有一定的格式要求，开发者应该按照这个格式来记录，便于其他团队的使用。当然，要记录哪些行为、操作，一般也是约定好的，因此，开发者主要是执行的角色。 根因分析（**甩锅必备**）：即在关键地方记录日志。方便在和各个终端定位问题时，别人说时你的程序问题，你可以理直气壮的拿出你的日志说，看，我这里运行了，状态也是对的。这样，对方就会乖乖去定位他的代码，而不是互相推脱。 1.3 什么时候记录日志？上文说了日志的重要性，那么什么时候需要记录日志。 系统初始化：系统或者服务的启动参数。核心模块或者组件初始化过程中往往依赖一些关键配置，根据参数不同会提供不一样的服务。务必在这里记录 INFO 日志，打印出参数以及启动完成态服务表述。 编程语言提示异常：如今各类主流的编程语言都包括异常机制，业务相关的流行框架有完整的异常模块。这类捕获的异常是系统告知开发人员需要加以关注的，是质量非常高的报错。应当适当记录日志，根据实际结合业务的情况使用 WARN 或者 ERROR 级别。 业务流程预期不符：除开平台以及编程语言异常之外，项目代码中结果与期望不符时也是日志场景之一，简单来说所有流程分支都可以加入考虑。取决于开发人员判断能否容忍情形发生。常见的合适场景包括外部参数不正确，数据处理问题导致返回码不在合理范围内等等。 系统核心角色，组件关键动作：系统中核心角色触发的业务动作是需要多加关注的，是衡量系统正常运行的重要指标，建议记录 INFO 级别日志，比如电商系统用户从登录到下单的整个流程；微服务各服务节点交互；核心数据表增删改；核心组件运行等等，如果日志频度高或者打印量特别大，可以提炼关键点 INFO 记录，其余酌情考虑 DEBUG 级别。 第三方服务远程调用：微服务架构体系中有一个重要的点就是第三方永远不可信，对于第三方服务远程调用建议打印请求和响应的参数，方便在和各个终端定位问题，不会因为第三方服务日志的缺失变得手足无措。 2. 日志打印2.1 Slf4j & LogbackSlf4j 英文全称为 “ Simple Logging Facade for Java ”，为 Java 提供的简单日志门面。Facade 门面，更底层一点说就是接口。它允许用户以自己的喜好，在工程中通过 Slf4j 接入不同的日志系统。 Logback 是 Slf4j 的原生实现框架，同样也是出自 Log4j 一个人之手，但拥有比 Log4j 更多的优点、特性和更做强的性能，Logback 相对于 Log4j 拥有更快的执行速度。基于我们先前在 Log4j 上的工作，Logback 重写了内部的实现，在某些特定的场景上面，甚至可以比之前的速度快上 10 倍。在保证 Logback 的组件更加快速的同时，同时所需的内存更加少。 2.2 日志文件日志文件放置于固定的目录中，按照一定的模板进行命名，推荐的日志文件名称： Code123456当前正在写入的日志文件名：[-].log如：example-server-book-service-access.log已经滚入历史的日志文件名：[-].yyyy-MM-dd-hh.[滚动号].log如：example-server-book-service-access.2019-12-01-10.1.log 2.3 日志变量定义推荐使用 lombok（代码生成器） 注解 @lombok.extern.slf4j.Slf4j 来生成日志变量实例。 Code12345678 org.projectlombok lombok 1.18.10 provided 代码示例 Code12345678import lombok.extern.slf4j.Slf4j;@Slf4jpublic class LogTest { public static void main(String[] args) { log.info(\"this is log test\"); }} 2.4 日志配置日志记录采用分级记录，级别与日志文件名相对应，不同级别的日志信息记录到不同的日志文件中。如有特殊格式日志，如 access log，单独使用一个文件，请注意避免重复打印（可使用 additivity**=”false”**避免 ）。 2.5 参数占位格式使用参数化形式 {} 占位，[] 进行参数隔离，这样的好处是可读性更高，而且只有真正准备打印的时候才会处理参数。 Code1234// 正确示例，必须使用参数化信息的方式log.debug(\"order is paying with userId:[{}] and orderId : [{}]\",userId, orderId);// 错误示例，不要进行字符串拼接,那样会产生很多 String 对象，占用空间，影响性能。及日志级别高于此级别也会进行字符串拼接逻辑。log.debug(\"order is paying with userId: \" + userId + \" and orderId: \" + orderId); 2.6.1 日志时间作为日志产生的日期和时间，这个数据非常重要，一般精确到毫秒。 Code1yyyy-MM-dd HH:mm:ss.SSS 2.6.2 日志级别日志的输出都是分级别的，不同的设置不同的场合打印不同的日志。 主要使用如下的四个级别： DEBUG：DEUBG 级别的主要输出调试性质的内容，该级别日志主要用于在开发、测试阶段输出。该级别的日志应尽可能地详尽，开发人员可以将各类详细信息记录到 DEBUG 里，起到调试的作用，包括参数信息，调试细节信息，返回值信息等等，便于在开发、测试阶段出现问题或者异常时，对其进行分析。 INFO：INFO 级别的主要记录系统关键信息，旨在保留系统正常工作期间关键运行指标，开发人员可以将初始化系统配置、业务状态变化信息，或者用户业务流程中的核心处理记录到INFO日志中，方便日常运维工作以及错误回溯时上下文场景复现。建议在项目完成后，在测试环境将日志级别调成 INFO，然后通过 INFO 级别的信息看看是否能了解这个应用的运用情况，如果出现问题后是否这些日志能否提供有用的排查问题的信息。 WARN：WARN 级别的主要输出警告性质的内容，这些内容是可以预知且是有规划的，比如，某个方法入参为空或者该参数的值不满足运行该方法的条件时。在 WARN 级别的时应输出较为详尽的信息，以便于事后对日志进行分析。 ERROR：ERROR 级别主要针对于一些不可预知的信息，诸如：错误、异常等，比如，在 catch 块中抓获的网络通信、数据库连接等异常，若异常对系统的整个流程影响不大，可以使用 WARN 级别日志输出。在输出 ERROR 级别的日志时，尽量多地输出方法入参数、方法执行过程中产生的对象等数据，在带有错误、异常对象的数据时，需要将该对象一并输出。 2.6.3 DEBUG / INFO 的选择 DEBUG 级别比 INFO 低，包含调试时更详细的了解系统运行状态的东西，比如变量的值等等，都可以输出到 DEBUG 日志里。INFO 是在线日志默认的输出级别，反馈系统的当前状态给最终用户看的。输出的信息，应该对最终用户具有实际意义的。从功能角度上说，INFO 输出的信息可以看作是软件产品的一部分，所以需要谨慎对待，不可随便输出。如果这条日志会被频繁打印或者大部分时间对于纠错起不到作用，就应当考虑下调为 DEBUG 级别。 由于 DEBUG 日志打印量远大于 INFO，出于前文日志性能的考虑，如果代码为核心代码，执行频率非常高，务必推敲日志设计是否合理，是否需要下调为 DEBUG 级别日志。 注意日志的可读性，不妨在写完代码 review 这条日志是否通顺，能否提供真正有意义的信息。 日志输出是多线程公用的，如果有另外一个线程正在输出日志，上面的记录就会被打断，最终显示输出和预想的就会不一致。 2.6.4 WARN / ERROR 的选择 当方法或者功能处理过程中产生不符合预期结果或者有框架报错时可以考虑使用，常见问题处理方法包括： 增加判断处理逻辑，尝试本地解决：增加逻辑判断吞掉报警永远是最优选择抛出异常，交给上层逻辑解决 抛出异常，交给上层逻辑解决 记录日志，报警提醒 使用返回码包装错误做返回 一般来说，WARN 级别不会短信报警，ERROR 级别则会短信报警甚至电话报警，ERROR 级别的日志意味着系统中发生了非常严重的问题，必须有人马上处理，比如数据库不可用，系统的关键业务流程走不下去等等。错误的使用反而带来严重的后果，不区分问题的重要程度，只要有问题就error记录下来，其实这样是非常不负责任的，因为对于成熟的系统，都会有一套完整的报错机制，那这个错误信息什么时候需要发出来，很多都是依据单位时间内 ERROR 日志的数量来确定的。 2.6.5 强调ERROR报警 ERROR 级别的日志打印通常伴随报警通知。ERROR的报出应该伴随着业务功能受损，即上面提到的系统中发生了非常严重的问题，必须有人马上处理。 ERROR日志目标 给处理者直接准确的信息：ERROR 信息形成自身闭环。 问题定位： 发生了什么问题，哪些功能受到影响 获取帮助信息：直接帮助信息或帮助信息的存储位置 通过报警知道解决方案或者找何人解决 2.6.6 线程名称输出该日志的线程名称，一般在一个应用中一个同步请求由同一线程完成，输出线程名称可以在各个请求产生的日志中进行分类，便于分清当前请求上下文的日志。 2.6.7 opentracing 标识在分布式应用中，用户的一个请求会调用若干个服务完成，这些服务可能还是嵌套调用的，因此完成一个请求的日志并不在一个应用的日志文件，而是分散在不同服务器上不同应用节点的日志文件中。该标识是为了串联一个请求在整个系统中的调用日志。 唯一字符串（trace id） 调用层级（span id） 通过搜索 trace id 就可以查到这个 trace id 标识的请求在整个系统中流转（处理）过程中产生的所有日志。 2.6.8 biz 标识在业务开发中，我们的日志都是和业务相关联的，有时候是需要根据用户或者业务做聚类的，因此一次请求如果可以通过某项标识做聚类的时候，可以将聚类标识打印到日志中。 用户标识（user id） 业务标识（biz id） 2.6.9 日志记录器名称日志记录器名称一般使用类名，日志文件中可以输出简单的类名即可，看实际情况是否需要使用包名和行号等信息。主要用于看到日志后到哪个类中去找这个日志输出，便于定位问题所在。 2.6.10 日志内容禁用 System.out.println 和 System.err.println 变参替换日志拼接 输出日志的对象，应在其类中实现快速的 toString 方法，以便于在日志输出时仅输出这个对象类名和 hashCode 预防空指针:不要在日志中调用对象的方法获取值，除非确保该对象肯定不为 null，否则很有可能会因为日志的问题而导致应用产生空指针异常。 2.6.11 异常堆栈异常堆栈一般会出现在 ERROR 或者 WARN 级别的日志中，异常堆栈含有方法调用链的系统，以及异常产生的根源。异常堆栈的日志属于上一行日志的，在日志收集时需要将其划至上一行中。 2.7 最佳实践2.7.1 日志格式Code12019-12-01 00:00:00.000|pid|log-level|[svc-name,trace-id,span-id,user-id,biz-id]|thread-name|package-name.class-name : log message 时间 pid，pid log-level，日志级别 svc-name，应用名称 trace-id，调用链标识 span-id，调用层级标识 user-id，用户标识 biz-id，业务标识 thread-name，线程名称 package-name.class-name，日志记录器名称 log message，日志消息体 2.7.2 日志模块扩展日志模块是基于以下技术点做扩展的。 Slf4j MDC 实现原理（暂不开展详解，如有兴趣私下沟通） Opentracing Scope 原理（暂不开展详解，如有兴趣私下沟通） 在每个 tracing 链路中，将 Opentracing Scope 中的上下文信息放置 MDC 中，根据 Spring Boot Logging 扩展接口扩展的取值逻辑 logging.pattern.level 的取值逻辑。 相关源码参考： Spring Cloud Sleuth： https://github.com/spring-cloud/spring-cloud-sleuth/blob/master/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/autoconfig/TraceEnvironmentPostProcessor.java https://github.com/spring-cloud/spring-cloud-sleuth/blob/master/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/log/Slf4jCurrentTraceContext.java 修改 logback 配置文件中每个 appender 的 pattern 为以下默认值即可实现标准化。 Code12%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}}|${PID:- }|%level|${LOG_LEVEL_PATTERN:-%5p}|%t|%-40.40logger{39}: %msg%n logback.xml 节选 Code1234567891011121314151617181920212223242526272829303132333435363738 ${LOG_PATH}/${APP_NAME}-info.log ${LOG_PATH}/${APP_NAME}-info.%d{yyyy-MM-dd-HH}.%i.log 48 1GB 20GB ${LOG_PATTERN} INFO ACCEPT DENY 代码使用示例： Code12345678910@Overridepublic Result page(@RequestParam(value = \"page-num\", defaultValue = \"1\") int pageNum, url: http://liweichao.com:10011/actuator/health> http-method: GET> request-header: [Accept:\"text/plain, text/*, */*\", Connection:\"close\", User-Agent:\"Consul Health Check\", Host:\"liweichao.com:10011\", Accept-Encoding:\"gzip\"]> request-time: 2019-11-26 15:01:03.309> querystring: -> payload: -> extra-param: -< response-time: 2019-11-26 15:01:03.332< take-time: 23< http-status: 200< response-header: [content-type:\"application/vnd.spring-boot.actuator.v2+json;charset=UTF-8\", content-size:\"15\"]< response-data: {\"status\":\"UP\"} 特定格式日志可按格式创建索引更方便聚焦查询分析和告警，如根据 take-time，http-status，biz-code 等值。 引入相关maven坐标xml1234567891011121314 org.springframework.bootgroupId> spring-boot-starter-webartifactId>dependency> org.codehaus.janinogroupId> janinoartifactId> 2.6.1version>dependency> 配置参考xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157 springboot-base-framecontextName> ${CONSOLE_LOG_PATTERN}pattern> ${logback.charset}charset> encoder> System.outtarget> appender> then> if> ${logback.dir}/${logback.info.filename}.logfile> trueappend> INFOlevel> filter> ${logback.dir}/${logback.info.filename}.%d{yyyy-MM-dd}.%i.logfileNamePattern> ${logback.maxhistory}maxHistory>| ${logback.maxfilesize}maxFileSize> rollingPolicy> ${FILE_LOG_PATTERN}pattern> ${logback.charset}charset> encoder> appender> ${logback.dir}/${logback.all.filename}.logfile> trueappend> ${logback.dir}/${logback.all.filename}.%d{yyyy-MM-dd}.%i.log.gzfileNamePattern> ${logback.maxhistory}maxHistory> ${logback.maxfilesize}maxFileSize> rollingPolicy> ${FILE_LOG_PATTERN}pattern> ${logback.charset}charset> encoder> appender> ${logback.dir}/${logback.error.filename}.logfile> trueappend> ERRORlevel> filter> ${logback.dir}/${logback.error.filename}.%d{yyyy-MM-dd}.%i.log.gzfileNamePattern> ${logback.maxhistory}maxHistory> ${logback.maxfilesize}maxFileSize> rollingPolicy> ${FILE_LOG_PATTERN}pattern> ${logback.charset}charset> encoder> appender> root>configuration> 参考文献 Java日志记录最佳实践 ：https://www.jianshu.com/p/546e9aace657) 别在 Java 代码里乱打日志了，这才是打印日志的正确姿势！：https://mp.weixin.qq.com/s/hJvkRlt9xQbWhYy1G7ZDsw 阿里云日志服务：https://help.aliyun.com/product/28958.html?spm=a2c4g.11186623.3.1.7cfd735dv8i1pB Spring Boot Logging：https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/html/spring-boot-features.html#boot-features-logging Spring Cloud Sleuth：https://github.com/spring-cloud/spring-cloud-sleuth Opentracing：https://github.com/opentracing 文章来源于 https://mp.weixin.qq.com/s/UDVr13gBS-_VhsXn6FZQEg","categories":[],"tags":[]},{"title":"power designer日常使用","slug":"power designer日常使用","date":"2020-01-09T01:24:11.000Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2020/01/09/power designer日常使用/","link":"","permalink":"https://calebzhao.github.io/2020/01/09/power%20designer%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1、Check Model错误解决1.1、Datatype attributes错误、PowerDesigner生成mysql脚本后多了一个national关键字 解决方案： 选择Database->Edit Current DBMS菜单，如下图： 选择National,勾选Computed，如下图所示：","categories":[{"name":"mysql","slug":"mysql","permalink":"https://calebzhao.github.io/categories/mysql/"}],"tags":[{"name":"power designer","slug":"power-designer","permalink":"https://calebzhao.github.io/tags/power-designer/"},{"name":"mysql","slug":"mysql","permalink":"https://calebzhao.github.io/tags/mysql/"}]},{"title":"spring cloud - bootstrapContext(一)","slug":"spring cloud - bootstrapContext(一)","date":"2020-01-06T02:11:23.000Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2020/01/06/spring cloud - bootstrapContext(一)/","link":"","permalink":"https://calebzhao.github.io/2020/01/06/spring%20cloud%20-%20bootstrapContext(%E4%B8%80)/","excerpt":"","text":"1、前言springcloud是基于springboot开发的，所以读者在阅读此文前最好已经了解了springboot的工作原理。本文将不阐述springboot的工作逻辑。 在整个 Spring Boot 启动的生命周期过程中，有一个阶段是 prepare environment。在这个阶段，会publish 一个 ApplicationEnvironmentPreparedEvent，通知所有对这个事件感兴趣的 Listener,提供对 Environment 做更多的定制化的操作。Spring Cloud 定义了一个BootstrapApplicationListener，在 BootstrapApplicationListener 的处理过程中会创建spring cloud的ApplicationContext。 2、spring cloud contextspringboot cloud context在官方的文档中在第一点被提及，是用户ApplicationContext的父级上下文，笔者称呼为BootstrapContext。根据springboot的加载机制，很多第三方以及重要的Configuration配置均是保存在了spring.factories文件中。 笔者翻阅了spring-cloud-context模块下的对应文件，见如下: properties123456789101112131415161718# AutoConfigurationorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\\org.springframework.cloud.autoconfigure.LifecycleMvcEndpointAutoConfiguration,\\org.springframework.cloud.autoconfigure.RefreshAutoConfiguration,\\org.springframework.cloud.autoconfigure.RefreshEndpointAutoConfiguration,\\org.springframework.cloud.autoconfigure.WritableEnvironmentEndpointAutoConfiguration# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.cloud.bootstrap.BootstrapApplicationListener,\\org.springframework.cloud.bootstrap.LoggingSystemShutdownListener,\\org.springframework.cloud.context.restart.RestartListener# Bootstrap componentsorg.springframework.cloud.bootstrap.BootstrapConfiguration=\\org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration,\\org.springframework.cloud.bootstrap.encrypt.EncryptionBootstrapConfiguration,\\org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration 涉及的主要分三类，笔者优先分析监听器，其一般拥有更高的优先级并跟其他两块有一定的关联性。除了日志监听器笔者不太关注，其余两个分步骤来分析 2.1、RestartListener重启监听器，应该是用于刷新上下文的，直接查看下其复写的方法 java1234567891011121314151617181920212223242526272829303132public class RestartListener implements SmartApplicationListener { private ConfigurableApplicationContext context; private ApplicationPreparedEvent event; @Override public void onApplicationEvent(ApplicationEvent input) { // 判断是否是ApplicationPreparedEvent事件, 如果是先缓存context if (input instanceof ApplicationPreparedEvent) { this.event = (ApplicationPreparedEvent) input; if (this.context == null) { this.context = this.event.getApplicationContext(); } } // 上下文刷新结束事件(ContextRefreshedEvent)，重新发布ApplicationPreparedEvent事件 else if (input instanceof ContextRefreshedEvent) { if (this.context != null && input.getSource().equals(this.context) && this.event != null) { // 注意这里的this.event的赋值是在前面的ApplicationPreparedEvent事件发生时赋值的 this.context.publishEvent(this.event); } } else { // 上下文关闭事件传播至此，则开始清空所拥有的对象 if (this.context != null && input.getSource().equals(this.context)) { this.context = null; this.event = null; } } }} 上述的刷新事件经过查阅，与org.springframework.cloud.context.restart.RestartEndpoint类有关，这个就后文再分析好了 2.2、BootstrapApplicationListener按照顺序分析此监听器 1、优先看下其类结构 java123public class BootstrapApplicationListener implements ApplicationListener, Ordered {} 此监听器是用于响应ApplicationEnvironmentPreparedEvent应用环境变量预初始化事件，表明BootstrapContext的加载时机在用户上下文(spring boot的ApplicationContext)之前，且其加载顺序比ConfigFileApplicationListener监听器超前，这点稍微强调下，监听器的具体执行顺序见我的另一篇文章Spring Boot启动流程分析。 2、接下来分析下其复写的方法*onApplicationEvent(ApplicationEnvironmentPreparedEvent event) java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@Overridepublic void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) { // 获取spring boot的环境变量对象 ConfigurableEnvironment environment = event.getEnvironment(); // 读取spring.cloud.bootstrap.enabled环境属性，默认为true。可通过系统变量设置 // 这行代码的意图是用于配置是否启用spring cloud if (!environment.getProperty(\"spring.cloud.bootstrap.enabled\", Boolean.class, true)) { // 已经设置过spring.cloud.bootstrap.enabled属性为false，代表不启用spring cloud功能，直接返回 // 那么就不会创建id为bootstrap的父ApplicationContext return; } // 运行到这里表示启用spring cloud // don't listen to events in a bootstrap context // 不监听bootstrap的发布的ApplicationEnvironmentPreparedEvent事件， 防止重复创建id为bootstrap的ApplicationContext // 这里判断environment中是否包含名称为\"bootstrap\"的属性源， // 注意后续的bootstrapServiceContext()方法中会为spring cloud的environment添加名称为\"bootstrap\"的属性源， // 所以bootstrapServiceContext()方法中为spring cloud创建的SpringApplication在调用其run()方法时发布 // ApplicationEnvironmentPreparedEvent事件又会进入当前类中，但是由于该bootstrap的environment(spring cloud的)已经 // 有名称为\"bootstrap\"的属性源，所以不会继续往后执行。 if (environment.getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME)) { // 说明当前是spring cloud启动过程中发布的ApplicationEnvironmentPreparedEvent事件，不能再次启动spring cloud了 return; } ConfigurableApplicationContext context = null; // 从命令行参数、系统属性、系统环境变量解析spring.cloud.bootstrap.name的值，如果都未指定则使用默认名称bootstrap String configName = environment.resolvePlaceholders(\"${spring.cloud.bootstrap.name:bootstrap}\"); // 寻找当前环境是否已存在BootstrapContext， // 这里的event.getSpringApplication().getInitializers()返回的是SpringApplication.run()方法启动时SpringApplication的构造 // 方法中通过SpringFacoriesLoader获取到的ApplicationContextInitializer。 // 按照顺序如下, 括号中的jar文件名代表其对应的spring.factories文件出处： // org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer （spring-boot-autoconfigure-2.2.1.RELEASE.jar） // org.springframework.boot.context.config.DelegatingApplicationContextInitializer （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.context.ContextIdApplicationContextInitializer （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener （spring-boot-autoconfigure-2.2.1.RELEASE.jar） // org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer （spring-boot-2.2.1.RELEASE.jar） for (ApplicationContextInitializer initializer : event.getSpringApplication() .getInitializers()) { if (initializer instanceof ParentContextApplicationContextInitializer) { context = findBootstrapContext( (ParentContextApplicationContextInitializer) initializer, configName); } } // 如果spring cloud的BootstrapContext还没有被创建，则开始创建 if (context == null) { context = bootstrapServiceContext(environment, event.getSpringApplication(), configName); // 注册注销监听器 event.getSpringApplication() .addListeners(new CloseContextOnFailureApplicationListener(context)); } // 将spring cloud的applicationContext中的ApplicationContextInitializers添加到spring boot的Context上 apply(context, event.getSpringApplication(), environment);}// 注意调用apply时spring cloud已经启动完成了，而当前的spring boot还处于ApplicationEnvironmentPreparedEvent事件执行阶段private void apply(ConfigurableApplicationContext context, SpringApplication application, ConfigurableEnvironment environment) { @SuppressWarnings(\"rawtypes\") // 从spring cloud的applicationContext中获取bean类型为ApplicationContextInitializer的事件监听器 // spring cloud启动过程中会注册所有的@Bean注解声明的组件, List initializers = getOrderedBeansOfType(context, ApplicationContextInitializer.class); // 将spring cloud的applicationContext中的ApplicationContextInitializers添加到spring boot的Context上 application.addInitializers(initializers .toArray(new ApplicationContextInitializer[initializers.size()])); addBootstrapDecryptInitializer(application);} 逻辑很简单，上面的代码注释已经给出每一步详细说明，这里再梳理下： spring.cloud.bootstrap.enabled 用于配置是否启用BootstrapContext，默认为true。可通过命令行参数、系统属性、系统环境变量设定 spring.cloud.bootstrap.name 用于加载bootstrap对应配置文件的别名，默认为bootstrap，在ConfigFileApplicationListener事件中会使用该名称加载配置文件 BootstrapContext上的beanType为ApplicationContextInitializer类型的bean对象集合会被注册至用户的Context上 3、重点看下BootstrapContext的创建过程，源码比较长 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139private ConfigurableApplicationContext bootstrapServiceContext( ConfigurableEnvironment environment, final SpringApplication application, String configName) { // 创建spring cloud 的一个空的environment StandardEnvironment bootstrapEnvironment = new StandardEnvironment(); // 获取上面创建spring cloud 的可变属性源 MutablePropertySources bootstrapProperties = bootstrapEnvironment.getPropertySources(); // 移除spring cloud的所有属性源，让spring cloud的environment变成一个不包含任何属性源的空environment for (PropertySource source : bootstrapProperties) { bootstrapProperties.remove(source.getName()); } // 从spring boot的environment获取\"spring.cloud.bootstrap.location\"属性, 一般通过命令行参数、jvm系统属性、系统环境变量设置，默认为空 String configLocation = environment.resolvePlaceholders(\"${spring.cloud.bootstrap.location:}\"); // 创建spring cloud的属性源的数据源，后面会把这个map加进去spring cloud的environment中 Map bootstrapMap = new HashMap(); // 特别注意：\"spring.config.name\"是用于加载配置文件的名称，默认为bootstrap， // 在ConfigFileApplicationListener事件中会获取属性为\"spring.config.name\"的值作为配置文件的名称去加载配置文件 bootstrapMap.put(\"spring.config.name\", configName); bootstrapMap.put(\"spring.main.web-application-type\", \"none\"); if (StringUtils.hasText(configLocation)) { // 特别注意：\"spring.config.location\"是用于加载配置文件的搜索路径，默认为空， // 在ConfigFileApplicationListener事件中会获取属性为\"spring.config.location\"的值，从该路径下去加载配置文件 bootstrapMap.put(\"spring.config.location\", configLocation); } // 为spring cloud的environment添加name为\"bootstrap\"的属性源，属性源中包括2个属性\"spring.config.name\"及\"spring.config.location\" bootstrapProperties.addFirst(new MapPropertySource(BOOTSTRAP_PROPERTY_SOURCE_NAME, bootstrapMap)); // 遍历spring boot的属性源 for (PropertySource source : environment.getPropertySources()) { // 如果是占位符的属性源就跳过 if (source instanceof StubPropertySource) { continue; } // 将spring boot的属性源添加到spring cloud的environment中， // 注意这里是addLast bootstrapProperties.addLast(source); } // 创建spring cloud自身的SpringApplication了， // SpringApplicationBuilder的构造方法会创建SpringApplication对象（又获取ApplicationContextInitializer和ApplicationListener） SpringApplicationBuilder builder = new SpringApplicationBuilder() // 指定激活的环境，此处activeProfiles是通过系统变量\"spring.profiles.active\"设置的 .profiles(environment.getActiveProfiles()) // 关闭banner输出 .bannerMode(Mode.OFF) // 设置spring cloud的环境，设置后在调用run()方法时就不会再创建了 // 这里可以回顾下SpringApplication.getOrCreateEnvironment()方法的实现 .environment(bootstrapEnvironment) // 不打印启动日志 .registerShutdownHook(false).logStartupInfo(false) // 非web .web(WebApplicationType.NONE); // 返回SpringApplicationBuilder创建的SpringApplication final SpringApplication builderApplication = builder.application(); // SpringApplication的构造方法中有this.mainApplicationClass = deduceMainApplicationClass();这行代码会获取mainApplicationClass // 所以builderApplication.getMainApplicationClass()一般不会返回为null if (builderApplication.getMainApplicationClass() == null) { // 不会进入这里 builder.main(application.getMainApplicationClass()); } if (environment.getPropertySources().contains(\"refreshArgs\")) { // If we are doing a context refresh, really we only want to refresh the // Environment, and there are some toxic listeners (like the // LoggingApplicationListener) that affect global static state, so we need a // way to switch those off. builderApplication.setListeners(filterListeners(builderApplication.getListeners())); } // 增加入口类BootstrapImportSelectorConfiguration builder.sources(BootstrapImportSelectorConfiguration.class); // 关键代码，创建spring cloud自身的ApplicationContext，又会把spring boot的SpringApplication.run()方法的流程全部走一遍 final ConfigurableApplicationContext context = builder.run(); // 设置spring cloud的ApplicationContext的id为\"bootstrap\" context.setId(\"bootstrap\"); // 这里的addAncestorInitializer方法的第1个参数application是spring boot的SpringApplication对象 // 而第2个参数context是上一行代码返回的spring cloud的ApplicationContext // 这里的意图是配置spring cloud的bootstrapContext为spring boot的Context的父上下文 addAncestorInitializer(application, context); // spring cloud的环境中现在有一些属性是我们不想在父ApplicationContext中看到的，所以把它移除(稍后会添加回来) bootstrapProperties.remove(BOOTSTRAP_PROPERTY_SOURCE_NAME); // 合并spring cloud中name为\"defaultProperties\"属性源至spring boot中，注意同名属性不覆盖 mergeDefaultProperties(environment.getPropertySources(), bootstrapProperties); // 返回spring cloud的ApplicationContext return context;}/*** 这个方法的目的如下：* 1、如果spring cloud中有name为\"springCloudDefaultProperties\"的属性源，而spring boot中没有该名称的属性源，则直接把* spring cloud的name为\"springCloudDefaultProperties\"的属性源加到spring boot的environment的末尾。** 2、如果spring cloud中有name为\"springCloudDefaultProperties\"的属性源，spring boot中也有该名称的属性源，则把spring cloud* 的属性源合并到spring boot的environment中，如果在spring cloud中的属性在spring boot中不存在则追加到spring boot中，特别注意* 如果spring cloud中的属性在spring boot中也存在，则不会覆盖，也就是说spring boot和spring cloud拥有相同key的属性时，spring boot的* 配置文件中的属性优先级高，不会合并该属性。* * @param environment 它是spring boot的environment* @param bootstrap 它是spring cloud的environment*/private void mergeDefaultProperties(MutablePropertySources environment, MutablePropertySources bootstrap) { String name = DEFAULT_PROPERTIES; // 判断spring cloud中是否有name为\"springCloudDefaultProperties\"的属性源 if (bootstrap.contains(name)) { // 获得spring cloud中name为\"springCloudDefaultProperties\"的属性源 PropertySource source = bootstrap.get(name); // 判断spring boot中是否有name为\"springCloudDefaultProperties\"的属性源 if (!environment.contains(name)) { // 如果spring cloud中有name为\"springCloudDefaultProperties\"的属性源，而spring boot中没有该名称的属性源，则直接把 // spring cloud的name为\"springCloudDefaultProperties\"的属性源加到spring boot的environment的末尾 environment.addLast(source); } // spring cloud中有name为\"springCloudDefaultProperties\"的属性源，spring boot中也有该名称的属性源 else { // 获得spring boot中name为\"springCloudDefaultProperties\"的属性源 PropertySource target = environment.get(name); // 判断spring boot和spring cloud的name为\"springCloudDefaultProperties\"的属性源的类型是否是MapPropertySource类型 if (target instanceof MapPropertySource && target != source && source instanceof MapPropertySource) { // 获得spring boot中name为\"springCloudDefaultProperties\"的属性源的底层数据源 Map targetMap = ((MapPropertySource) target).getSource(); // 获得spring cloud中name为\"springCloudDefaultProperties\"的属性源的底层数据源 Map map = ((MapPropertySource) source).getSource(); // 遍历spring cloud中name为\"springCloudDefaultProperties\"的属性源的底层数据源 for (String key : map.keySet()) { // 判断spring cloud中的属性在spring boot是否存在，若spring cloud中的属性在spring boot中不存在则追加到spring boot中 if (!target.containsProperty(key)) { targetMap.put(key, map.get(key)); } // 若spring cloud中的属性在spring boot中存在则忽略，spring cloud不覆盖spring boot的同名属性 } } } } mergeAdditionalPropertySources(environment, bootstrap);} 此处也对上述的代码作下简单的小结： spring.cloud.bootstrap.location变量用于配置bootstrapContext配置文件的加载路径，可用System设置，默认则采取默认的文件搜寻路径；与spring.cloud.bootstrap.name搭配使用 bootstrapContext对应的activeProfiles可采用spring.active.profiles系统变量设置，注意是System变量。当然也可以通过bootstrap.properties/bootstrap.yml配置文件设置 bootstrapContext的重要入口类为BootstrapImportSelectorConfiguration，此也是下文的分析重点 bootstrapContext的contextId为bootstrap。即使配置了spring.application.name属性也会被设置为前者，且其会被设置为用户Context的父上下文 bootstrap.(yml | properties)上的配置会被合并至用户级别的Environment中的defaultProperties集合中，且其相同的KEY会被丢弃，不同KEY会被保留。即其有最低的属性优先级 通过上述的代码均可以得知，bootstrapContext也是通过springboot常见的SpringApplication方式来创建的，但其肯定有特别的地方。特别之处就在BootstrapImportSelectorConfiguration类，其也与上述spring.factories文件中org.springframework.cloud.bootstrap.BootstrapConfiguration的Key有直接的关系，我们下文重点分析。 2.3、BootstrapImportSelector首先回顾bootstrapServiceContext()方法中的BootstrapImportSelectorConfiguration设置过程。 java12345678private ConfigurableApplicationContext bootstrapServiceContext(){ // ...省略代码 // 增加入口类BootstrapImportSelectorConfiguration builder.sources(BootstrapImportSelectorConfiguration.class); // ...省略代码} 承接前文监听器对bootstrapContext创建的引导，可以看到到其主要入口类为BootstrapImportSelectorConfiguration。下文将基于此类进行简单的分析。 其源码如下： java12345@Configuration(proxyBeanMethods = false)@Import(BootstrapImportSelector.class)public class BootstrapImportSelectorConfiguration {} 嗯，引入了延迟加载类BootstrapImportSelector，那就继续往下看下此会延迟加载哪些类，直接去观察其主方法。 java12345678910111213141516171819202122232425262728293031323334353637383940414243public class BootstrapImportSelector implements EnvironmentAware, DeferredImportSelector { private Environment environment; private MetadataReaderFactory metadataReaderFactory = new CachingMetadataReaderFactory(); @Override public void setEnvironment(Environment environment) { this.environment = environment; } @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); // 加载classpath路径下所有spring.factories文件中以org.springframework.cloud.bootstrap.BootstrapConfiguration作为Key的所有类 List names = new ArrayList(SpringFactoriesLoader.loadFactoryNames(BootstrapConfiguration.class, classLoader)); // 支持通过设置spring.cloud.bootstrap.sources属性来加载指定的类 names.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray( this.environment.getProperty(\"spring.cloud.bootstrap.sources\", \"\")))); List elements = new ArrayList(); // 创建用于排序的OrderedAnnotatedElement for (String name : names) { try { elements.add( new OrderedAnnotatedElement(this.metadataReaderFactory, name)); } catch (IOException e) { continue; } } // 对以org.springframework.cloud.bootstrap.BootstrapConfiguration作为Key的所有类进行就地排序 AnnotationAwareOrderComparator.sort(elements); // 得到排序后的名称 String[] classNames = elements.stream().map(e -> e.name).toArray(String[]::new); return classNames; } // ...省略后续代码} 上述的代码很简单，其会去加载classpath路径下所有spring.factories文件中以org.springframework.cloud.bootstrap.BootstrapConfiguration作为Key的所有类；同时springcloud也支持通过设置spring.cloud.bootstrap.sources属性来加载指定类。 下面就先以springcloud context板块内的spring.factories作为分析的源头 spring-cloud-context-2.2.0.RELEASE.jar!\\META-INF\\spring.factories 共4个 properties1234567# Bootstrap componentsorg.springframework.cloud.bootstrap.BootstrapConfiguration=\\org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration,\\org.springframework.cloud.bootstrap.encrypt.EncryptionBootstrapConfiguration,\\org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration spring-cloud-netflix-eureka-client-2.2.0.RELEASE.jar!\\META-INF\\spring.factories共1个 properties12org.springframework.cloud.bootstrap.BootstrapConfiguration=\\org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceBootstrapConfiguration 在分析上述的源码之前，笔者必须得清楚现在bootstrapContext加载的配置文件默认为bootstrap.properties抑或是bootstrap.yml，其属性已经被加入至相应的Environment对象中。基于此我们再往下走，以免犯糊涂。 2.3.1、PropertySourceBootstrapConfiguration配置源的加载，此Configuration主要用于确定是否外部加载的配置属性复写Spring内含的环境变量。注意其是ApplicationContextInitializer接口的实现类，前文已经提到，bootstrapContext上的此接口的bean类都会被注册至子级的SpringApplication对象上。直接看下主要的代码片段吧 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/*** spring cloud通过 PropertySourceLocator 加载外部环境属性源**/@Configuration(proxyBeanMethods = false)@EnableConfigurationProperties(PropertySourceBootstrapProperties.class)public class PropertySourceBootstrapConfiguration implements ApplicationContextInitializer, Ordered { // BOOTSTRAP_PROPERTY_SOURCE_NAME常量的值为\"bootstrapProperties\" public static final String BOOTSTRAP_PROPERTY_SOURCE_NAME = BootstrapApplicationListener.BOOTSTRAP_PROPERTY_SOURCE_NAME + \"Properties\"; private int order = Ordered.HIGHEST_PRECEDENCE + 10; // 注意这里注入了PropertySourceLocator @Autowired(required = false) private List propertySourceLocators = new ArrayList(); public void setPropertySourceLocators(Collection propertySourceLocators) { this.propertySourceLocators = new ArrayList(propertySourceLocators); } @Override public void initialize(ConfigurableApplicationContext applicationContext) { // 创建1个具有复合功能的属性源 CompositePropertySource composite = new OriginTrackedCompositePropertySource(BOOTSTRAP_PROPERTY_SOURCE_NAME); // 对propertySourceLocators排序 AnnotationAwareOrderComparator.sort(this.propertySourceLocators); // 一个flag, 标识是否加载到外部属性源 boolean empty = true; // 此处为子级的环境变量对象 ConfigurableEnvironment environment = applicationContext.getEnvironment(); // 通过PropertySourceLocator接口去加载外部配置 for (PropertySourceLocator locator : this.propertySourceLocators) { PropertySource source = null; // 重点：加载外部配置， spring cloud config、nacos的集合就是通过PropertySourceLocator来实现的 source = locator.locate(environment); if (source == null) { continue; } logger.info(\"Located property source: \" + source); // 把从外部环境加载到的属性源加到前面定义的复合属性源中 composite.addPropertySource(source); empty = false; } // 判断是否从外部环境加载到任何1个属性源 if (!empty) { // 获取spring boot的可变属性源 MutablePropertySources propertySources = environment.getPropertySources(); String logConfig = environment.resolvePlaceholders(\"${logging.config:}\"); LogFile logFile = LogFile.get(environment); // 判断spring boot的environment中是否存在name为\"bootstrapProperties\"的属性源 if (propertySources.contains(BOOTSTRAP_PROPERTY_SOURCE_NAME)) { // 移除spring boot的environment中name为\"bootstrapProperties\"的属性源 propertySources.remove(BOOTSTRAP_PROPERTY_SOURCE_NAME); } // 确定属性读取的先后顺序 insertPropertySources(propertySources, composite); // 日志相关，不管 reinitializeLoggingSystem(environment, logConfig, logFile); // 设置日志级别，不管 setLogLevels(applicationContext, environment); handleIncludedProfiles(environment); } } /** * 将远程属性源以适合的顺序插入到本地environment中： * 插入前要确定远程属性源与本地属性源的优先级哪个高(属性读取的先后顺序)，也就是通过key获取value时先读取谁的配置。 * * 这里的相关代码与spring.cloud.config.allowOverride、spring.cloud.config.overrideNone、spring.cloud.config.overrideSystemProperties配置相关 * * @param propertySources 它是spring boot的可变属性源 * @parm composite 复合属性源，里面的属性源是spring cloud从外部环境加载到的 */ private void insertPropertySources(MutablePropertySources propertySources, CompositePropertySource composite) { // 将从外部环境加载的属性源添加到新创建的可变属性源中 MutablePropertySources incoming = new MutablePropertySources(); incoming.addFirst(composite); // 从外部环境加载的属性源中获取key为\"spring.cloud.config\"的值，并将其值封装到PropertySourceBootstrapProperties类中 PropertySourceBootstrapProperties remoteProperties = new PropertySourceBootstrapProperties(); Binder.get(environment(incoming)).bind(\"spring.cloud.config\", Bindable.ofInstance(remoteProperties)); // 关键代码了， 如果配置影响了远程配置与本地配置的优先级： // spring.cloud.config.allowOverride=true // spring.cloud.config.overrideNone=true // spring.cloud.config.overrideSystemProperties=false // remoteProperties.isAllowOverride() // 1、远程配置是否允许被本地配置覆盖（是否允许允许本地属性配置覆盖远程属性配置） // remoteProperties.isOverrideNone() // 2、远程配置允许被本地配置覆盖的情况下，判断远程属性的任意配置是否都允许被本地配置覆盖 // remoteProperties.isOverrideSystemProperties() // 3、远程配置允许被本地配置覆盖的情况下，远程属性不能被本地配置任意覆盖， 再判断远程配置是否可以覆盖本地系统环境变量 if (! remoteProperties.isAllowOverride() || (!remoteProperties.isOverrideNone() && remoteProperties.isOverrideSystemProperties())) { propertySources.addFirst(composite); return; } // 判断远程属性的任意配置是否都允许被本地配置覆盖 if (remoteProperties.isOverrideNone()) { // 运行到这里说明：远程属性的任意配置都允许被本地配置覆盖， 也就是说远程配置的优先级低于本地配置， // 那么把远程配置添加到environment的最后(属性源的位置越靠前代表其优先级越高，越靠后则优先级越低) propertySources.addLast(composite); return; } // 本地环境是否包含系统环境变量属性源， SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME常量的值为\"systemEnvironment\" if (propertySources .contains(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME)) { // 远程配置是否可以覆盖本地系统环境变量配置 if (!remoteProperties.isOverrideSystemProperties()) { // 远程配置不能覆盖本地系统环境变量配置，也就是说本地系统环境变量的优先级高于远程配置， // 那么把远程属性源添加在本地系统环境变量属性源的后面 propertySources.addAfter( StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, composite); } else { // 运行到这里表示远程配置可以覆盖本地系统环境变量，也就是说远程配置的优先级高于本地系统环境变量， // 那么把远程属性源添加到本地系统环境变量属性源的前面 propertySources.addBefore( StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, composite); } } else { propertySources.addLast(composite); } }} 上述的代码就涉及两点： 一个是通过PropertySourceLocator接口加载外部配置 一个是用于解析以spring.cloud.config为开头的PropertySourceBootstrapProperties属性，默认情况下，外部配置比内部变量有更高的优先级。 2.3.2、ConfigurationPropertiesRebinderAutoConfiguration通过命名便会发现其跟刷新属性的功能有关，先看下其类结构： java1234567@Configuration(proxyBeanMethods = false)@ConditionalOnBean(ConfigurationPropertiesBindingPostProcessor.class)public class ConfigurationPropertiesRebinderAutoConfiguration implements ApplicationContextAware, SmartInitializingSingleton { } 上述代码表示其依据于当前类环境存在ConfigurationPropertiesBindingPostProcessorBean这个bean才会被应用，仔细查阅了下，发现只要有使用到@EnableConfigurationProperties注解即就会被注册。看来此配置跟ConfigurationProperties注解也有一定的关联性。 下面看看ConfigurationPropertiesBindingPostProcessor的源码： ConfigurationPropertiesBindingPostProcessor java123456789101112131415161718192021222324252627282930313233public class ConfigurationPropertiesBindingPostProcessor implements BeanPostProcessor, PriorityOrdered, ApplicationContextAware, InitializingBean { // ...省略代码 // 实现了InitializingBean接口， 在bean的属性初始化后会调用该方法 @Override public void afterPropertiesSet() throws Exception { this.registry = (BeanDefinitionRegistry) this.applicationContext.getAutowireCapableBeanFactory(); this.binder = ConfigurationPropertiesBinder.get(this.applicationContext); } // 实现了BeanPostProcessor @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { bind(ConfigurationPropertiesBean.get(this.applicationContext, bean, beanName)); return bean; } private void bind(ConfigurationPropertiesBean bean) { if (bean == null || hasBoundValueObject(bean.getName())) { return; } Assert.state(bean.getBindMethod() == BindMethod.JAVA_BEAN, \"Cannot bind @ConfigurationProperties for bean '\" + bean.getName() + \"'. Ensure that @ConstructorBinding has not been applied to regular bean\"); try { this.binder.bind(bean); } catch (Exception ex) { throw new ConfigurationPropertiesBindException(bean, ex); } }} 本文就罗列笔者比较关注的几个地方 1.ConfigurationPropertiesRebinder对象的创建 java12345678@Bean@ConditionalOnMissingBean(search = SearchStrategy.CURRENT)public ConfigurationPropertiesRebinder configurationPropertiesRebinder( ConfigurationPropertiesBeans beans) { ConfigurationPropertiesRebinder rebinder = new ConfigurationPropertiesRebinder( beans); return rebinder;} 此类读者可以自行翻阅代码，可以发现其暴露了JMX接口以及监听了springcloud context自定义的EnvironmentChangeEvent事件。看来其主要用来刷新ApplicationContext上的beans(含@ConfigurationProperties注解)对象集合 2.ConfigurationPropertiesBeans对象的创建 BeanPostProcessor将PropertySources绑定到使用@ConfigurationProperties注释的bean。 java12345@Bean@ConditionalOnMissingBean(search = SearchStrategy.CURRENT)public ConfigurationPropertiesBeans configurationPropertiesBeans() { return new ConfigurationPropertiesBeans();} 配合@ConfigurationProperties注解，其会缓存ApplicationContext上的所有含有ConfigurationProperties注解的bean。与第一点所提的ConfigurationPropertiesRebinder对象搭配使用 3.实例化结束后刷新父级ApplicationContext上的属性 java1234567891011121314151617@Overridepublic void afterSingletonsInstantiated() { // After all beans are initialized explicitly rebind beans from the parent // so that changes during the initialization of the current context are // reflected. In particular this can be important when low level services like // decryption are bootstrapped in the parent, but need to change their // configuration before the child context is processed. if (this.context.getParent() != null) { // TODO: make this optional? (E.g. when creating child contexts that prefer to // be isolated.) ConfigurationPropertiesRebinder rebinder = this.context .getBean(ConfigurationPropertiesRebinder.class); for (String name : this.context.getParent().getBeanDefinitionNames()) { rebinder.rebind(name); } }} 2.3.3、EncryptionBootstrapConfiguration与属性读取的加解密有关，跟JDK的keystore也有一定的关联，具体就不去解析了。读者可自行分析 3、Bean加载问题此处本文插入这个Bean的加载问题，因为笔者发现SpringApplication会被调用两次，那么ApplicationContext实例也会被创建两次。那么基于@Configuration修饰过的自定义的Bean是不是也会被加载两次呢？？ 经过在cloud环境下编写了一个简单的Bean java12345678910111213141516171819202122package com.example.clouddemo;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.context.annotation.Configuration;/** * @author nanco * ------------- * ------------- * @create 19/8/20 */@Configurationpublic class TestApplication implements ApplicationContextAware { @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { System.out.println(\"application parent context id: \" + applicationContext.getParent().getId()); System.out.println(\"application context id: \" + applicationContext.getId()); }} 且在application.properties文件中指定spring.application.name=springChild以及bootstrap.properties文件中也指定spring.application.name=springBootstrap 运行main方法之后打印的关键信息如下: Code12application parent context id: bootstrapapplication context id: springBootstrap-1 经过在org.springframework.boot.context.ContextIdApplicationContextInitializer类上进行断点调试发现只有用户级ApplicationContext被创建的过程中会实例化用户自定义Bean。也就是说bootstrapContext并不会去实例化用户自定义的Bean，这样就很安全。 那么为何如此呢??? 其实很简单，因为bootstrapContext指定的source类只有BootstrapImportSelectorConfiguration，并没有用户编写的启动类，也就无法影响用户级别Context的Bean加载实例化了，并且该类上无@EnableAutoConfiguration、@ComponentScan注解，表明其也不会去扫描我们自己的包以及处理spring.factories文件中@EnableAutoConfiguration注解key对应的配置集合， 而用户自己编写的启动类上都会有@SpringBootApplication注解，该注解是一个复合注解，里面会引入了@EnableAutoConfiguration、@ComponentScan、@SpringBootConfiguration，它会扫描我们自己的包以及处理spring.factories文件中@EnableAutoConfiguration注解key对应的配置集合。","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/tags/spring-cloud/"}]},{"title":"spring入门","slug":"spring入门","date":"2020-01-03T12:20:24.000Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2020/01/03/spring入门/","link":"","permalink":"https://calebzhao.github.io/2020/01/03/spring%E5%85%A5%E9%97%A8/","excerpt":"","text":"spring ioc循环引用造成循环引用的示例，有2个service类，名称分别为AService.java，BService.java AService.java java1234567891011121314151617181920212223package com.calebzhao.spring.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.config.ConfigurableBeanFactory;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Service;/** * @author calebzhao * @date 2020/1/3 20:10 */@Service@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class AService { @Autowired private BService bService; public void test(){ bService.test(); System.out.println(\"AService test\"); }} 注意AService声明了@@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) BService.java java12345678910111213141516171819202122package com.calebzhao.spring.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.config.ConfigurableBeanFactory;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Service;/** * @author calebzhao * @date 2020/1/3 20:10 */@Service@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class BService { @Autowired private AService aService; public void test(){ System.out.println(\"BService test\"); }} 注意BService声明了@@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) 入口类： java123456789101112131415161718192021222324package com.calebzhao.spring;import com.calebzhao.spring.config.MyApplicationContextInitializer;import com.calebzhao.spring.service.AService;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;/** * @author calebzhao * @date 2020/1/3 20:07 */@SpringBootApplicationpublic class SpringDemoApplication { public static void main(String[] args) { SpringApplication application = new SpringApplication(SpringDemoApplication.class); ConfigurableApplicationContext applicationContext = application.run(args); AService aService = applicationContext.getBean(AService.class); aService.test(); }} 启动会报错： Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758\"C:\\Program Files\\Java\\jdk1.8.0_201\\bin\\java.exe\" -XX:TieredStopAtLevel=1 -noverify -Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote -Dspring.jmx.enabled=true -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled=true \"-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.3\\lib\\idea_rt.jar=56442:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.3\\bin\" -Dfile.encoding=UTF-8 -classpath \"C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\rt.jar;F:\\code\\spring-cloud-learn2\\spring-demo\\target\\classes;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\boot\\spring-boot-starter-web\\2.2.1.RELEASE\\spring-boot-starter-web-2.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\boot\\spring-boot-starter\\2.2.1.RELEASE\\spring-boot-starter-2.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\boot\\spring-boot\\2.2.1.RELEASE\\spring-boot-2.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\boot\\spring-boot-autoconfigure\\2.2.1.RELEASE\\spring-boot-autoconfigure-2.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\boot\\spring-boot-starter-logging\\2.2.1.RELEASE\\spring-boot-starter-logging-2.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\ch\\qos\\logback\\logback-classic\\1.2.3\\logback-classic-1.2.3.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\ch\\qos\\logback\\logback-core\\1.2.3\\logback-core-1.2.3.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\slf4j\\slf4j-api\\1.7.29\\slf4j-api-1.7.29.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\apache\\logging\\log4j\\log4j-to-slf4j\\2.12.1\\log4j-to-slf4j-2.12.1.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\apache\\logging\\log4j\\log4j-api\\2.12.1\\log4j-api-2.12.1.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\slf4j\\jul-to-slf4j\\1.7.29\\jul-to-slf4j-1.7.29.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\jakarta\\annotation\\jakarta.annotation-api\\1.3.5\\jakarta.annotation-api-1.3.5.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\spring-core\\5.2.1.RELEASE\\spring-core-5.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\spring-jcl\\5.2.1.RELEASE\\spring-jcl-5.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\yaml\\snakeyaml\\1.25\\snakeyaml-1.25.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\boot\\spring-boot-starter-json\\2.2.1.RELEASE\\spring-boot-starter-json-2.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\com\\fasterxml\\jackson\\core\\jackson-databind\\2.10.0\\jackson-databind-2.10.0.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\com\\fasterxml\\jackson\\core\\jackson-annotations\\2.10.0\\jackson-annotations-2.10.0.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\com\\fasterxml\\jackson\\core\\jackson-core\\2.10.0\\jackson-core-2.10.0.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\com\\fasterxml\\jackson\\datatype\\jackson-datatype-jdk8\\2.10.0\\jackson-datatype-jdk8-2.10.0.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\com\\fasterxml\\jackson\\datatype\\jackson-datatype-jsr310\\2.10.0\\jackson-datatype-jsr310-2.10.0.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\com\\fasterxml\\jackson\\module\\jackson-module-parameter-names\\2.10.0\\jackson-module-parameter-names-2.10.0.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\boot\\spring-boot-starter-tomcat\\2.2.1.RELEASE\\spring-boot-starter-tomcat-2.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\apache\\tomcat\\embed\\tomcat-embed-core\\9.0.27\\tomcat-embed-core-9.0.27.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\apache\\tomcat\\embed\\tomcat-embed-el\\9.0.27\\tomcat-embed-el-9.0.27.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\apache\\tomcat\\embed\\tomcat-embed-websocket\\9.0.27\\tomcat-embed-websocket-9.0.27.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\boot\\spring-boot-starter-validation\\2.2.1.RELEASE\\spring-boot-starter-validation-2.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\jakarta\\validation\\jakarta.validation-api\\2.0.1\\jakarta.validation-api-2.0.1.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\hibernate\\validator\\hibernate-validator\\6.0.18.Final\\hibernate-validator-6.0.18.Final.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\jboss\\logging\\jboss-logging\\3.4.1.Final\\jboss-logging-3.4.1.Final.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\com\\fasterxml\\classmate\\1.5.1\\classmate-1.5.1.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\spring-web\\5.2.1.RELEASE\\spring-web-5.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\spring-beans\\5.2.1.RELEASE\\spring-beans-5.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\spring-webmvc\\5.2.1.RELEASE\\spring-webmvc-5.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\spring-aop\\5.2.1.RELEASE\\spring-aop-5.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\spring-context\\5.2.1.RELEASE\\spring-context-5.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\springframework\\spring-expression\\5.2.1.RELEASE\\spring-expression-5.2.1.RELEASE.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\projectlombok\\lombok\\1.18.10\\lombok-1.18.10.jar\" com.calebzhao.spring.SpringDemoApplication . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.1.RELEASE)initialzer2020-01-03 20:16:47.788 INFO 23148 --- [ main] c.c.spring.SpringDemoApplication : Starting SpringDemoApplication on calebzhao with PID 23148 (F:\\code\\spring-cloud-learn2\\spring-demo\\target\\classes started by calebzhao in F:\\code\\spring-cloud-learn2)2020-01-03 20:16:47.790 INFO 23148 --- [ main] c.c.spring.SpringDemoApplication : No active profile set, falling back to default profiles: default2020-01-03 20:16:48.444 INFO 23148 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)2020-01-03 20:16:48.450 INFO 23148 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]2020-01-03 20:16:48.450 INFO 23148 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.27]2020-01-03 20:16:48.507 INFO 23148 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2020-01-03 20:16:48.507 INFO 23148 --- [ main] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 682 ms2020-01-03 20:16:48.613 INFO 23148 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService 'applicationTaskExecutor'2020-01-03 20:16:48.730 INFO 23148 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ''2020-01-03 20:16:48.732 INFO 23148 --- [ main] c.c.spring.SpringDemoApplication : Started SpringDemoApplication in 1.176 seconds (JVM running for 1.867)Exception in thread \"main\" org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'AService': Unsatisfied dependency expressed through field 'bService'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'BService': Unsatisfied dependency expressed through field 'aService'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'AService': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:116) at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:397) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1429) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:341) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:227) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1155) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveBean(DefaultListableBeanFactory.java:416) at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:349) at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:342) at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1126) at com.calebzhao.spring.SpringDemoApplication.main(SpringDemoApplication.java:22)Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'BService': Unsatisfied dependency expressed through field 'aService'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'AService': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:116) at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:397) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1429) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:341) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:636) ... 13 moreCaused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'AService': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:267) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:276) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1287) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1207) at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:636) ... 24 more","categories":[{"name":"spring","slug":"spring","permalink":"https://calebzhao.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://calebzhao.github.io/tags/spring/"}]},{"title":"Spring中的ResolvableType详解.","slug":"Spring中的ResolvableType","date":"2020-01-02T07:51:40.000Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2020/01/02/Spring中的ResolvableType/","link":"","permalink":"https://calebzhao.github.io/2020/01/02/Spring%E4%B8%AD%E7%9A%84ResolvableType/","excerpt":"","text":"阅读本文之前如果对java中的Type体系不了解请先阅读我的另一篇文章：Java中的Type详解 ResolvableTypeResolvableType为所有的java类型提供了统一的数据结构以及API ，换句话说，一个ResolvableType对象就对应着一种java类型。 我们可以通过ResolvableType对象获取类型携带的信息，举例如下： getSuperType()：获取直接父类型，返回ResolvableType getInterfaces()：获取接口类型， 返回ResolvableType[]数组 getGeneric(int…)：获取类型携带的泛型类型，返回ResolvableType[]数组 resolve()：Type对象到Class对象的转换 另外，ResolvableType的构造方法全部为私有的，我们不能直接new，只能使用其提供的静态方法进行类型获取： forField(Field)：获取指定字段的类型 forMethodParameter(Method, int)：获取指定方法的指定形参的类型 forMethodReturnType(Method)：获取指定方法的返回值的类型 forClass(Class)：直接封装指定的类型 spring 中处理泛型类java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.calebzhao.test;import org.springframework.core.ResolvableType;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.Arrays;import java.util.Collection;import java.util.stream.IntStream;public class SpringTypeTest { /** * 测试继承获取泛型 * @param */ class Parent{ } interface IParent1 { } interface IParent2 { } public class Children extends Parent implements IParent1, IParent2 { } public static void main(String[] args) { System.out.println(\"------------------------jdk原生方式-获取泛型父类---------------------------------------\"); // jdk原生方式获取Children类继承的父类的类型 Type genericSuperclassType = Children.class.getGenericSuperclass(); // com.calebzhao.test.SpringTypeTest$Parent System.out.println(genericSuperclassType); if (genericSuperclassType instanceof ParameterizedType) { Type[] actualTypeArguments = ((ParameterizedType) genericSuperclassType) .getActualTypeArguments(); for (Type argumentType : actualTypeArguments) { System.out.println(\"父类ParameterizedType.getActualTypeArguments:\" + argumentType); } } System.out.println(\"------------------------jdk原生方式-获取泛型父接口---------------------------------------\"); // jdk原生方式获取Children类实现的接口的类型 Type[] genericInterfacesTypes = Children.class.getGenericInterfaces(); // [com.calebzhao.test.SpringTypeTest$IParent1, com.calebzhao.test.SpringTypeTest$IParent2] System.out.println(Arrays.toString(genericInterfacesTypes)); for (Type interfaceType : genericInterfacesTypes) { if (interfaceType instanceof ParameterizedType) { Type[] actualTypeArguments = ((ParameterizedType) interfaceType) .getActualTypeArguments(); for (Type argumentType : actualTypeArguments) { System.out.println(\"父接口ParameterizedType.getActualTypeArguments:\" + argumentType); } } } System.out.println(\"------------------------分割线 spring ResolvableType---------------------------------------\"); ResolvableType childrenResolvableType = ResolvableType.forClass(Children.class); System.out.println(\"children type：\" + childrenResolvableType.getType()); System.out.println(\"children raw type：\" + childrenResolvableType.getRawClass()); System.out.println(\"children generics：\" + Arrays.toString(childrenResolvableType.getGenerics())); System.out.println(\"-----super ResolvableType-------\"); ResolvableType superResolvableType = childrenResolvableType.getSuperType(); System.out.println(\"super generics：\" + Arrays.toString(superResolvableType.getGenerics())); System.out.println(\"super type：\" + superResolvableType.getType()); System.out.println(\"super raw class：\" + superResolvableType.getRawClass()); System.out.println(\"super getComponentType：\" + superResolvableType.getComponentType()); System.out.println(\"super getSource：\" + superResolvableType.getSource()); System.out.println(\"super：\" + Arrays.toString(superResolvableType.getInterfaces())); System.out.println(\"\\n-----interface ResolvableType-------\"); ResolvableType[] interfaceResolvableTypes = childrenResolvableType.getInterfaces(); IntStream.range(0, interfaceResolvableTypes.length).forEach(index ->{ ResolvableType interfaceResolvableType = interfaceResolvableTypes[index]; System.out.println(\"\\n -------第\" + index + \"个接口------------\"); System.out.println(\"interface generics：\" + Arrays.toString(interfaceResolvableType.getGenerics())); System.out.println(\"interface type：\" + interfaceResolvableType.getType()); System.out.println(\"interface raw class：\" + interfaceResolvableType.getRawClass()); System.out.println(\"interface getComponentType：\" + interfaceResolvableType.getComponentType()); System.out.println(\"interface getSource：\" + interfaceResolvableType.getSource()); System.out.println(\"interface：\" + Arrays.toString(interfaceResolvableType.getInterfaces())); }); }} spring 中处理泛型参数java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228package com.calebzhao.test;import org.springframework.core.ResolvableType;import org.springframework.util.ReflectionUtils;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.Collection;import java.util.List;import java.util.Map;import java.util.stream.IntStream;public class SpringResolvableTypeGenericClass { // 父类 class Parent{ } // 父接口1 interface IParent1 { } // 父接口2 interface IParent2 { } // 子类， 继承父类Parent， 实现接口IParent1，IParent2 public class Children extends Parent implements IParent1, IParent2 { } private List listString; private List listLists; { ResolvableType resolvableType = generics[index]; Class resolve = resolvableType.resolve(); System.out.println(\"parent属性的第\"+index+\"个泛型参数：\"+resolve); });// -----------private Parent parent;字段----------------//// parent属性的类型：com.calebzhao.test.SpringResolvableTypeGenericClass$Parent// parent属性的第0个泛型参数：class java.lang.String// parent属性的第1个泛型参数：class java.lang.Double } /** * private List listString; */ public static void doTestFindListStr(){ System.out.println(\"\\n-----------private List listString;字段----------------\\n\"); // 通过反射找到 private List listString;字段 Field listStringField = ReflectionUtils.findField(SpringResolvableTypeGenericClass.class,\"listString\"); // 获取listString字段的ResolvableType ResolvableType listStringResolvableType = ResolvableType.forField(listStringField); System.out.println(\"listString属性类型：\"+listStringResolvableType.getType()); //获取第0个位置的参数泛型 Class resolve = listStringResolvableType.getGeneric(0).resolve(); System.out.println(\"listString属性泛型参数：\"+resolve);// -----------private List listString;字段----------------//// listString属性类型：java.util.List// listString属性泛型参数：class java.lang.String } /** * private List listLists;","categories":[{"name":"spring","slug":"spring","permalink":"https://calebzhao.github.io/categories/spring/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/tags/spring-cloud/"},{"name":"spring boot","slug":"spring-boot","permalink":"https://calebzhao.github.io/tags/spring-boot/"},{"name":"Type","slug":"Type","permalink":"https://calebzhao.github.io/tags/Type/"},{"name":"ResolvableType","slug":"ResolvableType","permalink":"https://calebzhao.github.io/tags/ResolvableType/"},{"name":"spring","slug":"spring","permalink":"https://calebzhao.github.io/tags/spring/"},{"name":"泛型","slug":"泛型","permalink":"https://calebzhao.github.io/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"反射","slug":"反射","permalink":"https://calebzhao.github.io/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Spring Boot的Environment源码分析","slug":"Spring Boot的Environment源码分析","date":"2019-12-31T01:32:37.000Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2019/12/31/Spring Boot的Environment源码分析/","link":"","permalink":"https://calebzhao.github.io/2019/12/31/Spring%20Boot%E7%9A%84Environment%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"前言org.springframework.core.env.Environment是当前应用运行环境的公开接口，主要包括应用程序运行环境的两个关键方面：配置文件(profiles)和属性(properties)。Environment继承自接口PropertyResolver，而PropertyResolver提供了属性访问的相关方法。这篇文章从源码的角度分析Environment的存储容器和加载流程，然后基于源码的理解给出一个生产级别的扩展。 哪里创建的Environment?学习过springboot的都知道，在Springboot的main入口函数中调用SpringApplication.run(DemoApplication.class,args)函数便可以启用SpringBoot应用程序，跟踪一下SpringApplication源码可以发现，最终还是调用了SpringApplication的动态run函数。 我们在编写一个spring boot应用时通常启动的方式是通过SpringApplication.run(xxx.class, args)来启动的， java123456@SpringBootApplicationpublic class ClientApplication { public static void main(String[] args) { SpringApplication.run(ClientApplication.class, args); }} Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273```javapublic class SpringApplication{ // ...省略与Environment无关的代码 public SpringApplication(Class... primarySources) { this(null, primarySources); } public static ConfigurableApplicationContext run(Class primarySource, String... args) { return run(new Class[] { primarySource }, args); } public static ConfigurableApplicationContext run(Class[] primarySources, String[] args) { return new SpringApplication(primarySources).run(args); } public ConfigurableApplicationContext run(String... args) { // ...省略与Environment无关的代码 try { ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 与Environment相关的关键代码 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); ...省略与Environment无关的代码 } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); } // ...省略与Environment无关的代码 } private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) { // 关键代码：获取ConfigurableEnvironment， 如果不存在就创建 ConfigurableEnvironment environment = getOrCreateEnvironment(); configureEnvironment(environment, applicationArguments.getSourceArgs()); ConfigurationPropertySources.attach(environment); listeners.environmentPrepared(environment); bindToSpringApplication(environment); if (!this.isCustomEnvironment) { environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); } ConfigurationPropertySources.attach(environment); return environment; } // 根据应用类型创建相应的ConfigurableEnvironment private ConfigurableEnvironment getOrCreateEnvironment() { if (this.environment != null) { return this.environment; } switch (this.webApplicationType) { case SERVLET: // servlet应用 return new StandardServletEnvironment(); case REACTIVE: // reactive反应式应用 return new StandardReactiveWebEnvironment(); default: // 非reactive， 非web， 也就是标准java应用 return new StandardEnvironment(); } } // ...省略与Environment无关的代码} 可以看到SpringApplication类中最终会根据应用类型(WebApplicationType枚举类)创建相应的ConfigurableEnvironment的具体实现实例对象，另外关于SpringApplication这个类的具体执行流程另一篇博客已有详细的源码分析，这里不再赘述，参见Spring Boot启动流程分析 下面以web环境的StandardServletEnvironment为例进行分析 Environment类体系 PropertyResolver：用于针对任何基础源解析属性的接口，提供属性访问功能 ConfigurablePropertyResolver：继承自PropertyResolver，额外提供属性类型转换(基于org.springframework.core.convert.ConversionService)功能 Environment：继承自PropertyResolver，额外提供访问和判断profiles的功能 ConfigurableEnvironment：继承自ConfigurablePropertyResolver和Environment，并且提供设置激活的profile和默认的profile的功能。 ConfigurableWebEnvironment：继承自ConfigurableEnvironment，并且提供配置Servlet上下文和Servlet参数的功能。 AbstractEnvironment：实现了ConfigurableEnvironment接口，默认属性和存储容器的定义，并且实现了ConfigurableEnvironment中的方法，并且为子类预留可重写的扩展方法。 StandardEnvironment：继承自AbstractEnvironment，非Servlet(Web)环境下的标准Environment实现。 StandardServletEnvironment：继承自StandardEnvironment，Servlet(Web)环境下的标准Environment实现。 MockEnvironment: ConfigurableEnvironment的简单实现，出于测试的目的，用于暴露setProperty(String, String) 及 withProperty(String, String)方法 AbstractPropertyResolver：抽象基类，用于根据任何基础源解析属性， conversionService的默认实现使用DefaultConversionService创建。 PropertySourcesPropertyResolver：PropertyResolver的实现，可以针对一组基础的PropertySource解析属性值 reactive相关的暂时不研究。 Environment提供的方法一般情况下，我们在SpringMVC项目中启用到的是StandardServletEnvironment，它的父接口是ConfigurableWebEnvironment，我们可以查看此接口提供的方法： PropertyResolover：从接口提供的方法可以看到PropertyResolover接口提供的方法都是获取属性相关的get方法或者求值(resolve)方法，不涉及set操作 ConfigurablePropertyResolover：扩展了PropertyResolover接口提供的方法, 额外提供了访问属性转换(ConfigurableConversionService)的get/set方法，及属性占位符placheholder的get/set方法，即该类的目的是提供写操作(set)的相关方法 Environment：从提供的方法可以看到全部是与profile相关的访问，获取当前默认的profile及已激活的profile， 只有get操作 ConfigurableEnvironment：从类名就知道提供的对Environment写操作相关的方法，包括设置默认profile、设置当前激活哪个profile、获取系统属性、合并另一个ConfigurableEnvironment的属性 ConfigurableWebEnvironment：只提供了initPropertySources方法, 从参数就可以看出来是提供配置ServletContext上下文和ServletConfig参数的功能 因此从每个类提供的方法可以看到Environment相关的接口的思想是一层层抽象出标准环境、web环境、可配置的标准环境、可配置的web环境，将读操作和写操作分离、web环境和非web环境分离 Environment的存储容器从SpringApplication.getOrCreateEnvironment()方法可以看到最终返回的ConfigurableEnvironment就是StandardServletEnvironment 或StandardEnvironment或者StandardReactiveWebEnvironment java1234567891011121314151617// 根据应用类型创建相应的ConfigurableEnvironmentprivate ConfigurableEnvironment getOrCreateEnvironment() { if (this.environment != null) { return this.environment; } switch (this.webApplicationType) { case SERVLET: // servlet应用 return new StandardServletEnvironment(); case REACTIVE: // reactive反应式应用 return new StandardReactiveWebEnvironment(); default: // 非reactive， 非web， 也就是标准java应用 return new StandardEnvironment(); }} 下面从StandardServletEnvironment开始分析。 new StandardServletEnvironment()会执行StandardServletEnvironment的的构造方法，会发现这个类没有提供构造方法，只重写了customizePropertySources及initPropertySources这2个方法，这2个类后续分析。 我们继续看StandardServletEnvironment的父类StandardEnvironment的实现，发现StandardEnvironment也是非常简单，只重写了customizePropertySources()这个方法，暂且不管，继续看它的父类AbstractEnvironment，会发现这个类做了很多事情，定义了propertySources及profile相关属性，下面具体分析AbstractEnvironment这个类。 PropertySource要分析AbstractEnvironment这个类先看PropertySource java123456789101112131415public abstract class AbstractEnvironment implements ConfigurableEnvironment { // ...省略代码 private final MutablePropertySources propertySources = new MutablePropertySources(); // ...省略代码 public AbstractEnvironment() { customizePropertySources(this.propertySources); } protected void customizePropertySources(MutablePropertySources propertySources) { }} 上面的propertySource属性就是用来存放PropertySource列表的，再看MutablePropertySources这个类的实现： java123456public class MutablePropertySources implements PropertySources { private final List propertySourceList = new CopyOnWriteArrayList();","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"https://calebzhao.github.io/categories/spring-boot/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"https://calebzhao.github.io/tags/spring-boot/"},{"name":"envionment","slug":"envionment","permalink":"https://calebzhao.github.io/tags/envionment/"}]},{"title":"Spring Boot启动流程分析","slug":"Spring Boot启动流程分析","date":"2019-12-30T00:22:37.000Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2019/12/30/Spring Boot启动流程分析/","link":"","permalink":"https://calebzhao.github.io/2019/12/30/Spring%20Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/","excerpt":"","text":"有道无术,术可求;有术无道,止于术 1、前言学习过springboot的都知道，在Springboot的main入口函数中调用SpringApplication.run(DemoApplication.class,args)函数便可以启用SpringBoot应用程序，跟踪一下SpringApplication源码可以发现，最终还是调用了SpringApplication的动态run函数。 下面以SpringBoot2.2.1.RELEASE为例简单分析一下运行过程。 我们在编写一个spring boot应用时通常启动的方式是通过SpringApplication.run(xxx.class, args)来启动的 java123456@SpringBootApplicationpublic class ClientApplication { public static void main(String[] args) { SpringApplication.run(ClientApplication.class, args); }} 2、分析 SpringApplication构造函数SpringApplication源码： java1234567891011121314151617181920212223242526272829303132333435public class SpringApplication { public SpringApplication(Class... primarySources) { this(null, primarySources); } public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) { // 2.1、赋值资源加载器 this.resourceLoader = resourceLoader; // 2.2、断言主要加载资源类不能为 null，否则报错 Assert.notNull(primarySources, \"PrimarySources must not be null\"); // 2.3、初始化主要加载资源类集合并去重 this.primarySources = new LinkedHashSet(Arrays.asList(primarySources)); // 2.4、推断当前应用类型是servlet环境、reactive反应式环境、标准环境 this.webApplicationType = WebApplicationType.deduceFromClasspath(); // 2.5、关键代码：加载classpath下META-INF/spring.factories中key为ApplicationContextInitializer的自动化配置类的名称 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // 2.6、关键代码：加载classpath下META-INF/spring.factories中key为ApplicationListener的自动化配置类的名称 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //2.7、推断main方法所在的类 this.mainApplicationClass = deduceMainApplicationClass(); } // 这个方法就是SpringApplication.run(ClientApplication.class, args);这段代码调用的方法 public static ConfigurableApplicationContext run(Class primarySource, String... args) { return run(new Class[] { primarySource }, args); } public static ConfigurableApplicationContext run(Class[] primarySources, String[] args) { return new SpringApplication(primarySources).run(args); }} 可知这个构造器类的初始化包括以下 7 个过程，下面逐一分析每个步骤的源码: 2.1、赋值资源加载器java1this.resourceLoader = resourceLoader; 2.2、断言主要加载资源类不能为 null，否则报错java1Assert.notNull(primarySources, \"PrimarySources must not be null\"); 2.3、初始化主要加载资源类集合并去重java1this.primarySources = new LinkedHashSet(Arrays.asList(primarySources)); 2.4、推断当前 WEB 应用类型java1this.webApplicationType = deduceWebApplicationType(); 来看下 deduceWebApplicationType 方法和相关的源码： java1234567891011121314151617181920212223242526272829303132333435363738394041424344// 应用类型public enum WebApplicationType { // 非servlet应用、非reactive应用 NONE, // servlet应用 SERVLET, // reactive反应式应用 REACTIVE; private static final String[] SERVLET_INDICATOR_CLASSES = { \"javax.servlet.Servlet\", \"org.springframework.web.context.ConfigurableWebApplicationContext\" }; private static final String WEBMVC_INDICATOR_CLASS = \"org.springframework.web.servlet.DispatcherServlet\"; private static final String WEBFLUX_INDICATOR_CLASS = \"org.springframework.web.reactive.DispatcherHandler\"; private static final String JERSEY_INDICATOR_CLASS = \"org.glassfish.jersey.servlet.ServletContainer\"; private static final String SERVLET_APPLICATION_CONTEXT_CLASS = \"org.springframework.web.context.WebApplicationContext\"; private static final String REACTIVE_APPLICATION_CONTEXT_CLASS = \"org.springframework.boot.web.reactive.context.ReactiveWebApplicationContext\"; // 从类路径推倒应用类型 static WebApplicationType deduceFromClasspath() { // 当类路径中存在WEBFLUX_INDICATOR_CLASS // 并且不存在WEBMVC_INDICATOR_CLASS时 // 且不存在JERSEY_INDICATOR_CLASS时 if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null) && !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) { // 是reactive反应式程序 return WebApplicationType.REACTIVE; } // 当加载的类路径中不包含SERVLET_INDICATOR_CLASSES中定义的任何一个类时，返回标准应用 for (String className : SERVLET_INDICATOR_CLASSES) { if (!ClassUtils.isPresent(className, null)) { // 是标准应用 return WebApplicationType.NONE; } } // 加载的类路径中包含了SERVLET_INDICATOR_CLASSES中定义的所有类型则判断为web应用 return WebApplicationType.SERVLET; }} 2.5、设置ApplicationContextInitializer初始化器Code1setInitializers((Collection)getSpringFactoriesInstances(ApplicationContextInitializer.class)); 初始化initializers属性，加载classpath下META-INF/spring.factories中配置的ApplicationContextInitializer。 ApplicationContextInitializer的作用是什么？源码如下。 java123456789public interface ApplicationContextInitializer { /** * Initialize the given application context. * @param applicationContext the application to configure */ void initialize(C applicationContext);} 用来初始化指定的 Spring 应用上下文，如注册属性资源、激活 Profiles 等。 来看下 setInitializers 方法源码，其实就是初始化一个 ApplicationContextInitializer 应用上下文初始化器实例的集合。 java1234public void setInitializers(Collection> initializers) { this.initializers = new ArrayList(); this.initializers.addAll(initializers);} 再来看下这个初始化 getSpringFactoriesInstances 方法和相关的源码： java1234567891011121314151617181920private Collection getSpringFactoriesInstances(Class type) { return getSpringFactoriesInstances(type, new Class[] {});}private Collection getSpringFactoriesInstances(Class type, Class[] parameterTypes, Object... args) { ClassLoader classLoader = getClassLoader(); // Use names and ensure unique to protect against duplicates // SpringFactoriesLoader.loadFactoryNames()方法将会 // 从calssptah下的META-INF/spring.factories中读取 key为 // org.springframework.context.ApplicationContextInitializer的值， // 并以集合形式返回 Set names = new LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); // 根据返回names集合逐个实例化,也就是初始化各种ApplicationContextInitializer, // 这些Initializer实际是在Spring上下文ApplicationContext执行refresh前调用 List instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); // 对上面创建的实例排序 AnnotationAwareOrderComparator.sort(instances); return instances;} 这个方法会尝试从类路径的META-INF/spring.factories处读取相应配置文件，然后进行遍历，读取配置文件中Key 为：org.springframework.context.ApplicationContextInitializer的value。以spring-boot-autoconfigure这个包为例，它的META-INF/spring.factories部分定义如下所示： properties1234# Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener 其中上面代码用到的SpringFactoriesLoader.loadFactoryNames(xx.class)的具体实现见另一篇文章springboot2.2自动注入文件spring.factories如何加载详解 2.6、设置ApplicationListener监听器java1setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); setListeners 初始化属性listeners，加载classpath下META-INF/spring.factories中配置的ApplicationListener，此处入参为getSpringFactoriesInstances方法入参type= ApplicationListener.class ApplicationListener 的作用是什么？源码如下。 java12345678910@FunctionalInterfacepublic interface ApplicationListener extends EventListener { /** * Handle an application event. * @param event the event to respond to */ void onApplicationEvent(E event);} 看源码，这个接口继承了 JDK 的java.util.EventListener 接口，实现了观察者模式，它一般用来定义感兴趣的事件类型，事件类型限定于 ApplicationEvent 的子类，这同样继承了 JDK 的 java.util.EventObject 接口。 设置监听器和设置初始化器调用的方法是一样的，只是传入的类型不一样，设置监听器的接口类型为：getSpringFactoriesInstances，对应的spring-boot-autoconfigure-2.2.1.RELEASE.jar!/META-INF/spring.factories 文件配置内容请见下方。 properties123# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.autoconfigure.BackgroundPreinitializer 可以看出目前只有一个 BackgroundPreinitializer 监听器。 2.7、推断主入口应用类java1deduceMainApplicationClass() deduceMainApplicationClass()方法的源码实现如下： java1234567891011121314private Class deduceMainApplicationClass() { try { StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) { if (\"main\".equals(stackTraceElement.getMethodName())) { return Class.forName(stackTraceElement.getClassName()); } } } catch (ClassNotFoundException ex) { // Swallow and continue } return null;} 这个推断入口应用类的方式有点特别，通过构造一个运行时异常，再遍历异常栈中的方法名，获取方法名为 main 的栈帧，从来得到入口类的名字再返回该类。 3、 分析 SpringApplication中 run方法SpringApplication的run方法代码如下： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public ConfigurableApplicationContext run(String... args) { // 1、创建并启动计时监控类 StopWatch stopWatch = new StopWatch(); stopWatch.start(); // 2、初始化应用上下文和异常报告集合 ConfigurableApplicationContext context = null; Collection exceptionReporters = new ArrayList(); // 3、设置系统属性 `java.awt.headless` 的值，默认值为：true configureHeadlessProperty(); // 4、加载classpath下面的META-INF/spring.factories中key为SpringApplicationRunListener的配置 SpringApplicationRunListeners listeners = getRunListeners(args); // 执行所有runlistener的starting方法，实际上发布一个【ApplicationStartingEvent】事件 // 内部会发布ApplicationStartingEvent事件，有以下监听器监听了该事件（按执行顺序列出）： // 括号中的代码表示该listener时是在哪个项目的spring.factories中声明的 // org.springframework.boot.context.logging.LoggingApplicationListener （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.autoconfigure.BackgroundPreinitializer （spring-boot-autoconfigure-2.2.1.RELEASE.jar） // org.springframework.boot.context.config.DelegatingApplicationListener （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener （spring-boot-2.2.1.RELEASE.jar） listeners.starting(); try { // 5、实例化ApplicationArguments对象，初始化默认应用参数类 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 6、 创建Environment （web环境 or 标准环境）+配置Environment，主要是把run方法的参数配置 // 到Environment 发布【ApplicationEnvironmentPreparedEvent】事件，依次执行如下的listener： // 括号中的代码表示该listener时是在哪个项目的spring.factories中声明的 // org.springframework.cloud.bootstrap.BootstrapApplicationListener (spring-cloud-context-2.2.0.RELEASE.jar!\\META-INF\\spring.factories) // org.springframework.cloud.bootstrap.LoggingSystemShutdownListener (spring-cloud-context-2.2.0.RELEASE.jar!\\META-INF\\spring.factories) // org.springframework.boot.context.config.ConfigFileApplicationListener (spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories) // org.springframework.boot.context.config.AnsiOutputApplicationListener (spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories) // org.springframework.boot.context.logging.LoggingApplicationListener (spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories) // org.springframework.boot.autoconfigure.BackgroundPreinitializer (spring-boot-autoconfigure-2.2.1.RELEASE.jar!\\META-INF\\spring.factories) // org.springframework.boot.context.logging.ClasspathLoggingApplicationListener (spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories) // org.springframework.boot.context.config.DelegatingApplicationListener (spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories) // org.springframework.boot.context.FileEncodingApplicationListener (spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories) // 这段代码非常非常关键，spring cloud与spring boot的整合就是在这里开始的 // spring cloud的BootstrapApplicationListener实现了ApplicationListener接口，并且接收ApplicationEnvironmentPreparedEvent事件 // BootstrapApplicationListener中会创建一个新的SpringApplication，又会调用新创建的SpringApplication.run()方法产生id为bootstrap的 // 父ApplicationContext // 返回类型可能是StandardServletEnvironment(spring boot servlet环境)或StandardEnvironment(spring cloud使用)， // 下面列出environment中属性源的名称，属性源按照在ConfigurableEnvironment中的顺序包括: // 【springApplicationCommandLineArgs】 // 有命令参数才有该属性源 // configurationProperties // 【bootstrap】 //spring cloud中的， spring boot不存在该属性源 // 【servletConfigInitParams】// servlet应用存在该属性源， spring cloud不存在 // 【servletContextInitParams】// servlet应用存在该属性源， spring cloud不存在 // systemProperties jvm系统属性源 // systemEnvironment 系统环境变量属性源 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); // 7、打印banner，SpringBoot启动时，控制台输出的一个歪歪扭扭的很不清楚的Spring几个大字母， // 也可以自定义，参考博客：http://majunwei.com/view/201708171646079868.html Banner printedBanner = printBanner(environment); // 8、 根据不同environment创建应用上下文（返回ConfigurableApplicationContext的子类实例） context = createApplicationContext(); // 9、通过SpringFactoriesLoader检索META-INF/spring.factories中的SpringBootExceptionReporter， // 获取并实例化异常分析器 exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] { ConfigurableApplicationContext.class }, context); // 10、 上下文相关预处理，发布【ApplicationPreparedEvent】事件 // 为ApplicationContext加载environment，之后逐个执行ApplicationContextInitializer的initialize()方法来进一步封装ApplicationContext， // 并调用所有的SpringApplicationRunListener的contextPrepared()方法，【EventPublishingRunListener只提供了一个空的contextPrepared()方法】， // 之后初始化IoC容器，并调用SpringApplicationRunListener的contextLoaded()方法，广播ApplicationContext的IoC加载完成， // 这里就包括通过@EnableAutoConfiguration导入的各种自动配置类。 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 11、 执行context的refresh，并且调用context的registerShutdownHook方法 refreshContext(context); // 12、应用上下文刷新后置处理，是一个空方法 afterRefresh(context, applicationArguments); // 13、停止计时监控类 stopWatch.stop(); // 14、输出日志记录执行主类名、时间信息 if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); } // 15、执行所有runlisteners的started方法，发布【ApplicationStartedEvent】事件(应用已经启动的事件) listeners.started(context); // 16、遍历所有注册的ApplicationRunner和CommandLineRunner，并执行其run()方法。 // 我们可以实现自己的ApplicationRunner或者CommandLineRunner，来对SpringBoot的启动过程进行扩展。 callRunners(context, applicationArguments); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); } try { // 17、遍历前面14行获得SpringApplicationRunListeners局部变量中所维护的listeners属性, // 执行所有SpringApplicationRunListener的running方法，发布【ApplicationReadyEvent】事件（应用已经启动完成的监听事件） listeners.running(context); } catch (Throwable ex) { handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); } // 18、返回应用上下文 return context;} 其实这个方法我们可以简单的总结下步骤为 ： 配置属性 获取监听器，发布应用开始启动事件 初始化输入参数 配置环境，输出banner 创建上下文 预处理上下文 刷新上下文 刷新上下文的后处理，空实现 发布应用已经启动事件 发布应用启动完成事件 所以，我们可以按以下几步来分解 run 方法的启动过程。 3.1、创建并启动StopWatch创建并启动计时监控类 java12StopWatch stopWatch = new StopWatch();stopWatch.start(); 来看下这个计时监控类 StopWatch 的相关源码： java123456789101112131415public class StopWatch { public void start() throws IllegalStateException { start(\"\"); } public void start(String taskName) throws IllegalStateException { if (this.currentTaskName != null) { throw new IllegalStateException(\"Can't start StopWatch: it's already running\"); } this.currentTaskName = taskName; this.startTimeNanos = System.nanoTime(); }} 首先记录了当前任务的名称，默认为空字符串，然后记录当前 Spring Boot 应用启动的开始时间（单位纳秒）。 3.2、初始化SpringBootExceptionReporter初始化应用上下文和异常报告集合 java12ConfigurableApplicationContext context = null;Collection exceptionReporters = new ArrayList(); 3.3、设置系统属性 java.awt.headless 的值java1configureHeadlessProperty(); 设置该默认值为：true，Java.awt.headless = true 有什么作用？ 对于一个 Java 服务器来说经常要处理一些图形元素，例如地图的创建或者图形和图表等。这些API基本上总是需要运行一个X-server以便能使用AWT（Abstract Window Toolkit，抽象窗口工具集）。然而运行一个不必要的 X-server 并不是一种好的管理方式。有时你甚至不能运行 X-server,因此最好的方案是运行 headless 服务器，来进行简单的图像处理。 参考：www.cnblogs.com/princessd8251/p/4000016.html 3.4、创建SpringApplicationRunListeners并发布ApplicationStartingEvent3.4.1、getRunListeners()方法java1234567SpringApplicationRunListeners listeners = getRunListeners(args);// 内部会发布ApplicationStartingEvent事件，有以下监听器监听了该事件（按执行顺序列出）：// org.springframework.boot.context.logging.LoggingApplicationListener// org.springframework.boot.autoconfigure.BackgroundPreinitializer// org.springframework.boot.context.config.DelegatingApplicationListener// org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListenerlisteners.starting(); 来看下创建 SpringApplicationRunListeners运行监听器相关的源码： java123456private SpringApplicationRunListeners getRunListeners(String[] args) { Class[] types = new Class[] { SpringApplication.class, String[].class }; // SpringApplicationRunListener的实现实际只有EventPublishingRunListener return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));} 可以看到返回了SpringApplicationRunListeners对象， 3.4.2、创建SpringApplicationRunListeners返回的SpringApplicationRunListeners这个类的源码如下： java1234567891011121314151617181920class SpringApplicationRunListeners { private final Log log; private final List listeners; /** * * @param listeners 这个集合实际只有EventPublishingRunListener一个类的实例 */ SpringApplicationRunListeners(Log log, Collection listeners) { this.log = log; this.listeners = new ArrayList(listeners); } void starting() { for (SpringApplicationRunListener listener : this.listeners) { listener.starting(); } }} 创建逻辑和之前实例化初始化器和监听器的一样，一样调用的是 getSpringFactoriesInstances 方法来获取配置的监听器名称并实例化所有的类。 SpringApplicationRunListener 所有监听器配置在 spring-boot-2.2.1.RELEASE.jar!/META-INF/spring.factories 这个配置文件里面。 properties123# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\org.springframework.boot.context.event.EventPublishingRunListener 可以看到SpringApplicationRunListener的值是org.springframework.boot.context.event.EventPublishingRunListener这个类，所以创建SpringApplicationRunListeners这个对象时构造方法传递的2个参数就是这个EventPublishingRunListener的实例。 3.4.3、listeners.starting()所以listeners.starting();这行代码的实现SpringApplicationRunListeners.starting()方法中遍历的属性this.listeners实际就只有1个EventPublishingRunListener java123456789class SpringApplicationRunListeners{ private final List listeners; void starting() { for (SpringApplicationRunListener listener : this.listeners) { listener.starting(); } }} 接下来看EventPublishingRunListener类的starting方法的源码实现。 3.4.4、EventPublishingRunListener.starting()java123456789101112131415161718192021222324252627282930313233343536373839404142/*** 用于发布多种SpringApplicationEvent事件。* 在上下文ApplicationContext实际refresh之前使用ApplicationEventMulticaster来触发事件。* * */public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered { // SpringApplication.run(xxx.class, args)运行时内部创建的SpringApplication实例， // 构造方法实例化时设置了List initializers及List listeners属性 let's suppress the exception and just log a debug message. Log logger = LogFactory.getLog(getClass()); if (logger.isTraceEnabled()) { logger.trace(\"Non-matching event type for listener: \" + listener, ex); } } else { throw ex; } } }} 3.5、初始化默认应用参数类java1ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); DefaultApplicationArguments类的源码如下： java123456789101112131415161718192021222324252627282930public class DefaultApplicationArguments implements ApplicationArguments { private final Source source; private final String[] args; public DefaultApplicationArguments(String... args) { Assert.notNull(args, \"Args must not be null\"); this.source = new Source(args); this.args = args; } private static class Source extends SimpleCommandLinePropertySource { Source(String[] args) { super(args); } @Override public List getNonOptionArgs() { return super.getNonOptionArgs(); } @Override public List getOptionValues(String name) { return super.getOptionValues(name); } }} 从构造方法可以看到最主要的操作就是this.source = new Source(args);这一行代码，而Souce类是一个内部内，Source的构造方法中直接调用了父类SimpleCommandLinePropertySource的构造方法，下面看SimpleCommandLinePropertySource类构造方法的实现细节： java123456public class SimpleCommandLinePropertySource extends CommandLinePropertySource { public SimpleCommandLinePropertySource(String... args) { super(new SimpleCommandLineArgsParser().parse(args)); }} 可以看到创建了SimpleCommandLineArgsParser类的实例，调用了它的parse(String… args)方法，从类名和方法命名可以就应该能猜到这个类是用来解析命令行参数的。 SimpleCommandLineArgsParser类源码如下： java12345678910111213141516171819202122232425262728293031323334353637class SimpleCommandLineArgsParser { public CommandLineArgs parse(String... args) { CommandLineArgs commandLineArgs = new CommandLineArgs(); // 比如命令 java --server.port=8888 --spring.profiles.active=prod -jar app.jar for (String arg : args) { // 参数是否以--打头，比如参数 --server.port=8888 if (arg.startsWith(\"--\")) { // 截取--字符串后面的字符串，比如--server.port=8888变成server.port=8888 String optionText = arg.substring(2, arg.length()); String optionName; String optionValue = null; // 是否有值 if (optionText.contains(\"=\")) { // 等号前面的字符串作为name optionName = optionText.substring(0, optionText.indexOf('=')); // 等号后面的字符串作为value optionValue = optionText.substring(optionText.indexOf('=')+1, optionText.length()); } else { // --后面的整个字符串作为name optionName = optionText; } if (optionName.isEmpty() || (optionValue != null && optionValue.isEmpty())) { throw new IllegalArgumentException(\"Invalid argument syntax: \" + arg); } // 存储name和value到CommandLineArgs中 commandLineArgs.addOptionArg(optionName, optionValue); } else { commandLineArgs.addNonOptionArg(arg); } } return commandLineArgs; }} 到这里ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);这一行代码的作用就分析完了，可以看到做的事情就是解析命令行参数。 3.6、创建Environment并发布ApplicationEnvironmentPreparedEventCode12ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);configureIgnoreBeanInfo(environment); 下面我们主要来看下准备环境的 prepareEnvironment 源码： java12345678910111213141516171819202122232425262728private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) { // 3.6.1、 获取（或者创建）应用ConfigurableEnvironment ConfigurableEnvironment environment = getOrCreateEnvironment(); // 3.6.2、 配置应用环境（启动参数绑定到ConfigurableEnvironment中、绑定ConfigurableConversionService到ConfigurableEnvironment中） configureEnvironment(environment, applicationArguments.getSourceArgs()); // 3.6.3、 ConfigurationPropertySources.attach(environment); // 3.6.4、这里的listeners是SpringApplicationRunListeners，发布ApplicationEnvironmentPreparedEvent事件 // 这段代码非常非常重要，spring cloud与spring boot的整合就是在这里开始的 // spring cloud的BootstrapApplicationListener实现了ApplicationListener接口，并且接收ApplicationEnvironmentPreparedEvent事件 // BootstrapApplicationListener中会创建一个新的SpringApplication，又会调用新创建的SpringApplication.run()方法产生id为bootstrap的 // 父ApplicationContext listeners.environmentPrepared(environment); // 3.6.5、绑定ConfigurableEnvironment到当前的SpringApplication实例中 bindToSpringApplication(environment); if (!this.isCustomEnvironment) { environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); } ConfigurationPropertySources.attach(environment); return environment;} 上面的代码需要重点关注，和spring cloud的整合在这里开始。 3.6.1、获取（或者创建）ConfigurableEnvironmentjava1ConfigurableEnvironment environment = getOrCreateEnvironment(); getOrCreateEnvironment()方法实现如下： java12345678910111213private ConfigurableEnvironment getOrCreateEnvironment() { if (this.environment != null) { return this.environment; } switch (this.webApplicationType) { case SERVLET: return new StandardServletEnvironment(); case REACTIVE: return new StandardReactiveWebEnvironment(); default: return new StandardEnvironment(); }} 这里分为标准 Servlet 环境和标准环境。 3.6.2、 配置ConfigurableEnvironmentjava1configureEnvironment(environment, applicationArguments.getSourceArgs()); configureEnvironment()实现如下： java1234567891011121314protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) { // 3.6.2.1、创建ConversionService并存到Environment中 // SpringApplication的成员变量，默认值为true。 if (this.addConversionService) { // 创建ApplicationConversionService(类型转换器)并注册默认的Converter、Formatter类型转换器实现，spring mvc中经常使用ConversionService ConversionService conversionService = ApplicationConversionService.getSharedInstance(); // 将ConversionService存到ConfigurableEnvironment中 environment.setConversionService((ConfigurableConversionService) conversionService); } // 3.6.2.2、将命令行的属性添加到Environment中 configurePropertySources(environment, args); // 3.6.2.3、将additionalProfiles合并到Environment中，设置激活的profile configureProfiles(environment, args);} 3.6.2.1、创建ConversionService并存到Environment中 ApplicationConversionService.getSharedInstance()源码如下： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*** 类型转换器服务，用于将*/public class ApplicationConversionService extends FormattingConversionService { private static volatile ApplicationConversionService sharedInstance; public ApplicationConversionService() { this(null); } public ApplicationConversionService(StringValueResolver embeddedValueResolver) { if (embeddedValueResolver != null) { setEmbeddedValueResolver(embeddedValueResolver); } configure(this); } public static ConversionService getSharedInstance() { ApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance; if (sharedInstance == null) { synchronized (ApplicationConversionService.class) { sharedInstance = ApplicationConversionService.sharedInstance; if (sharedInstance == null) { sharedInstance = new ApplicationConversionService(); ApplicationConversionService.sharedInstance = sharedInstance; } } } return sharedInstance; } public static void configure(FormatterRegistry registry) { DefaultConversionService.addDefaultConverters(registry); DefaultFormattingConversionService.addDefaultFormatters(registry); addApplicationFormatters(registry); addApplicationConverters(registry); } public static void addApplicationFormatters(FormatterRegistry registry) { registry.addFormatter(new CharArrayFormatter()); registry.addFormatter(new InetAddressFormatter()); registry.addFormatter(new IsoOffsetFormatter()); } public static void addApplicationConverters(ConverterRegistry registry) { addDelimitedStringConverters(registry); registry.addConverter(new StringToDurationConverter()); registry.addConverter(new DurationToStringConverter()); registry.addConverter(new NumberToDurationConverter()); registry.addConverter(new DurationToNumberConverter()); registry.addConverter(new StringToDataSizeConverter()); registry.addConverter(new NumberToDataSizeConverter()); registry.addConverter(new StringToFileConverter()); registry.addConverterFactory(new LenientStringToEnumConverterFactory()); registry.addConverterFactory(new LenientBooleanToEnumConverterFactory()); }} 可以看到getSharedInstance()方法就是一个典型的双重判断单例模式的实现，只是需要注意这里sharedInstance变量是成员变量使用volatile进行了修饰，禁止指令重排序及保证内存可见性，ApplicationConversionService的构造方法中最终调用了configure(FormatterRegistry registry)方法 从方法实现看默认注册了一些Convert、Formater接口的实现。 DefaultConversionService.addDefaultConverters(registry);源码如下： java12345678910111213141516171819202122public class DefaultConversionService extends GenericConversionService { public DefaultConversionService() { addDefaultConverters(this); } public static void addDefaultConverters(ConverterRegistry converterRegistry) { addScalarConverters(converterRegistry); addCollectionConverters(converterRegistry); converterRegistry.addConverter(new ByteBufferConverter((ConversionService) converterRegistry)); converterRegistry.addConverter(new StringToTimeZoneConverter()); converterRegistry.addConverter(new ZoneIdToTimeZoneConverter()); converterRegistry.addConverter(new ZonedDateTimeToCalendarConverter()); converterRegistry.addConverter(new ObjectToObjectConverter()); converterRegistry.addConverter(new IdToEntityConverter((ConversionService) converterRegistry)); converterRegistry.addConverter(new FallbackObjectToStringConverter()); converterRegistry.addConverter(new ObjectToOptionalConverter((ConversionService) converterRegistry)); } ...省略部分代码} DefaultFormattingConversionService.addDefaultFormatters(registry);实现源码如下： java12345678910111213141516171819202122232425262728293031323334353637383940public class DefaultFormattingConversionService extends FormattingConversionService { private static final boolean jsr354Present; private static final boolean jodaTimePresent; static { ClassLoader classLoader = DefaultFormattingConversionService.class.getClassLoader(); jsr354Present = ClassUtils.isPresent(\"javax.money.MonetaryAmount\", classLoader); jodaTimePresent = ClassUtils.isPresent(\"org.joda.time.LocalDate\", classLoader); } public static void addDefaultFormatters(FormatterRegistry formatterRegistry) { // Default handling of number values formatterRegistry.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory()); // Default handling of monetary values if (jsr354Present) { formatterRegistry.addFormatter(new CurrencyUnitFormatter()); formatterRegistry.addFormatter(new MonetaryAmountFormatter()); formatterRegistry.addFormatterForFieldAnnotation(new Jsr354NumberFormatAnnotationFormatterFactory()); } // Default handling of date-time values // just handling JSR-310 specific date and time types new DateTimeFormatterRegistrar().registerFormatters(formatterRegistry); if (jodaTimePresent) { // handles Joda-specific types as well as Date, Calendar, Long new JodaTimeFormatterRegistrar().registerFormatters(formatterRegistry); } else { // regular DateFormat-based Date, Calendar, Long converters new DateFormatterRegistrar().registerFormatters(formatterRegistry); } } ...省略部分代码} 3.6.2.2、将命令行的属性添加到Environment中configurePropertySources方法源码如下： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class SpringApplication { // ...省略代码 // 是否添加命令行参数到ConfigurableEnvironment中 private boolean addCommandLineProperties = true; // 默认属性，如果有则会合并到ConfigurableEnvironment中 private Map defaultProperties; public void setDefaultProperties(Map defaultProperties) { this.defaultProperties = defaultProperties; } protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) { if (this.addConversionService) { ConversionService conversionService = ApplicationConversionService.getSharedInstance(); environment.setConversionService((ConfigurableConversionService) conversionService); } // 将命令行的属性添加到Environment中 configurePropertySources(environment, args); configureProfiles(environment, args); } // ...省略部分代码 /** * 创建一个基于命令行属性的PropertySource并将其添加到ConfigurableEnvironment中 * * @param environment 环境对象，根据应用类型可能是StandardEnvironment、StandardServletEnvironment、StandardReactiveWebEnvironment * @param args 要被添加的命令行参数数据，如 ['--server.port=9090', '--spring.profiles.active=prod'] */ protected void configurePropertySources(ConfigurableEnvironment environment, String[] args) { // 获得AbstractEnvironment中的propertySources属性，代表可变属性源， // MutablePropertySources类中包含addFirst、addBefore、addLast、remove、replace等操纵属性源的方法 MutablePropertySources sources = environment.getPropertySources(); // 判断是否有默认属性 if (this.defaultProperties != null && !this.defaultProperties.isEmpty()) { // 如果有默认属性，则将其添加到environment中 sources.addLast(new MapPropertySource(\"defaultProperties\", this.defaultProperties)); } // 判断是否添加命令行参数到ConfigurableEnvironment中，默认true if (this.addCommandLineProperties && args.length > 0) { // 命令行属性源名称 String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME; // 判断ConfigurableEnvironment中是否已经存在该属性源 if (sources.contains(name)) { // 根据name获取ConfigurableEnvironment中已存在的属性源 PropertySource source = sources.get(name); // 声明1个有属性源复合功能的属性源，当复合属性源中维护的多个属性源都有相同的key时，位置靠前的属性源中的值优先返回 CompositePropertySource composite = new CompositePropertySource(name); // 将参数args属性作为第1个属性源，由于它的位置在第1个，所以它的优先级最高 composite.addPropertySource(new SimpleCommandLinePropertySource(\"springApplicationCommandLineArgs\", args)); // 将ConfigurableEnvironment中已存在的属性源作为第2个属性源，优先级比上面一行的SimpleCommandLinePropertySource低 composite.addPropertySource(source); // 将ConfigurableEnvironment中已存在的单一属性源替换为上面创建的复合属性源 sources.replace(name, composite); } // ConfigurableEnvironment中不存在该属性源 else { // 将命令行参数添加ConfigurableEnvironment中的(底层维护着MutablePropertySources类型的propertySources属性) sources.addFirst(new SimpleCommandLinePropertySource(args)); } } } ...省略代码} 接下来继续分析configurePropertySources(environment, args);这一行后面的代码configureProfiles(environment, args); 3.6.2.3、configureProfiles(environment, args);配置additionalProfiles到Environment中，设置激活的profile java123456789101112131415161718192021222324252627public class SpringApplication { // 额外的profile的名称，可以是多个（表示同时启用多个profile） private Set additionalProfiles = new HashSet(); ...省略代码 public void setAdditionalProfiles(String... profiles) { this.additionalProfiles = new LinkedHashSet(Arrays.asList(profiles)); } /** * 这个方法的作用是将通过代码设置的profile的名称追加到environment中，例如如下实例： * SpringApplication app = new SpringApplication(TestApplication.class); * app.setAdditionalProfiles(\"dev\", \"test\"); * app.run(args); */ protected void configureProfiles(ConfigurableEnvironment environment, String[] args) { Set profiles = new LinkedHashSet(this.additionalProfiles); // environment.getActiveProfiles()获得当前激活的profile的名称集合(返回的是Set类型) // 然后加入profiles集合中，此时profiles集合中包含2种profile来源：this.additionalProfiles及environment中的 profiles.addAll(Arrays.asList(environment.getActiveProfiles())); // 设置使用的profile environment.setActiveProfiles(StringUtils.toStringArray(profiles)); } ...省略代码} prepareEnvironment()方法的源码分析完了，现在让我们回到public ConfigurableApplicationContext run(String... args)方法中，继续看prepareEnvironment()方法之后的方法configureIgnoreBeanInfo(environment)。 3.6.3、启动参数绑定到ConfigurableEnvironment中java1ConfigurationPropertySources.attach(environment); ConfigurationPropertySources类的静态方法attach(Environment environment)源码如下： java123456789101112131415161718192021222324public final class ConfigurationPropertySources { /** * The name of the {@link PropertySource} {@link #adapt adapter}. */ private static final String ATTACHED_PROPERTY_SOURCE_NAME = \"configurationProperties\"; private ConfigurationPropertySources() { } public static void attach(Environment environment) { Assert.isInstanceOf(ConfigurableEnvironment.class, environment); MutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources(); PropertySource attached = sources.get(ATTACHED_PROPERTY_SOURCE_NAME); if (attached != null && attached.getSource() != sources) { sources.remove(ATTACHED_PROPERTY_SOURCE_NAME); attached = null; } if (attached == null) { sources.addFirst(new ConfigurationPropertySourcesPropertySource(ATTACHED_PROPERTY_SOURCE_NAME, new SpringConfigurationPropertySources(sources))); } }} 3.6.4、发布ApplicationEnvironmentPreparedEvent事件java123456789101112// 内部会发布ApplicationEnvironmentPreparedEvent事件，依次执行如下的listener：// 括号中的代码表示该listener时是在哪个项目的spring.factories中声明的 // org.springframework.cloud.bootstrap.BootstrapApplicationListener (spring-cloud-context-2.2.0.RELEASE.jar!\\META-INF\\spring.factories)// org.springframework.cloud.bootstrap.LoggingSystemShutdownListener (spring-cloud-context-2.2.0.RELEASE.jar!\\META-INF\\spring.factories)// org.springframework.boot.context.config.ConfigFileApplicationListener (spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories)// org.springframework.boot.context.config.AnsiOutputApplicationListener (spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories)// org.springframework.boot.context.logging.LoggingApplicationListener (spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories)// org.springframework.boot.autoconfigure.BackgroundPreinitializer (spring-boot-autoconfigure-2.2.1.RELEASE.jar!\\META-INF\\spring.factories)// org.springframework.boot.context.logging.ClasspathLoggingApplicationListener (spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories)// org.springframework.boot.context.config.DelegatingApplicationListener (spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories)// org.springframework.boot.context.FileEncodingApplicationListener (spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories)listeners.environmentPrepared(environment); SpringApplicationRunListeners类的environmentPrepared方法源码如下： java12345678910111213141516171819202122class SpringApplicationRunListeners { private final Log log; // SpringApplicationRunListener`的实现类只有EventPublishingRunListener private final List listeners; // 该构造方法是在SpringApplication#getRunListeners(String[] args)中调用的 // 传入的listeners集合就只有1个元素EventPublishingRunListener SpringApplicationRunListeners(Log log, Collection listeners) { this.log = log; this.listeners = new ArrayList(listeners); } void environmentPrepared(ConfigurableEnvironment environment) { // this.listeners集合就只有EventPublishingRunListener for (SpringApplicationRunListener listener : this.listeners) { // 调用EventPublishingRunListener.environmentPrepared(ConfigurableEnvironment environment)方法 listener.environmentPrepared(environment); } }} SpringApplicationRunListener的实现类只有EventPublishingRunListener，EventPublishingRunListener类的environmentPrepared方法的源码如下： java12345678910111213141516public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered { private final SpringApplication application; private final String[] args; private final SimpleApplicationEventMulticaster initialMulticaster; @Override public void environmentPrepared(ConfigurableEnvironment environment) { this.initialMulticaster .multicastEvent(new ApplicationEnvironmentPreparedEvent(this.application, this.args, environment)); }} 3.6.4.1、SimpleApplicationEventMulticasterSimpleApplicationEventMulticaster类的作用时真正的发布事件(ApplicationEvent event)。 SimpleApplicationEventMulticaster类的源码如下： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/*** ApplicationEventMulticaster接口的简单实现。* 将所有事件(ApplicationEvent)广播给所有已注册的监听器(ApplicationEvent)，然后由监听器忽略他们不感兴趣的事件，* 监听器通常对传入的事件执行相应的instanceof检查，来确定该事件是否是自己感兴趣的，如果对该事件不敢兴趣就忽略它，否则进行业务逻辑处理。** 默认情况下所有监听器在调用线程中被执行，但这带来了恶意的侦听器可能会阻塞整个应用的风险，但只增加了最小的开销，可以指定一个可选的* 任务执行器(Executor taskExecutor)来让监听器(ApplicationListener)在不同的线程中执行，例如这个taskExecutor可以是一个线程池，* 这样无论ApplicationListener的执行时间多长(比如ApplicationListener中存在耗时的网络请求、性能不好的数据库访问或是否是阻塞操作(比如io、等待CPU)），* 都不会导致整个应用被阻塞*/public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster { // 指定ApplicationListener在哪个线程执行器中执行（可以不指定），具体含义参见上面类级别的文档 @Nullable private Executor taskExecutor; // 错误处理器，作用参见invokeListener(ApplicationListener listener, ApplicationEvent event)方法内注释 @Nullable private ErrorHandler errorHandler; public SimpleApplicationEventMulticaster() { } // 可以指定ApplicationListener在哪个线程执行器中执行 public void setTaskExecutor(@Nullable Executor taskExecutor) { this.taskExecutor = taskExecutor; } // 可以指定ApplicationListener的错误处理器 public void setErrorHandler(@Nullable ErrorHandler errorHandler) { this.errorHandler = errorHandler; } @Override public void multicastEvent(ApplicationEvent event) { multicastEvent(event, resolveDefaultEventType(event)); } @Override public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) { ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event)); // 获得ApplicationListener的执行器（该执行器是可选的） Executor executor = getTaskExecutor(); // 找到对该ApplicationEvent感兴趣的监听器(ApplicationListener) for (ApplicationListener listener : getApplicationListeners(event, type)) { // 判断是否指定了ApplicationListener在哪个线程执行器中执行 if (executor != null) { // 在指定的taskExecutor中执行，不会阻塞调用线程 executor.execute(() -> invokeListener(listener, event)); } else { // 没有指定taskExecutor，执行在调用线程中执行（可能会阻塞调用线程） invokeListener(listener, event); } } } protected void invokeListener(ApplicationListener listener, ApplicationEvent event) { // 是否有错误处理器，如果有错误处理器，那么ApplicationListener方法内执行抛出异常时会捕获抛出的异常交由指定的错误处理器去处理 // 否则spring不处理 ErrorHandler errorHandler = getErrorHandler(); if (errorHandler != null) { try { doInvokeListener(listener, event); } catch (Throwable err) { // 交由错误处理器处理异常 errorHandler.handleError(err); } } else { // 如果ApplicationListener方法执行时产生异常，则不处理，由上级处理 doInvokeListener(listener, event); } } private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) { try { // onApplicationEvent方法就是我们平时使用ApplicationLisenter接口时要实现的方法，回调观察者 listener.onApplicationEvent(event); } catch (ClassCastException ex) { String msg = ex.getMessage(); if (msg == null || matchesClassCastMessage(msg, event.getClass())) { // Possibly a lambda-defined listener which we could not resolve the generic event type for // -> let's suppress the exception and just log a debug message. Log logger = LogFactory.getLog(getClass()); if (logger.isTraceEnabled()) { logger.trace(\"Non-matching event type for listener: \" + listener, ex); } } else { throw ex; } } }} 从上面第47行代码可以看到这是一个for循环，for循环的对象是getApplications()方法的返回值，这里我们不关注是怎么找到对ApplicationEnvironmentPreparedEvent事件感兴趣的ApplicationListener的，重点看getApplicaitons()方法的返回值有哪些，有哪些ApplicationListener的实现类对ApplicationEnvironmentPreparedEvent事件感兴趣，下面具体分析这些监听器的实现。 3.6.4.2、接收ApplicationEnvironmentPreparedEvent事件的ApplicationListener使用idea调试时getApplications()方法的返回值(spring cloud环境)： 按照执行顺序这些监听器的实现出处如下（注意下面文件的内容不是实际的文件内容顺序，是按照实际执行顺序列出）： spring-cloud-context-2.2.0.RELEASE.jar!\\META-INF\\spring.factories 共2个 properties12345## Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.cloud.bootstrap.BootstrapApplicationListener,\\org.springframework.cloud.bootstrap.LoggingSystemShutdownListener,\\...省略不相关的 spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories properties123456## Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.context.config.ConfigFileApplicationListener,\\org.springframework.boot.context.config.AnsiOutputApplicationListener,\\org.springframework.boot.context.logging.LoggingApplicationListener,\\...省略不相关的 spring-boot-autoconfigure-2.2.1.RELEASE.jar!\\META-INF\\spring.factories共1个 properties123# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.autoconfigure.BackgroundPreinitializer spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories properties123456## Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\org.springframework.boot.context.config.DelegatingApplicationListener,\\org.springframework.boot.context.FileEncodingApplicationListener,\\...省略不相关的 根据getApplications()方法的返回值看到第一个监听了ApplicationEnvironmentPreparedEvent事件的ApplicationListener就是spring cloud的org.springframework.cloud.bootstrap.BootstrapApplicationListener, 下面开始分析BootstrapApplicationListener`类的源码 3.6.4.3、spring cloud的BootstrapApplicationListenerjava123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class BootstrapApplicationListener implements ApplicationListener, Ordered { /** * Property source name for bootstrap. */ public static final String BOOTSTRAP_PROPERTY_SOURCE_NAME = \"bootstrap\"; /** * The default order for this listener. */ public static final int DEFAULT_ORDER = Ordered.HIGHEST_PRECEDENCE + 5; /** * The name of the default properties. */ public static final String DEFAULT_PROPERTIES = \"springCloudDefaultProperties\"; private int order = DEFAULT_ORDER; @Override public void onApplicationEvent(ApplicationEnvironmentPreparedEvent event) { // 这里的environment是SpringApplication.run(xxx.class, args)时创建的StandardServletEnvironment // 属性源包括configurationProperties、servletConfigInitParams、servletContextInitParams、systemProperties、systemEnvironment ConfigurableEnvironment environment = event.getEnvironment(); // 判断spring.cloud.bootstrap.enabled的属性值，若未设置则默认true // 这段代码的意思是是否启用了springg cloud，默认true启动 if (!environment.getProperty(\"spring.cloud.bootstrap.enabled\", Boolean.class, true)) { // 已经设置过spring.cloud.bootstrap.enabled属性为false，代表不启用spring cloud功能，直接返回 // 那么就不会创建id为bootstrap的父ApplicationContext return; } // 运行到这里表示启用spring cloud // don't listen to events in a bootstrap context // 不监听bootstrap的发布的ApplicationEnvironmentPreparedEvent事件， 防止重复创建id为bootstrap的ApplicationContext // 这里判断environment中是否包含名称为\"bootstrap\"的属性源， // 注意后续的bootstrapServiceContext()方法中会为spring cloud的environment添加名称为\"bootstrap\"的属性源， // 所以bootstrapServiceContext()方法中为spring cloud创建的SpringApplication在调用其run()方法时发布 // ApplicationEnvironmentPreparedEvent事件又会进入当前类中，但是由于该bootstrap的environment(spring cloud的)已经 // 有名称为\"bootstrap\"的属性源，所以不会继续往后执行。 if (environment.getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME)) { return; } ConfigurableApplicationContext context = null; // 从命令行参数、系统属性、系统环境变量解析spring.cloud.bootstrap.name的值，如果都未指定则使用默认名称bootstrap String configName = environment.resolvePlaceholders(\"${spring.cloud.bootstrap.name:bootstrap}\"); // 这里的event.getSpringApplication().getInitializers()返回的是SpringApplication.run()方法启动时SpringApplication的构造 // 方法中通过SpringFacoriesLoader获取到的ApplicationContextInitializer。 // 按照顺序如下, 括号中的jar文件名代表其对应的spring.factories文件出处： // org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer （spring-boot-autoconfigure-2.2.1.RELEASE.jar） // org.springframework.boot.context.config.DelegatingApplicationContextInitializer （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.context.ContextIdApplicationContextInitializer （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener （spring-boot-autoconfigure-2.2.1.RELEASE.jar） // org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer （spring-boot-2.2.1.RELEASE.jar） for (ApplicationContextInitializer initializer : event.getSpringApplication().getInitializers()) { if (initializer instanceof ParentContextApplicationContextInitializer) { // 不会运行到这里，上面所有列出来的类都不是ParentContextApplicationContextInitializer类型 context = findBootstrapContext((ParentContextApplicationContextInitializer) initializer, configName); } } // 运行到这里context为null if (context == null) { // 创建id为bootstrap的父ApplicationContext context = bootstrapServiceContext(environment, event.getSpringApplication(), configName); event.getSpringApplication() .addListeners(new CloseContextOnFailureApplicationListener(context)); } apply(context, event.getSpringApplication(), environment); }} 创建spring cloud的ApplicationContext context = bootstrapServiceContext(environment, event.getSpringApplication(), configName);这行代码的实现如下： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169private ConfigurableApplicationContext bootstrapServiceContext( ConfigurableEnvironment environment, final SpringApplication application, String configName) { // 创建spring cloud 的environment StandardEnvironment bootstrapEnvironment = new StandardEnvironment(); // 获取上面创建spring cloud 的可变属性源 MutablePropertySources bootstrapProperties = bootstrapEnvironment.getPropertySources(); for (PropertySource source : bootstrapProperties) { bootstrapProperties.remove(source.getName()); } // 从spring boot的environment获取\"spring.cloud.bootstrap.location\"属性 String configLocation = environment.resolvePlaceholders(\"${spring.cloud.bootstrap.location:}\"); // 创建spring cloud的属性源的数据源，后面会把这个map加进去spring cloud的environment中 Map bootstrapMap = new HashMap(); // 特别注意：\"spring.config.name\"是用于加载配置文件的名称，默认为bootstrap， // 在ConfigFileApplicationListener事件中会获取属性为\"spring.config.name\"的值作为配置文件的名称去加载配置文件 bootstrapMap.put(\"spring.config.name\", configName); bootstrapMap.put(\"spring.main.web-application-type\", \"none\"); if (StringUtils.hasText(configLocation)) { // 特别注意：\"spring.config.location\"是用于加载配置文件的搜索路径，默认为空， // 在ConfigFileApplicationListener事件中会获取属性为\"spring.config.location\"的值，从该路径下去加载配置文件 bootstrapMap.put(\"spring.config.location\", configLocation); } // 为spring cloud的environment添加name为\"bootstrap\"的属性源，属性源中包括2个属性\"spring.config.name\"及\"spring.config.location\" bootstrapProperties.addFirst(new MapPropertySource(BOOTSTRAP_PROPERTY_SOURCE_NAME, bootstrapMap)); // 遍历spring boot的属性源 for (PropertySource source : environment.getPropertySources()) { // 如果是占位符的属性源就跳过 if (source instanceof StubPropertySource) { continue; } // 将spring boot的属性源添加到spring cloud的environment中， // 注意这里是addLast bootstrapProperties.addLast(source); } // 创建spring cloud自身的SpringApplication了， // SpringApplicationBuilder的构造方法会创建SpringApplication对象（又获取ApplicationContextInitializer和ApplicationListener） SpringApplicationBuilder builder = new SpringApplicationBuilder() // 指定激活的环境，此处activeProfiles是通过系统变量\"spring.profiles.active\"设置的 .profiles(environment.getActiveProfiles()) // 关闭banner输出 .bannerMode(Mode.OFF) // 设置spring cloud的环境，设置后在调用run()方法时就不会再创建了 // 这里可以回顾下SpringApplication.getOrCreateEnvironment()方法的实现 .environment(bootstrapEnvironment) // 不打印启动日志 .registerShutdownHook(false).logStartupInfo(false) // 非web .web(WebApplicationType.NONE); // 返回SpringApplicationBuilder创建的SpringApplication final SpringApplication builderApplication = builder.application(); // SpringApplication的构造方法中有this.mainApplicationClass = deduceMainApplicationClass();这行代码会获取mainApplicationClass // 所以builderApplication.getMainApplicationClass()一般不会返回为null if (builderApplication.getMainApplicationClass() == null) { // 不会进入这里 // gh_425: // SpringApplication cannot deduce the MainApplicationClass here // if it is booted from SpringBootServletInitializer due to the // absense of the \"main\" method in stackTraces. // But luckily this method's second parameter \"application\" here // carries the real MainApplicationClass which has been explicitly // set by SpringBootServletInitializer itself already. builder.main(application.getMainApplicationClass()); } if (environment.getPropertySources().contains(\"refreshArgs\")) { // If we are doing a context refresh, really we only want to refresh the // Environment, and there are some toxic listeners (like the // LoggingApplicationListener) that affect global static state, so we need a // way to switch those off. builderApplication .setListeners(filterListeners(builderApplication.getListeners())); } builder.sources(BootstrapImportSelectorConfiguration.class); // 关键代码，创建spring cloud自身的ApplicationContext，又会把spring boot的SpringApplication.run()方法的流程全部走一遍 final ConfigurableApplicationContext context = builder.run(); // gh-214 using spring.application.name=bootstrap to set the context id via // `ContextIdApplicationContextInitializer` prevents apps from getting the actual // spring.application.name // during the bootstrap phase. // 设置spring cloud的ApplicationContext的id为\"bootstrap\" context.setId(\"bootstrap\"); // 这里的addAncestorInitializer方法的第1个参数application是spring boot的SpringApplication对象 // 而第2个参数context是上一行代码返回的spring cloud的ApplicationContext addAncestorInitializer(application, context); // spring cloud的环境中现在有一些属性是我们不想在父ApplicationContext中看到的，所以把它移除(稍后会添加回来) bootstrapProperties.remove(BOOTSTRAP_PROPERTY_SOURCE_NAME); // 合并spring cloud中name为\"defaultProperties\"属性源至spring boot中，注意同名属性不覆盖 mergeDefaultProperties(environment.getPropertySources(), bootstrapProperties); // 返回spring cloud的ApplicationContext return context;}/**** @param application 该属性是spring boot的SpringApplication对象* @param context spring cloud的ApplicationContext*/private void addAncestorInitializer(SpringApplication application, ConfigurableApplicationContext context) { boolean installed = false; for (ApplicationContextInitializer initializer : application .getInitializers()) { if (initializer instanceof AncestorInitializer) { installed = true; // New parent ((AncestorInitializer) initializer).setParent(context); } } if (!installed) { application.addInitializers(new AncestorInitializer(context)); }}/*** 这个方法的目的如下：* 1、如果spring cloud中有name为\"springCloudDefaultProperties\"的属性源，而spring boot中没有该名称的属性源，则直接把* spring cloud的name为\"springCloudDefaultProperties\"的属性源加到spring boot的environment的末尾。** 2、如果spring cloud中有name为\"springCloudDefaultProperties\"的属性源，spring boot中也有该名称的属性源，则把spring cloud* 的属性源合并到spring boot的environment中，如果在spring cloud中的属性在spring boot中不存在则追加到spring boot中，特别注意* 如果spring cloud中的属性在spring boot中也存在，则不会覆盖，也就是说spring boot和spring cloud拥有相同key的属性时，spring boot的* 配置文件中的属性优先级高，不会合并该属性。* * @param environment 它是spring boot的environment* @param bootstrap 它是spring cloud的environment*/private void mergeDefaultProperties(MutablePropertySources environment, MutablePropertySources bootstrap) { String name = DEFAULT_PROPERTIES; // 判断spring cloud中是否有name为\"springCloudDefaultProperties\"的属性源 if (bootstrap.contains(name)) { // 获得spring cloud中name为\"springCloudDefaultProperties\"的属性源 PropertySource source = bootstrap.get(name); // 判断spring boot中是否有name为\"springCloudDefaultProperties\"的属性源 if (!environment.contains(name)) { // 如果spring cloud中有name为\"springCloudDefaultProperties\"的属性源，而spring boot中没有该名称的属性源，则直接把 // spring cloud的name为\"springCloudDefaultProperties\"的属性源加到spring boot的environment的末尾 environment.addLast(source); } // spring cloud中有name为\"springCloudDefaultProperties\"的属性源，spring boot中也有该名称的属性源 else { // 获得spring boot中name为\"springCloudDefaultProperties\"的属性源 PropertySource target = environment.get(name); // 判断spring boot和spring cloud的name为\"springCloudDefaultProperties\"的属性源的类型是否是MapPropertySource类型 if (target instanceof MapPropertySource && target != source && source instanceof MapPropertySource) { // 获得spring boot中name为\"springCloudDefaultProperties\"的属性源的底层数据源 Map targetMap = ((MapPropertySource) target).getSource(); // 获得spring cloud中name为\"springCloudDefaultProperties\"的属性源的底层数据源 Map map = ((MapPropertySource) source).getSource(); // 遍历spring cloud中name为\"springCloudDefaultProperties\"的属性源的底层数据源 for (String key : map.keySet()) { // 判断spring cloud中的属性在spring boot是否存在，若spring cloud中的属性在spring boot中不存在则追加到spring boot中 if (!target.containsProperty(key)) { targetMap.put(key, map.get(key)); } // 若spring cloud中的属性在spring boot中存在则忽略，spring cloud不覆盖spring boot的同名属性 } } } } mergeAdditionalPropertySources(environment, bootstrap);} Code1234567891011121314org.springframework.cloud.bootstrap.BootstrapApplicationListener org.springframework.cloud.bootstrap.LoggingSystemShutdownListener org.springframework.boot.context.config.ConfigFileApplicationListener(SmartApplicationListener) org.springframework.boot.env.EnvironmentPostProcessor= org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\\ org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\\ org.springframework.cloud.client.HostInfoEnvironmentPostProcessor org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\ org.springframework.boot.context.config.ConfigFileApplicationListener # PropertySource Loaders org.springframework.boot.env.PropertySourceLoader=\\ org.springframework.boot.env.PropertiesPropertySourceLoader,\\ org.springframework.boot.env.YamlPropertySourceLoader org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor 3.6.4.4、ConfigFileApplicationListener该类的作用是加载配置文件 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered { @Override public void onApplicationEvent(ApplicationEvent event) { if (event instanceof ApplicationEnvironmentPreparedEvent) { onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event); } if (event instanceof ApplicationPreparedEvent) { onApplicationPreparedEvent(event); } } private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) { List postProcessors = loadPostProcessors(); // 当前类本身实现了EnvironmentPostProcessor接口，把自己加到postProcessors集合中， postProcessors.add(this); // 进行排序，排序后此时的postProcessors按照执行顺序如下： // org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor （spring-boot-2.2.1.RELEASE.jar） // org.springframework.cloud.client.HostInfoEnvironmentPostProcessor （spring-cloud-commons-2.2.0.RELEASE.jar） // org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.context.config.ConfigFileApplicationListener （上一行把自己添加进来的，不是来源于spring.factories文件中） // org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor （spring-boot-2.2.1.RELEASE.jar） AnnotationAwareOrderComparator.sort(postProcessors); // 遍历处理每一个EnvironmentPostProcessor for (EnvironmentPostProcessor postProcessor : postProcessors) { postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication()); } } private void onApplicationPreparedEvent(ApplicationEvent event) { this.logger.switchTo(ConfigFileApplicationListener.class); addPostProcessors(((ApplicationPreparedEvent) event).getApplicationContext()); } List loadPostProcessors() { // 返回的EnvironmentPostProcessor按照执行顺序如下： // 括号中的代表该自动化配置的所在的spring.factories文件出处 // org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor （spring-boot-2.2.1.RELEASE.jar） // org.springframework.cloud.client.HostInfoEnvironmentPostProcessor （spring-cloud-commons-2.2.0.RELEASE.jar） // org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor （spring-boot-2.2.1.RELEASE.jar） return SpringFactoriesLoader.loadFactories(EnvironmentPostProcessor.class, getClass().getClassLoader()); } // 当前类实现了EnvironmentPostProcessor接口 @Override public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) { addPropertySources(environment, application.getResourceLoader()); }} SystemEnvironmentPropertySourceEnvironmentPostProcessor java123456789101112131415161718192021222324252627282930313233public class SystemEnvironmentPropertySourceEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered { @Override public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) { // sourceName的值为\"systemEnvironment\" String sourceName = StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME; // 获取name为\"systemEnvironment\"的系统环境变量属性源 PropertySource propertySource = environment.getPropertySources().get(sourceName); // 一般都不会为null if (propertySource != null) { // 会执行到这里，调用当前类的replacePropertySource方法 replacePropertySource(environment, sourceName, propertySource); } } /** * * @param environment spring boot/cloud的环境对象，servlet环境是StandardServletEnvironment * @param sourceName 值为\"systemEnvironment\" * @parm propertySource 名称为\"systemEnvironment\"的系统环境变量属性源 */ private void replacePropertySource(ConfigurableEnvironment environment, String sourceName, PropertySource propertySource) { // 获取所有系统环境变量 Map originalSource = (Map) propertySource.getSource(); SystemEnvironmentPropertySource source = new OriginAwareSystemEnvironmentPropertySource(sourceName, originalSource); // 把name为\"systemEnvironment\"的系统环境变量属性源替换为OriginAwareSystemEnvironmentPropertySource // 有什么作用？？目前还不清楚为什么要这样做。 environment.getPropertySources().replace(sourceName, source); }} SpringApplicationJsonEnvironmentPostProcessor java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/**** 找到environment中Key为\"spring.application.json\"的属性，将其值解析为Map对象，作为一个属性源，* 向environment中添加1个name为\"spring.application.json\"的JsonPropertySource属性源，数据源是之前描述的解析得到的Map对象*/public class SpringApplicationJsonEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered { public static final String SPRING_APPLICATION_JSON_PROPERTY = \"spring.application.json\"; public static final String SPRING_APPLICATION_JSON_ENVIRONMENT_VARIABLE = \"SPRING_APPLICATION_JSON\"; @Override public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) { // 获取可变属性源，包括springApplicationCommandLineArgs、configurationProperties、bootstrap、systemProperties、systemEnvironment属性源 MutablePropertySources propertySources = environment.getPropertySources(); propertySources.stream() // 获取\"spring.application.json\" 或 \"SPRING_APPLICATION_JSON\"属性的实际值对应的JsonPropertyValue对象 // 如果当前属性源不存在该属性则返回null // 返回的数据形式如[null, JsonPropertyValue, null, JsonPropertyValue, JsonPropertyValue, null...] .map(JsonPropertyValue::get) // 找出第一个非null的JsonPropertyValue .filter(Objects::nonNull).findFirst() // 如果存在\"spring.application.json\" 或 \"SPRING_APPLICATION_JSON\"属性的实际值对应的JsonPropertyValue对象则进行处理 .ifPresent((v) -> processJson(environment, v)); } // 处理spring boot/cloud环境中\"spring.application.json\" 或 \"SPRING_APPLICATION_JSON\"属性的实际值对应的JsonPropertyValue对象 private void processJson(ConfigurableEnvironment environment, JsonPropertyValue propertyValue) { // 根据classpath类路径是否存在com.fasterxml.jackson.databind.ObjectMapper、com.google.gson.Gson、org.yaml.snakeyaml.Yaml // 类返回对应的解析器JacksonJsonParser、GsonJsonParser、YamlJsonParser、BasicJsonParser JsonParser parser = JsonParserFactory.getJsonParser(); // propertyValue.getJson()的值为environment中\"spring.application.json\" 或 \"SPRING_APPLICATION_JSON\"属性的值 // 使用jackson、gson、yaml将字符串解析为Map类型对象 Map map = parser.parseMap(propertyValue.getJson()); if (!map.isEmpty()) { // 添加name为\"spring.application.json\"的属性源 addJsonPropertySource(environment, new JsonPropertySource(propertyValue, flatten(map))); } } private static class JsonPropertyValue { // 实际值为 [\"spring.application.json\", \"SPRING_APPLICATION_JSON\"] private static final String[] CANDIDATES = { SPRING_APPLICATION_JSON_PROPERTY, SPRING_APPLICATION_JSON_ENVIRONMENT_VARIABLE }; private final PropertySource propertySource; private final String propertyName; private final String json; /** * @param propertySource \"spring.application.json\" 或 \"SPRING_APPLICATION_JSON\"属性所在的属性源 * @param propertyName 表示根据哪个属性名找到的属性值的，值为字符串\"spring.application.json\" 或 \"SPRING_APPLICATION_JSON\"其中之一 * @param json 在envorpnment中\"spring.application.json\" 或 \"SPRING_APPLICATION_JSON\"属性对应的值 */ JsonPropertyValue(PropertySource propertySource, String propertyName, String json) { this.propertySource = propertySource; this.propertyName = propertyName; this.json = json; } /** * * @param propertySource 属性源 */ static JsonPropertyValue get(PropertySource propertySource) { for (String candidate : CANDIDATES) { // 获取\"spring.application.json\" 或 \"SPRING_APPLICATION_JSON\"属性的实际值 Object value = propertySource.getProperty(candidate); // 判断属性的值是否是字符串并且有内容 if (value instanceof String && StringUtils.hasLength((String) value)) { // 返回当前类的实例 return new JsonPropertyValue(propertySource, candidate, (String) value); } } return null; } } private static class JsonPropertySource extends MapPropertySource implements OriginLookup { private final JsonPropertyValue propertyValue; JsonPropertySource(JsonPropertyValue propertyValue, Map source) { // 属性源的name为\"spring.application.json\" super(SPRING_APPLICATION_JSON_PROPERTY, source); this.propertyValue = propertyValue; } @Override public Origin getOrigin(String key) { return this.propertyValue.getOrigin(); } } } HostInfoEnvironmentPostProcessor java123456789101112131415161718192021222324252627public class HostInfoEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered { @Override public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) { // 找到第1个非回环地址(非127.xxx.xxx.xxx)信息 InetUtils.HostInfo hostInfo = getFirstNonLoopbackHostInfo(environment); LinkedHashMap map = new LinkedHashMap(); // 计算机名，例如我的电脑是calebzhao，win10系统在桌面图标“此电脑”右键菜单点击属性即可看到计算机名 map.put(\"spring.cloud.client.hostname\", hostInfo.getHostname()); // 电脑ip地址，不是本地回环地址，一般个人计算机是192.168.xxx.xxx map.put(\"spring.cloud.client.ip-address\", hostInfo.getIpAddress()); MapPropertySource propertySource = new MapPropertySource( \"springCloudClientHostInfo\", map); // 添加了一个名称为springCloudClientHostInfo的属性源 environment.getPropertySources().addLast(propertySource); } private HostInfo getFirstNonLoopbackHostInfo(ConfigurableEnvironment environment) { InetUtilsProperties target = new InetUtilsProperties(); ConfigurationPropertySources.attach(environment); Binder.get(environment).bind(InetUtilsProperties.PREFIX, Bindable.ofInstance(target)); try (InetUtils utils = new InetUtils(target)) { return utils.findFirstNonLoopbackHostInfo(); } }} ConfigFileApplicationListener 默认从[\"file:./config/\", \"file:./\", \"classpath:/config/\", \"classpath:/\"]目录下加载配置文件 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341public class ConfigFileApplicationListener implements EnvironmentPostProcessor, SmartApplicationListener, Ordered { private static final String DEFAULT_PROPERTIES = \"defaultProperties\"; public static final String ACTIVE_PROFILES_PROPERTY = \"spring.profiles.active\"; public static final String INCLUDE_PROFILES_PROPERTY = \"spring.profiles.include\"; static { Set filteredProperties = new HashSet(); filteredProperties.add(\"spring.profiles.active\"); filteredProperties.add(\"spring.profiles.include\"); LOAD_FILTERED_PROPERTY = Collections.unmodifiableSet(filteredProperties); } // 入口 @Override public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) { addPropertySources(environment, application.getResourceLoader()); } protected void addPropertySources(ConfigurableEnvironment environment, ResourceLoader resourceLoader) { // 在systemEnvironment属性源之后添加能够获取随机数的属性源，属性源的名称为\"random\" RandomValuePropertySource.addToEnvironment(environment); // 加载 new Loader(environment, resourceLoader).load(); } private class Loader { private final ConfigurableEnvironment environment; private final PropertySourcesPlaceholdersResolver placeholdersResolver; private final ResourceLoader resourceLoader; private final List propertySourceLoaders; private Deque profiles; Loader(ConfigurableEnvironment environment, ResourceLoader resourceLoader) { this.environment = environment; this.placeholdersResolver = new PropertySourcesPlaceholdersResolver(this.environment); this.resourceLoader = (resourceLoader != null) ? resourceLoader : new DefaultResourceLoader(); // 这里非常关键，到spring.factories中找key为org.springframework.boot.env.PropertySourceLoader的属性源加载器, // 括号中的内容代表该PropertySourceLoader所在的spring.factories文件所在的jar文件，按照执行顺序找到的实现如下： // org.springframework.boot.env.PropertiesPropertySourceLoader （spring-boot-2.2.1.RELEASE.jar） // org.springframework.boot.env.YamlPropertySourceLoader （spring-boot-2.2.1.RELEASE.jar） this.propertySourceLoaders = SpringFactoriesLoader.loadFactories(PropertySourceLoader.class, getClass().getClassLoader()); } // 实际处理逻辑：加载项目下的application.yml，，默认从[\"file:./config/\", \"file:./\", \"classpath:/config/\", \"classpath:/\"]加载配置文件 void load() { // environment包括springApplicationCommandLineArgs、configurationProperties、【bootstrap】、systemProperties、systemEnvironment属性源 FilteredPropertySource.apply(this.environment, DEFAULT_PROPERTIES, // defaultProperties LOAD_FILTERED_PROPERTY, // [\"spring.profiles.active\", \"spring.profiles.include\"] (defaultProperties) -> { this.profiles = new LinkedList(); this.processedProfiles = new LinkedList(); this.activatedProfiles = false; this.loaded = new LinkedHashMap(); // 1.把环境中的profiles取出来，默认会增加1个为null的profile // 如果用户如果自己通过命令行参数、jvm系统属性、系统环境变量指定了\"spring.profiles.active\" // 或\"spring.profiles.include\"属性值则不使用默认的profile， // 否则表明用户没有明确指定启用哪些profile，那么就使用spring默认的profile， // 用户设置可以覆盖spring默认设置 initializeProfiles(); // 2.循环处理profiles，查找文件位置然后去加载文件 while (!this.profiles.isEmpty()) { Profile profile = this.profiles.poll(); // 判断是否是默认profile if (isDefaultProfile(profile)) { addProfileToEnvironment(profile.getName()); } // 重点：加载该环境的配置文件 load(profile, this::getPositiveProfileFilter, addToLoaded(MutablePropertySources::addLast, false)); this.processedProfiles.add(profile); } load(null, this::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, true)); addLoadedPropertySources(); applyActiveProfiles(defaultProperties); } ); } private void initializeProfiles() { // The default profile for these purposes is represented as null. We add it // first so that it is processed first and has lowest priority. this.profiles.add(null); // ACTIVE_PROFILES_PROPERTY常量的值为\"spring.profiles.active\" // 从environment中取key为\"spring.profiles.active\"的值，若未找到返回空集合 Set activatedViaProperty = getProfilesFromProperty(ACTIVE_PROFILES_PROPERTY); // INCLUDE_PROFILES_PROPERTY常量的值为\"spring.profiles.include\" // 从environment中取key为\"spring.profiles.include\"的值，若未找到返回空集合 Set includedViaProperty = getProfilesFromProperty(INCLUDE_PROFILES_PROPERTY); // 从environment中找到profile名称不在activatedViaProperty及includedViaProperty集合内的已激活的profile的名称 List otherActiveProfiles = getOtherActiveProfiles(activatedViaProperty, includedViaProperty); this.profiles.addAll(otherActiveProfiles); // Any pre-existing active profiles set via property sources (e.g. // System properties) take precedence over those added in config files. this.profiles.addAll(includedViaProperty); addActiveProfiles(activatedViaProperty); // 如果用户如果自己通过命令行参数、jvm系统属性、系统环境变量指定了\"spring.profiles.active\"或\"spring.profiles.include\"属性值 // 则不使用默认的profile，否则表明用户没有明确指定启用哪些profile，那么就使用spring默认的profile，用户设置可以覆盖spring默认设置 if (this.profiles.size() == 1) { // profiles集合中只包含1个null元素 // 获取默认profile的名称，this.environment.getDefaultProfiles()方法默认返回字符串\"default\" for (String defaultProfileName : this.environment.getDefaultProfiles()) { // 创建name为\"default\"的Profile对象 Profile defaultProfile = new Profile(defaultProfileName, true); // 将默认profile加到profiles中，此时profiles集合变成 [ null, 名称为\"default\"的Profile对象 ] this.profiles.add(defaultProfile); } } } private Set getProfilesFromProperty(String profilesProperty) { if (!this.environment.containsProperty(profilesProperty)) { return Collections.emptySet(); } Binder binder = Binder.get(this.environment); Set profiles = getProfiles(binder, profilesProperty); return new LinkedHashSet(profiles); } private void load(Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer) { // 确定从哪些位置搜索配置文件，默认从[\"file:./config/\", \"file:./\", \"classpath:/config/\", \"classpath:/\"]搜索配置文件 getSearchLocations() // 遍历每个搜索路径 .forEach((location) -> { // 判断搜索路径是否是以\"/\"结尾的，如果是说明指定的目录，否则说明指定的搜索路径精确到具体文件名了 boolean isFolder = location.endsWith(\"/\"); // NO_SEARCH_NAMES集合默认只有1个null元素 // 如果location路径是文件夹，在用户没有明确指定\"spring.config.name\"属性的情况下， // 对于spring boot返回的是[\"application\"]，对于spring cloud返回的是[\"bootstrap\"] Set names = isFolder ? getSearchNames() : NO_SEARCH_NAMES; // 重点：根据names循环加载可能的配置文件 names.forEach((name) -> load(location, name, profile, filterFactory, consumer)); }); } private void load(String location, String name, Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer) { // 判断name是否有值 if (!StringUtils.hasText(name)) { for (PropertySourceLoader loader : this.propertySourceLoaders) { if (canLoadFileExtension(loader, location)) { load(loader, location, profile, filterFactory.getDocumentFilter(profile), consumer); return; } } throw new IllegalStateException(\"File extension of config file location '\" + location + \"' is not known to any PropertySourceLoader. If the location is meant to reference \" + \"a directory, it must end in '/'\"); } Set processed = new HashSet(); // this.propertySourceLoaders的值是在Loader类的构造方法中通过 // SpringFactoriesLoader.loadFactories(PropertySourceLoader.class, getClass().getClassLoader())初始化的。 // this.propertySourceLoaders集合属性值按照顺序包括: // org.springframework.boot.env.PropertiesPropertySourceLoader // org.springframework.boot.env.YamlPropertySourceLoader for (PropertySourceLoader loader : this.propertySourceLoaders) { // loader.getFileExtensions()方法返回值分如下2种情况： // 对于org.springframework.boot.env.PropertiesPropertySourceLoader返回 [\"properties\", \"xml\"] // 对于org.springframework.boot.env.YamlPropertySourceLoader返回 [\"yml\", \"yaml\"] for (String fileExtension : loader.getFileExtensions()) { if (processed.add(fileExtension)) { // 核心方法：加载spring boot、spring cloud的配置文件 loadForFileExtension(loader, location + name, \".\" + fileExtension, profile, filterFactory, consumer); } } } } /** * * @param loader 属性加载器，PropertiesPropertySourceLoader或YamlPropertySourceLoader * @param prefix 不包括扩展名的路径，例如\"file:./config/bootstrap\"、\"classpath:./config/application\"、\"classpath:/application\"等 * @param fileExtension 文件扩展名，例如\".yml\"、\".yaml\"、\".properties\"、\".xml\" * @param profile 启用的环境 * */ private void loadForFileExtension(PropertySourceLoader loader, String prefix, String fileExtension, Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer) { DocumentFilter defaultFilter = filterFactory.getDocumentFilter(null); DocumentFilter profileFilter = filterFactory.getDocumentFilter(profile); if (profile != null) { // 加载特定环境的配置文件 // 例如\"file:./config/bootstrap-default.yml\" 、\"classpath:/application-default.yml\" String profileSpecificFile = prefix + \"-\" + profile + fileExtension; load(loader, profileSpecificFile, profile, defaultFilter, consumer); load(loader, profileSpecificFile, profile, profileFilter, consumer); // Try profile specific sections in files we've already processed for (Profile processedProfile : this.processedProfiles) { if (processedProfile != null) { String previouslyLoaded = prefix + \"-\" + processedProfile + fileExtension; load(loader, previouslyLoaded, profile, profileFilter, consumer); } } } // 加载常规配置文件 // 例如\"file:./config/bootstrap.yml\" 、\"classpath:/application.yml\" load(loader, prefix + fileExtension, profile, profileFilter, consumer); } private void load(PropertySourceLoader loader, String location, Profile profile, DocumentFilter filter, DocumentConsumer consumer) { try { // 真正加载配置文件了 Resource resource = this.resourceLoader.getResource(location); if (resource == null || !resource.exists()) { if (this.logger.isTraceEnabled()) { StringBuilder description = getDescription(\"Skipped missing config \", location, resource, profile); this.logger.trace(description); } return; } if (!StringUtils.hasText(StringUtils.getFilenameExtension(resource.getFilename()))) { if (this.logger.isTraceEnabled()) { StringBuilder description = getDescription(\"Skipped empty config extension \", location, resource, profile); this.logger.trace(description); } return; } String name = \"applicationConfig: [\" + location + \"]\"; List documents = loadDocuments(loader, name, resource); if (CollectionUtils.isEmpty(documents)) { if (this.logger.isTraceEnabled()) { StringBuilder description = getDescription(\"Skipped unloaded config \", location, resource, profile); this.logger.trace(description); } return; } List loaded = new ArrayList(); for (Document document : documents) { if (filter.match(document)) { addActiveProfiles(document.getActiveProfiles()); addIncludedProfiles(document.getIncludeProfiles()); loaded.add(document); } } Collections.reverse(loaded); if (!loaded.isEmpty()) { loaded.forEach((document) -> consumer.accept(profile, document)); if (this.logger.isDebugEnabled()) { StringBuilder description = getDescription(\"Loaded config file \", location, resource, profile); this.logger.debug(description); } } } catch (Exception ex) { throw new IllegalStateException(\"Failed to load property source from location '\" + location + \"'\", ex); } } // 确定从哪些位置搜索配置文件 private Set getSearchLocations() { // CONFIG_LOCATION_PROPERTY常量值为\"spring.config.location\" // 这里的意图是判断用户是否通过命令行参数、系统属性、系统环境变量指定了\"spring.config.location\"属性值 // 如果指定了\"spring.config.location\"属性值则使用用户指定的配置文件路径 if (this.environment.containsProperty(CONFIG_LOCATION_PROPERTY)) { return getSearchLocations(CONFIG_LOCATION_PROPERTY); } // CONFIG_ADDITIONAL_LOCATION_PROPERTY常量值为\"spring.config.additional-location\" // 这里的意图是判断命令行参数、系统属性、系统环境变量是否指定了\"spring.config.additional-location\"属性值 // 如果指定了说明除了要解析默认的配置文件路径外，还要额外解析指定位置的配置文件，这就是additional-location所表达的意思 Set locations = getSearchLocations(CONFIG_ADDITIONAL_LOCATION_PROPERTY); // DEFAULT_SEARCH_LOCATIONS常量值为\"classpath:/,classpath:/config/,file:./,file:./config/\" locations.addAll( // ConfigFileApplicationListener.this.searchLocations默认为null // asResolvedSet返回值为集合[\"file:./config/\", \"file:./\", \"classpath:/config/\", \"classpath:/\"] asResolvedSet(ConfigFileApplicationListener.this.searchLocations, DEFAULT_SEARCH_LOCATIONS)); return locations; } private Set getSearchLocations(String propertyName) { Set locations = new LinkedHashSet(); // 判断environment环境中是否包含指定属性 if (this.environment.containsProperty(propertyName)) { for (String path : asResolvedSet(this.environment.getProperty(propertyName), null)) { if (!path.contains(\"$\")) { path = StringUtils.cleanPath(path); if (!ResourceUtils.isUrl(path)) { // ResourceUtils.FILE_URL_PREFIX常量值为\"file:\" path = ResourceUtils.FILE_URL_PREFIX + path; } } locations.add(path); } } return locations; } // 确定配置文件的名称 private Set getSearchNames() { // CONFIG_NAME_PROPERTY常量值为\"spring.config.name\" // 这里的意图是判断用户是否通过命令行参数、系统属性、系统环境变量指定了\"spring.config.name\"属性 // 特别注意spring cloud的BootstrapApplicationListener中的bootstrapServiceContext()方法中， // 创建的environment添加了1个名称为bootstrap的属性源，该属性源中就指定了\"spring.config.name\"属性值为\"bootstrap\" if (this.environment.containsProperty(CONFIG_NAME_PROPERTY)) { // 用户指定了\"spring.config.name\"属性，获取属性值 String property = this.environment.getProperty(CONFIG_NAME_PROPERTY); // 对属性值以逗号分隔，返回倒序集合，例如用户通过命令行参数指定属性-D\"spring.config.name=application.yml,config.yml\" // 则返回[\"config.yml\", \"application.yml\"] return asResolvedSet(property, null); } // DEFAULT_NAMES常量值为\"application\", ConfigFileApplicationListener.this.names属性默认值为null // 运行到这里说明用户没有指定\"spring.config.name\"属性，那么使用默认配置文件名称\"application\" return asResolvedSet(ConfigFileApplicationListener.this.names, DEFAULT_NAMES); } /** * 如果value为空则使用后备值fallback，否则从environment中解析value中的占位符，然后按逗号分隔并反转 * 例如：value为null, fallback为\"classpath:/,classpath:/config/,file:./,file:./config/\"，则返回 * 集合[\"file:./config/\", \"file:./\", \"classpath:/config/\", \"classpath:/\"] */ private Set asResolvedSet(String value, String fallback) { // 以逗号分隔的字符串分割转集合 List list = Arrays.asList(StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray( (value != null) ? this.environment.resolvePlaceholders(value) : fallback))); // 对集合反转 Collections.reverse(list); return new LinkedHashSet(list); } }} FilteredPropertySource源码 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package org.springframework.boot.context.config;import java.util.Set;import java.util.function.Consumer;import org.springframework.core.env.ConfigurableEnvironment;import org.springframework.core.env.MutablePropertySources;import org.springframework.core.env.PropertySource;/** * Internal {@link PropertySource} implementation used by * {@link ConfigFileApplicationListener} to filter out properties for specific operations. * * @author Phillip Webb */class FilteredPropertySource extends PropertySource { private final Set filteredProperties; FilteredPropertySource(PropertySource original, Set filteredProperties) { super(original.getName(), original); this.filteredProperties = filteredProperties; } @Override public Object getProperty(String name) { if (this.filteredProperties.contains(name)) { return null; } return getSource().getProperty(name); } /** * * @parma environment spring boot/cloud的环境对象，包含了springApplicationCommandLineArgs、 * configurationProperties、【bootstrap】、systemProperties、systemEnvironment属性源 * * @param propertySourceName 字符串\"defaultProperties\" * @parm filteredProperties 集合[\"spring.profiles.active\", \"spring.profiles.include\"] * @param operation 消费者 * */ static void apply(ConfigurableEnvironment environment, String propertySourceName, Set filteredProperties, Consumer operation)","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"https://calebzhao.github.io/categories/spring-boot/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"https://calebzhao.github.io/tags/spring-boot/"}]},{"title":"深入理解jvm","slug":"深入理解jvm","date":"2019-12-30T00:22:37.000Z","updated":"2020-01-10T04:43:18.143Z","comments":true,"path":"2019/12/30/深入理解jvm/","link":"","permalink":"https://calebzhao.github.io/2019/12/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm/","excerpt":"","text":"1、前置知识1.1、jvm参数使用形式-XX:+option 表示开启option选项 -XX:-option 表示关闭option选项 -XX:option=value 表示option选项的值设置为value 注意上述符号：X是大写的，“-”是减号，“+”是加号 1.2、查看编译后的.class文件的字节码指令进入到class文件所在目录，执行下述命令： javap com.mysql.Driver 查看反编译后的源代码 javap -c xxx.class javap -v xxx.class 查看详细的字节码信息 1.3、追踪jvm加载与卸载class-XX:+TraceClassLoading，用于追踪类的加载信息并打印出来 -XX:+TraceClassUnloading 跟踪类的卸载 打印如下： 1.4、jvm指令Code123456789101112131415161718192021222324252627282930313233// ldc指令表示将int、float、String类型的常量值从常量池推送至栈顶public static final String salary = \"hello world\";// bipush指令表示将单字节（-128到127）的常量池推送至栈顶public static final short s = 7;// bipush指令将除了-1 到 5 外的int类型t从常量池推送至栈顶public static final int i2_ = -2// iconst_m1指令将-1从常量池推送至栈顶public static final int i1_ = -1;// iconst_0指令将0从常量池推送至栈顶public static final int i0 = 0;// iconst_1指令将1从常量池推送至栈顶public static final int i1 = 1;// iconst_2指令将2从常量池推送至栈顶public static final int i2 = 2;// iconst_3指令将3从常量池推送至栈顶public static final i = 3;// iconst_4指令将4从常量池推送至栈顶public static final int i = 4;// iconst_5指令将5从常量池推送至栈顶public static final int i5= 5;// bipush指令将除了-1 到 5 外的int类型t从常量池推送至栈顶public static final int i6= 6;// iconst_1public static final boolean b1 = true;// iconst_1public static final byte byte1 = 1;// bipushpublic static final char c1 = 'A'; 2、类的加载过程及ClassLoader2.1、类加载的概念2.1.1、类加载的概念类的加载是指将类的.class文件中的二进制数据读入内存中，将其放在运行时数据区的方法区中，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象放在哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区中的数据结构。 2.2.2、加载.class文件的方式 从本地文件系统中直接加载 通过网络下载.class文件 从zip、jar登归档文件中加载c.lass文件 从专有数据库中提取.class文件 将java源文件动态编译为.class文件（应用场景：动态代理、asm、cglib、jsp编译为servlet等）2.2、类加载的过程2.2.1、类加载的5大阶段 加载阶段：加载字节码 链接阶段： 2.1. 验证阶段：验证字节码是否正确 2.1.1. 魔数是否正确、2.1.2. 字节码的主从版本号是否能被当前虚拟机执行​2.1.3. 类定义是否正确，如类实现了接口，则素有方法必须都实现，抽象类里的没有实现的方法是否是抽象方法，final不能被改 2.2. 准备阶段：为静态变量分配内存空间，并赋**默认值（注意这里并不是赋初始值**） 2.3. 解析阶段 初始化阶段：为类的静态变量赋初始值(静态代码块的执行也是在这一步) 类的初始化过程, 这几个阶段是按顺序开始，而不是按顺序进行或完成， 因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 2.3、导致类初始化的jvm规范类初始化是类加载过程的最后一个阶段，到初始化阶段，才真正开始执行类中的Java程序代码。虚拟机规范严格规定了有且只有5种情况必须立即对类进行初始化： 第一种：遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的Java代码场景是：使用new关键字实例化对象时、读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。第二种：使用Java.lang.refect包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。第三种：初始化一个类的子类，当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。第四种：当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。第五种：当使用JDK1.5支持时，如果一个java.langl.incoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 虚拟机规定有且只有这5种情况才会触发类的初始化，这5中场景中的行为称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发其初始化阶段（注意这里没有说不加载这个类），称为被动引用。下面举一些例子来说明主动使用和被动引用。 2.4、导致类初始化的代码示例2.4.1、通过子类引用父类中的静态字段，这时对子类的引用为被动引用，因此不会初始化子类（可能会加载子类），只会初始化父类类加载器并不需要等待某个类被“首次使用”时再加载它 jvm添加参数： -XX:+TraceClassLoading 用于追踪类的加载信息并打印出来 Code1234567891011121314151617181920212223242526272829public class ClassInitialDemo { public static void main(String[] args) throws ClassNotFoundException { // 重点：重点注意，父类会初始化，但是不会导致子类初始化 System.out.println(Child.salary); }}class Parent{ public static int salary = 100; static { System.out.println(\"Obj 初始化\"); } static void print(){ System.out.println(salary); }}class Child extends Parent{ public static int age = 32; static { System.out.println(\"Child 初始化\"); }} 从输出可以看出这里并没有使用到Child子类, 但是jvm加载了父类Obj, 也加载了子类Child，初始化了父类Obj, 但是并没有初始化子类，验证了前面所说的“**类加载器并不需要等待某个类被“首次使用”时再加载它**” 2.4.2、子类继承父类，主动引用子类时，先初始化父类，再初始化子类（并不适用于接口）Code12345678910111213141516171819202122232425public class ClassInitialDemo { public static void main(String[] args) throws ClassNotFoundException { System.out.println(Child.age); }}class Parent{ public static int salary = 100; static { System.out.println(\"Obj 初始化\"); } public static void print(){ System.out.println(salary); }}class Child extends Parent{ public static int age = 32; static { System.out.println(\"Child 初始化\"); }} 2.4.3、初始化一个类时并不会初始化其父接口，但是却会加载父接口Code12345678910111213141516171819202122interface ParentInterface{ int a = 1; int b = new Random().nextInt(10); Thread c = new Thread(){ { System.out.println(\"ParentInterface\"); } };}class ChildClass implements ParentInterface{ public static int b = 2;}public class Demo{ public static void main(String[] args) { System.out.println(ChildClass.b); }} 输出结果： 可以看到加载了ParentInterface.class， 但是并没有输出“ParentInterface”, 验证了上面说的子类实现接口时，主动引用子类不会导致父接口的初始化， 如果子类引用的变量被final修饰了，那么子类也不会加载 2.4.3、编译器可确定的静态常量不会导致类的加载及初始化(注意接口中的变量都是static final)常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中，本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化。 注意：这里指的是将常量存放到了ClassInitialDemo的常量池中，之后ClassInitialDemo与FinalObj就没有任何关系了，删除了FinalObj.class文件，ClassInitialDemo仍然能正常运行 Code12345678910111213141516171819202122public class ClassInitialDemo { public static void main(String[] args) throws ClassNotFoundException { // 重点：编译器可确定的静态常量不会导致类初始化 System.out.println(FinalObj.salary); System.out.println(FinalObj.s); }}class FinalObj{ // ldc指令，对于确定值得常量在编译器把他放到常量池了，不会导致类的加载及初始化 // 这里如果删除final会导致类的加载初始化 public static final String salary = \"hello world\"; // bipush指令 public static final short s = 7; static { System.out.println(\"FinalObj 初始化\"); }} 颠覆三观**：运行前删除FinalObj.class文件，但是代码却能正常运行** 通过命令行执行javap -c ClassInitialDemo.class查看字节码 *可以看到在ClassInitialDemo中已经存在hello world, * 2.4.4、接口中变量的加载结论：接口中的变量默认都是public statc final的，所以编译期就会把a和b放到其运行类所在的常量池中，运行时和ParentInterface.class和ChildInterface.class已经没有任何关系了。 Code1234567891011interface ParentInterface{ int a = 1; int b = new Random().nextInt(10);}interface ChildInterface extends ParentInterface{ int b = 2;} 测试代码 Code1234System.out.println(ParentInterface.a);System.out.println(ChildInterface.a);System.out.println(ChildInterface.b);System.out.println(ChildInterface.d); 编译后先删除ParentInterface.class和ChildInterface.class, 然后再运行上述代码会发现这2个类不存在了，仍然能正常运行，通过 jvm追加参数-XX:+TraceClassLoading打印的日志会发现也没有加载这2个类。 执行结果： 2.4.5、初始化子接口时并不会初始化其父接口Code123456789101112131415161718192021222324interface ParentInterface{ Thread c = new Thread(){ { System.out.println(\"ParentInterface\"); } };}interface ChildInterface extends ParentInterface{ Thread d = new Thread(){ { System.out.println(\"ChildInterface\"); } };}}public class Demo{ public static void main(String[] args) { System.out.println(ChildInterface.d); ｝｝ 输出结果: 从输出可以看到父接口和子接口都被加载了，但是只初始化了子接口，而没有初始化父接口2.4.6、编译期不能确定的静态常量会导致类初始化Code123456789101112131415public class ClassInitialDemo { public static void main(String[] args) throws ClassNotFoundException { // 重点：编译器不能确定的静态常量会导致类初始化 System.out.println(FinalObj.x); }}class FinalObj{ //虽然被final修饰，但是其值在编译器不能确定，必须要类初始化后才能确定，所以会导致类的初始化 public static final int x = new Random().nextInt(10); static { System.out.println(\"FinalObj 初始化\"); }} 2.4.7、static初始化执行顺序是在所有静态变量赋完默认值后再执行静态变量初始化及静态代码块的Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ClassInitialDemo { public static void main(String[] args) throws ClassNotFoundException { ObjInitial2.getInstance().print(); }}/** * 注意 * 初始化顺序如下： * 1、x = 0 静态变量赋默认值 * 2、y = 0 静态变量赋默认值 * 3、instance = null 静态变量赋默认值null * 4、z = 0 静态变量赋默认值 * 5、x = 0 静态变量初始化 * 5、instance = new ObjInitial2() 静态变量初始化导致构造函数初始化 执行x++ y++ * 6、instance 之后的第一个static静态代码块初始化， 执行x++ y++ * 7、z = x+1初始化 * 8、执行z之后的静态代码块 */class ObjInitial2{ private static int x = 0; private static int y; private static ObjInitial2 instance = new ObjInitial2(); static { x++; y++; System.out.println(\"ObjInitial2 static 初始化\"); } public static int z = x + 1; static { System.out.println(\"z=\" + z); } public ObjInitial2(){ x++; y++; System.out.println(\"ObjInitial2 new 初始化\"); } public static void print(){ System.out.println(\"x=\" +x +\" y=\" + y); } public static ObjInitial2 getInstance(){ return instance; }} 2.4.8、static初始化使用new关键字Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ClassInitialDemo { public static void main(String[] args) throws ClassNotFoundException { ObjInitial.getInstance().print(); }}/** * 注意 * 初始化顺序如下： * 1、instance = null 静态变量赋默认值null * 2、x = 0 静态变量赋默认值 * 3、y = 0 静态变量赋默认值 * 4、instance = new ObjInitial3() 静态变量，初始化导致构造函数初始化 执行x++ y++ * 5、x = 0 静态变量初始化 * 6、static静态代码块初始化， 执行x++ y++ */class ObjInitial3{ private static ObjInitial3 instance = new ObjInitial3(); private static int x = 0; private static int y; static { x++; y++; System.out.println(\"ObjInitial3 static 初始化\"); } public ObjInitial3(){ x++; y++; System.out.println(\"ObjInitial3 new 初始化\"); } public static void print(){ System.out.println(\"x=\" +x +\" y=\" + y); } public static ObjInitial3 getInstance(){ return instance; }} 2.4.9、静态代码块变量访问规则Code1234567891011121314151617181920class ObjInitial4{ static int x = 0; static { // 静态代码块中可以对代码块之前声明的变量进行读写操作 System.out.println(x); x = x + 1; // 对代码块之后生声明的变量只能进行写操作，不能进行读操作 y = 1; // 这行代码编译器会报错 // System.out.println(y); } static int y; } 2.5、jvava内置的类加载器 根加载器（**Bootstrap）， 由c语言实现， 该加载器没有父级加载器，他负责加载jvm的核心类库，如java.lang.*, java.lang.Object就是由根加载器加载的，根加载器从系统属性sun.boot.class.path所指定的目录中加载类库, 根加载器的实现依赖于底层操作系统，属于java虚拟机实现的一部分，他没有继承java.lang.ClassLoader** 扩展类加载器（**ExtClassLoader**), 他的父加载器为根加载器，他从java.ext.dirs系统属性所指定的目录中加载类库或者从jdk的安装目录的jre\\lib\\ext子目录下加载类库，如果把用户创建的jar文件放在该目录下，也会自动由扩展加载器加载。扩展类加载器是纯java类，他继承java.lang.ClassLoader 系统（**AppClassLoader**）类加载器：也称为应用类加载器，它的父加载器为扩展类加载器，它从环境变量classpath或者系统属性** java.class.path所指定的目录中加载类，他是用户自定义的加载器的默认父加载器**，系统类加载器是纯java类，他继承java.lang.ClassLoader 示例代码： Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package classLoader;/** * @author calebzhao * 2019/8/10 13:57 */public class BootClassLoader { public static void main(String[] args) { //根加载器加载的目录 System.out.println(System.getProperty(\"sun.boot.class.path\")); //扩展类加载器(Extension)加载的目录 System.out.println(System.getProperty(\"java.ext.dirs\")); // 系统（System）类加载器加载的目录 System.out.println(System.getProperty(\"java.class.path\")); Class classInitialClass = Class.forName(\"classLoader.ClassInitialDemo\"); // 打印：sun.misc.Launcher$AppClassLoader@18b4aac2 // 其加载器是系统加载器AppClassLoader System.out.println(classInitialClass.getClassLoader()); // 打印：sun.misc.Launcher$ExtClassLoader@677327b6 // 父加载器是ExtClassLoader， 证明了AppClassLoader的父加载器是ExtClassLoader System.out.println(classInitialClass.getClassLoader().getParent()); // 打印：null, // ExtClassLoader的父加载器由于是根加载器，不是java语言实现的， System.out.println(classInitialClass.getClassLoader().getParent().getParent()); // 打印:null // 说明String是由根加载加载的 Class stringClass = Class.forName(\"java.lang.String\"); System.out.println(stringClass.getClassLoader()); // 打印null // 说明Object是由根加载加载的 Class objClass = Class.forName(\"java.lang.Object\"); System.out.println(objClass.getClassLoader()); // 打印：sun.misc.Launcher$AppClassLoader@18b4aac2 // 获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); //数组类型的class对象是由jvm创建的，不是由AppClassLoader创建的 int[] a = new int[1]; System.out.println(a.getClass()); System.out.println(a.getClass().getClassLoader()); // 对于任意类型的数组来说，Class.getClassLoader()的返回值总是和数组中元素的ClassLoader一致 Obj[] objs = new Obj[1]; System.out.println(objs.getClass()); System.out.println(objs.getClass().getClassLoader()); }} 注意：对于任意类型的数组来说，数组类型的Class对象不是由ClassLoader创建的，而是由jvm在需要的时候自动创建的，数组类型的对象Class.getClassLoader()方法的返回值总是和数组中元素的ClassLoader一致。 ClassLoader源代码文档： Class objects for array classes are not created by classloaders, but are created automatically as required by the Java runtime.The class loader for an array class, as returned by {@linkClass#getClassLoader()} is the same as the class loader for its elementtype; if the element type is a primitive type, then the array class has noclass loader. idea运行结果如下： Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 根加载器Bootstrap结果C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\rt.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\sunrsasign.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\classes# 扩展加载器(ExtClassLoader)结果C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext;C:\\WINDOWS\\Sun\\Java\\lib\\ext# 系统加载器(AppClassLoader)结果C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\resources.jar;C:\\ProgramFiles\\Java\\jdk1.8.0_201\\jre\\lib\\rt.jar;F:\\code\\thread-learn\\demo1\\target\\classes;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\junit\\junit\\4.12\\junit-4.12.jar;F:\\program\\nexus-2.11.4-01\\sonatype-work\\nexus\\storage\\central\\org\\hamcrest\\hamcrest-core\\1.3\\hamcrest-core-1.3.jar;C:\\Program Files\\JetBrains\\IntelliJ IDEA 2018.3.4\\lib\\idea_rt.jarsun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@677327b6nullnullnullsun.misc.Launcher$AppClassLoader@18b4aac2class [Inullclass [LclassLoader.Obj;sun.misc.Launcher$AppClassLoader@18b4aac2 2.6、ClassLoader加载类的原理2.6.1、 原理ClassLoader使用的是双亲委派机制来搜索加载类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个组合的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它在亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。 类加载器双亲委托模型： 2.6.2、双亲委托模型好处因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要 ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。 2.6.3、类与类加载器的笔记类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达更通俗一些：比较两个类是否”相等”，只有再这两个类是有同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 2.6.4、JDK的ClassLoader类源代码Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 默认构造方法，可以看出如果没有指定父加载器则默认父加载器为系统加载器AppClassLoaderprotected ClassLoader() { this(checkCreateClassLoader(), getSystemClassLoader());}protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException{ synchronized (getClassLoadingLock(name)) { // 首先检查这个类是否已经被加载过，如果已经被加载过则直接返回class Class c = findLoadedClass(name); // 还没有被加载过 if (c == null) { long t0 = System.nanoTime(); try { // 如果有父加载器，则先委托给父加载器去加载 if (parent != null) { c = parent.loadClass(name, false); } // 没有父加载器，则由根加载器查找 else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { } // 没有父加载器或父加载器返回null没有加载成功 if (c == null) { long t1 = System.nanoTime(); // 由自己加载这个类 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } // 返回null或加载的class return c; }} 先检查是否已经被加载过，若没有加载则调用父加载器的loadClass() 方法，若父加载器为空，则默认使用启动类加载器作为父加载器。如果父加载器失败，再调用自己的findClass 方法进行加载,因此到这里再次证明了类加载器的过程： 2.7、自定义ClassLoader实验第1步、编写MyClassLoader.javaCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package classLoader;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;/** * 自定义类加载器 * @author calebzhao * 2019/8/10 15:30 */public class MyClassLoader extends ClassLoader { private String dir; /** * 如果不指定父ClassLoader则使用系统默认的ExtClassLoader * @param dir */ public MyClassLoader(String dir){ this.dir = dir; } public MyClassLoader(String dir, ClassLoader parent){ super(parent); this.dir = dir; } public void setDir(String dir) { this.dir = dir; } public String getDir() { return dir; } @Override protected Class findClass(String name) throws ClassNotFoundException { String path = name.replace('.', '/'); File file = new File(dir, path + \".class\"); if (!file.exists()){ throw new ClassNotFoundException(); } byte[] classBytes = loadClassBytes(file); if (classBytes == null || classBytes.length == 0){ throw new ClassNotFoundException(); } return this.defineClass(name, classBytes, 0, classBytes.length); } private byte[] loadClassBytes(File file) { try (ByteArrayOutputStream bos = new ByteArrayOutputStream(); FileInputStream fis = new FileInputStream(file);){ byte[] buffer = new byte[1024]; int length = -1; while ((length = fis.read(buffer)) != -1){ bos.write(buffer, 0 , length); } return bos.toByteArray(); } catch (IOException e) { return null; } }} 第2步、编写测试类Code12345678910111213141516171819202122package classLoader;/** * @author calebzhao * 2019/8/10 16:10 */public class MyClassLoaderDemo { public static void main(String[] args) throws ClassNotFoundException { String classBaseDir = \"C:\\\\TestTargetClassLoader\"; MyClassLoader myClassLoader = new MyClassLoader(classBaseDir); Class clazz = myClassLoader.loadClass(\"classLoader.MyClassObj\"); System.out.println(clazz); System.out.println(clazz.getClassLoader()); System.out.println(clazz.getClassLoader().getParent()); }} 编写待加载的类MyClassObj.java Code1234567891011121314package classLoader;/** * @author calebzhao * 2019/8/10 16:51 */public class MyClassObj { private static int x = 1; static { System.out.println(\"MyClassObj 执行了静态代码块 x=\" +x); }} 第3步、编译、拷贝及运行编译MyClassObj.java ，拷贝编译后的target\\classed包到磁盘C:/TestTargetClassLoader下，注意保证包结构完整 删除当前项目的target目录下的MyClassObj.class文件，因为如果不删除这个文件会导致由于双亲委派模型的加载规则，导致自定义加载器的父加载器先加载到这个文件，那么我们自定义的加载器就不会再次去加载了 注意：如果运行后仍发现是由AppClassLoader加载的，则去target/classes目录下看下MyClassObj.class是否已经删除，通常是由于运行的时候idea又把MyClassObj.class编译出来了导致的 最终运行效果如下： 延伸：类加载器多次加载class的是否得到的是同样的class? 当在MyClassLoaderDemo.java中最后如下代码后: Code123456789101112 // 同一个类加载的实例多次调用MyClassLoader myClassLoader2 = new MyClassLoader(classBaseDir);Class clazz2 = myClassLoader2.loadClass(\"classLoader.MyClassObj\");System.out.println(\"第1个ClassLoader实例加载MyClassObj.class得到的hashcode:\" + clazz2.hashCode());Class clazz3 = myClassLoader2.loadClass(\"classLoader.MyClassObj\");System.out.println(\"第1个ClassLoader实例加载MyClassObj.class得到的hashcode:\" + clazz3.hashCode());// 又一个classLoader实例MyClassLoader myClassLoader3 = new MyClassLoader(classBaseDir);Class clazz4 = myClassLoader3.loadClass(\"classLoader.MyClassObj\");System.out.println(\"第2个ClassLoader实例加载MyClassObj.class得到的hashcode:\" + clazz4.hashCode()); 从结果可以看到： 1、同一个类加载器的同一个实例多次调用返回的Class是完全一样的(hascode相同) 2、而同一个类加载器的多个不同实例加载同一个MyClassObj.class文件得到的Class是不一样的(hashcode不相同) 2.8、类的卸载 Code1234567MyClassLoader myClassLoader6 = new MyClassLoader(classBaseDir);Class clazz7 = myClassLoader6.loadClass(\"classLoader.customClassLoader.MyClassObj\");System.out.println(clazz7.hashCode());System.out.println(clazz7.getClassLoader());// 必须myClassLoader6 = null;// 必须 clazz7 = null;System.gc(); 设置jvm启动参数 -XX:+TraceClassUnloading 跟踪类的卸载 输出如下： 2.9、打破双亲委派模型，自下而上加载1、打破双亲委派模型的原理加载class的顺序是自下而上加载（与jdk的ClassLoader实现不同, jdk默认是自上而下加载的），先由自定义加载器加载，如果自己加载不到则再委托给父加载器加载。 2、打破双亲委派模型demoCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package classLoader.customClassLoader;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;/** * @author calebzhao * 2019/8/10 19:47 */public class MyClassLoader2 extends ClassLoader { private String dir; /** * 如果不指定父ClassLoader则使用系统默认的ExtClassLoader * @param dir */ public MyClassLoader2(String dir){ this.dir = dir; } public MyClassLoader2(String dir, ClassLoader parent){ super(parent); this.dir = dir; } public void setDir(String dir) { this.dir = dir; } public String getDir() { return dir; } @Override protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 检查是否已经加载过了 Class cls = findLoadedClass(name); // 还没有加载过 if (cls == null){ // 先从自己尝试加载class cls = findClass(name); // 自己加载不了class，并且有父加载器 if (cls == null && this.getParent() != null){ // 由父加载器加载class cls = this.getParent().loadClass(name); } } return cls; } } @Override protected Class findClass(String name) throws ClassNotFoundException { String path = name.replace('.', '/'); File file = new File(dir, path + \".class\"); if (!file.exists()){ return null; } byte[] classBytes = loadClassBytes(file); if (classBytes == null || classBytes.length == 0){ throw new ClassNotFoundException(); } return this.defineClass(name, classBytes, 0, classBytes.length); } private byte[] loadClassBytes(File file) { try (ByteArrayOutputStream bos = new ByteArrayOutputStream(); FileInputStream fis = new FileInputStream(file);){ byte[] buffer = new byte[1024]; int length = -1; while ((length = fis.read(buffer)) != -1){ bos.write(buffer, 0 , length); } return bos.toByteArray(); } catch (IOException e) { return null; } }} 测试： Code12345678910111213141516171819package classLoader.customClassLoader;/** * @author calebzhao * 2019/8/10 20:01 */public class MyClassLoader2Demo { public static void main(String[] args) throws ClassNotFoundException { String classBaseDir = \"C:\\\\TestTargetClassLoader\"; MyClassLoader2 myClassLoader21 = new MyClassLoader2(classBaseDir); Class clazz21 = myClassLoader21.loadClass(\"classLoader.customClassLoader.MyClassObj\"); System.out.println(clazz21); System.out.println(clazz21.getClassLoader()); System.out.println(clazz21.getClassLoader().getParent()); }} 3、打破双亲委派模型后的自定义加载器是否能够加载java.lang.String?创建一个新项目，结构如下： 把String.class编译后按照其包结构放到之前的C:\\TestTargetClassLoader目录下 上述MyClassLoader2Demo .java文件最后加入如下代表测试是否能够加载String类 Code12Class stringClass = myClassLoader21.loadClass(\"java.lang.String\");System.out.println(stringClass); 报错了，说明并不能加载到String.class文件 2.10 获得ClassLoader的途径 2.11、类加载的命名空间2.11.1、概念 结论： 1、子加载器(MyClassLoader)所加载的类(MySimple)能访问父加载器(AppClassLoader)加载的类(MyCat) 2、父加载器(AppClassLoader)所加载的类(MyCat)不能访问子加载器(MyClassLoader)所加载的类(MySimple) 3、一个类的类加载是由其所在调用方法的类加载器加载的 2.11.2、示例1Code1234567891011121314151617181920212223242526272829package classLoader.namespace;import classLoader.customClassLoader.MyClassLoader2;/** * @author calebzhao * 2019/8/10 20:41 */public class NamespaceDemo { public static void main(String[] args) throws IllegalAccessException, InstantiationException, ClassNotFoundException { String classBaseDir = \"C:\\\\TestTargetClassLoader\"; MyClassLoader2 myClassLoader21 = new MyClassLoader2(classBaseDir); Class clazz21 = myClassLoader21.loadClass(\"classLoader.namespace.NamespaceObj\"); System.out.println(clazz21.hashCode()); System.out.println(clazz21.getClassLoader()); System.out.println(); System.out.println(NamespaceObj.class.hashCode()); System.out.println(NamespaceObj.class.getClassLoader()); NamespaceObj myClassObj = (NamespaceObj) clazz21.newInstance(); System.out.println(myClassObj); }} 输出： 从输出可以看到ClassLoader不一样， NamespaceObj myClassObj = (NamespaceObj) clazz21.newInstance();这行赋值会出现ClassCastException, 明明都是NamespaceObj, 但是其hashcode不同，实例化时当然不是同一个类 2.11.3、一个类的类加载是由其所在调用方法的类加载器加载的1、代码编写 Code1234567891011121314151617181920package classLoader.namespace;import classLoader.customClassLoader.MyClassLoader;/** * @author calebzhao * 2019/8/11 20:14 */public class NamespaceDemo2 { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException { String classBaseDir = \"C:\\\\TestTargetClassLoader\"; MyClassLoader myClassLoader = new MyClassLoader(classBaseDir); Class mySimpleClass = myClassLoader.loadClass(\"classLoader.namespace.MySimple\"); System.out.println(mySimpleClass.getClassLoader()); Object mySimple = mySimpleClass.newInstance(); }} MySimple.java文件 Code1234567891011121314package classLoader.namespace;/** * @author calebzhao * 2019/8/11 21:00 */public class MySimple{ public MySimple(){ System.out.println(\"MySimple invoked\"); System.out.println(\"MySimple ClassLoader:\" + this.getClass().getClassLoader()); new MyCat(); }} MyCat.java文件 Code1234567891011121314package classLoader.namespace;/** * @author calebzhao * 2019/8/11 21:00 */public class MyCat { public MyCat(){ System.out.println(\"MyCat invoked\"); System.out.println(\"MyCat ClassLoader:\" + this.getClass().getClassLoader()); }} 2、编译完后复制class文件到非Classpath目录，如下： 3、然后删除target/classLoader/namespace中的MyCat.class文件 4、运行结果 说明： 可以看到明明自己是用MyClassLoader.loadClass(“classLoader.namespace.MySimple”)去加载MySimple.class文件，由于target目录下有MySimple.class文件，所以根据双亲委派机制实际的加载MySimple.class文件**是由AppClassLoader加载的**，这个毫无疑问，大家都懂。 但是明明**C:\\TestTargetClassLoader\\classLoader\\namespace里面有MyCat.class文件，而target没有MyCat.class文件却报错ClassNotFoundException,为什么呢？** 原因：MySimple类的构造方法中 new MyCat();这一行代码去实例化会导致加载MyCat.class文件，那么MyCat.class文件是由哪个ClassLoader加载的呢? 是由AppClassLoader加载的，因为MyCat的实例化是在MySimple类中进行的，所以会使用和当前调用方（MySimple）相同的类加载器(AppClassLoader)去加载MyCat.class, 而target目录下并没有MyCat.class文件所以导致抛出了ClassNotFoundException文件。 所以得出开始的结论：一个类的类加载是由其所在调用方法的类加载器加载的 2.11.4、命名空间示例1：继续改造重新编译上述后, 删除target/classLoader/namespace中的MySimple.class文件,保留MyCat.class文件 重新运行结果如下： 说明：MySimple.class是由MyClassLoader加载的， 在MySimple.java的构造方法中new Mycat()这一行，首先由MyClassLoader加载，由于双亲委派机制会委托给AppClassLoader加载，AppClassLoader委托给ExtClassLoader, ExtClassLoader委托给Bootstrap ClassLoader, 而根加载器和Ext加载器都加载不到，所以会回到AppClassLoader加载，而target目录下有Mycat.class文件，所以成功加载MyCat类 2.11.5、父加载器**(AppClassLoader)所加载的类(MyCat)不能访问子加载器(MyClassLoader)加载的类(MySimple)**1、代码 Code12345678910111213141516171819package classLoader.namespace;/** * @author calebzhao * 2019/8/11 21:00 */public class MySimple{ public MySimple(){ System.out.println(\"MySimple invoked\"); System.out.println(\"MySimple ClassLoader:\" + this.getClass().getClassLoader()); new MyCat(); //子加载器(MyClassLoader)所加载的类(MySimple)能访问父加载器(AppClassLoader)加载的类(MyCat)// System.out.println(\"from MySimple: \" + MyCat.class); }} Code1234567891011121314151617package classLoader.namespace;/** * @author calebzhao * 2019/8/11 21:00 */public class MyCat { public MyCat(){ System.out.println(\"MyCat invoked\"); System.out.println(\"MyCat ClassLoader:\" + this.getClass().getClassLoader()); //父加载器(AppClassLoader)所加载的类(MyCat)不能访问子加载器(MyClassLoader)加载的类(MySimple) System.out.println(\"from MyCat\" + MySimple.class); }} 2、重新编译，把target/classLoader/namespace下的文件和之前一样复制到非classpath目录 3、删除MySimple.class, 保留MyCat.class文件，重新运行 说明是由于刚刚在MyCat.java的构造方法中加入的System.out.println(“from mycat” + MySimple.class);这一行代码导致的。 原因：MySimple.class由MyClassLoader加载， MyCat.class由AppClassLoader加载, 在MyCat.class中使用MySimple.class会导致加载MySimple.class, 虽然之前加载过MySimple.class， 但是之前的MySimple.class是在MyClassLoader中加载的，而现在MySimple.class是由AppClassLoader尝试加载，而target目录下的MySimple.class已经被我们删除了，所以抛出ClssNotFoundException 2.1.6、子加载器(MyClassLoader)所加载的类(MySimple)能访问父加载器(AppClassLoader)加载的类(MyCat)1、代码 Code12345678910111213public class MySimple{ public MySimple(){ System.out.println(\"MySimple invoked\"); System.out.println(\"MySimple ClassLoader:\" + this.getClass().getClassLoader()); new MyCat(); //子加载器(MyClassLoader)所加载的类(MySimple)能访问父加载器(AppClassLoader)加载的类(MyCat) System.out.println(MyCat.class); }} Code1234567891011121314151617package classLoader.namespace;/** * @author calebzhao * 2019/8/11 21:00 */public class MyCat { public MyCat(){ System.out.println(\"MyCat invoked\"); System.out.println(\"MyCat ClassLoader:\" + this.getClass().getClassLoader()); //父加载器(AppClassLoader)所加载的类(MyCat)不能访问子加载器(MyClassLoader)加载的类(MySimple)// System.out.println(\"from MyCat\" + MySimple.class); }} 2、重新编译、复制拷贝到之前的非classpath目录， 3、然后删除target/classLoader/namespace目录下的MySimple.class，保留MyCat.class，重新运行 2.12、替换系统类加载器2.12.1、通过java.system.class.loader属性替换ClssLoader.getSysemClassLoader()方法的javadoc文档如下： 1、编写如下代码测试 Code1234567891011121314151617package classLoader.customClassLoader;/** * 替换系统类加载器 * * @author calebzhao * 2019/8/12 22:09 */public class ReplaceSytemClassLoader { public static void main(String[] args) { System.out.println(System.getProperty(\"java.system.class.loader\")); System.out.println(MyClassObj.class.getClassLoader()); System.out.println(ClassLoader.getSystemClassLoader()); }} 输出如下：可以看到java.system.class.loader的值是null， 此时系统类加载器是AppClassLoader 2、进入到target.classes目录下执行: java -Djava.system.class.loader=classLoader.customClassLoader.MyClassLoader classLoader.customClassLoader.ReplaceSytemClassLoader 输出如下：可以看到java.system.class.loader确实已经被改变了, 而ClassLoader.getSystemClassLoader()的结果已经变成我们设置的MyClassLoader类加载器了 2.12.2、注意：要被替换为系统类加载器的自定义类加载必须定义无参数的构造方法 假如把这个构造方法注释掉会报错， 这个构造方法是由La 2.13、ContextClassLoader2.13.1、入门示例Code12345678910111213package classLoader.contextClassLoader;/** * @author calebzhao * 2019/8/13 20:55 */public class ContextClassLoaderDemo { public static void main(String[] args) { System.out.println(Thread.class.getClassLoader()); System.out.println(Thread.currentThread().getContextClassLoader()); }} 原因：Thread类是由启动类加载器加载的，所以打印null, 当前类是位于classpath下的，由AppClassLoader加载的 2.13.2、当前类加载器概念：加载当前类的类加载器 每个类都会使用自己的类加载器（即加载自身的类加载器）来去加载其所依赖的类，如果ClassX引用了ClassY,那么ClassX的类加载器就会去加载ClassY(前提是ClassY尚未被加载) 代码示例： CurrentClassLoader .java Code123456789101112131415161718package classLoader.contextClassLoader;import classLoader.customClassLoader.MyClassLoader;/** * @author calebzhao * 2019/8/13 21:03 */public class CurrentClassLoader { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException { String classBaseDir = \"C:\\\\TestTargetClassLoader\"; MyClassLoader myClassLoader = new MyClassLoader(classBaseDir); Class clazz = myClassLoader.loadClass(\"classLoader.contextClassLoader.ClassA\"); clazz.newInstance(); }} ClassA.java Code1234567891011121314package classLoader.contextClassLoader;/** * @author calebzhao * 2019/8/13 21:04 */public class ClassA { public ClassA(){ System.out.println(\"ClassA: \" + this.getClass().getClassLoader()); new ClassB(); }} ClassB.java Code123456789101112package classLoader.contextClassLoader;/** * @author calebzhao * 2019/8/13 21:04 */public class ClassB { public ClassB(){ System.out.println(\"ClassB: \" + this.getClass().getClassLoader()); }} 然后把target/classLoader/contextClassLoader下面的类复制到非classpath目录 再删除当前项目的target/classLoader/contextClassLoader下面的ClassA.class、ClassB.class 最后运行输出如下： 可以看到ClassA是由MyClassLoader加载的（这个毫无疑问，再不懂就说不过去了），而在ClassA的构造方法中实例化了ClassB, 从输出看到ClassB也是由MyClassLoader加载的，验证前面的结论：每个类都会使用自己的类加载器（即加载自身的类加载器）来去加载其所依赖的类 2.13.3、线程上下文类加载器线程上下文类加载器是从jdk1.2开始引入的，类Thread中的getContextClassLoader()与setContextClassLoader(ClassLoader cl)分别用来获取和设置上下文类加载器。如果没有通过setContextClassLoader(ClassLoader cl)进行设置的话，线程将继承父线程的上下文类加载器，java线程运行时的上下文类加载器是系统类加载器，在线程中运行的代码可以通过该类加载器来加载类与资源。 线程上下文类加载器的重要性： SPI（Service Provider Interface） 父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所指定的ClassLoader加载的类，这就改变了父ClassLoader不能使用子ClassLoader或是其他没有直接父子关系的classLoader加载的类的情况，即改变了双亲委托模型。 线程上下文类加载器就是当前线程的current ClassLoader。 双亲委托模型是自下而上的，即下层的类加载器会委托给上层的类加载器进行加载，但是对于SPI来说，有些接口是由java核心库提供的，而java核心库是由启动类加载器加载的，而这些接口的实现却来自于不同的jar包（厂商提供），java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求，而通过给当前线程设置上下文类加载器（将当前线程上下文的类加载设置为接口的类加载器），那么接口的实现提供方(厂商提供的jar包)就可以获取到当前线程的上下文类加载器，来用和接口一样的类加载器去加载接口的实现，解决接口的类加载器和实现类加载器不一致的问题。 2.1.4、线程上下文类加载器的一般使用模式Code12345678910111213141516171819202122232425262728293031323334package classLoader.contextClassLoader;import classLoader.customClassLoader.MyClassLoader;/** * context classloader的一般使用模式 * * @author calebzhao * 2019/8/13 22:04 */public class ContextClassLoaderUseDemo { public static void main(String[] args) { String classBaseDir = \"C:\\\\TestTargetClassLoader\"; MyClassLoader myClassLoader = new MyClassLoader(classBaseDir); invoke(myClassLoader); } /** * context classloader使用模式 * @param classLoader */ public static void invoke(ClassLoader classLoader){ ClassLoader originClassLoader = Thread.currentThread().getContextClassLoader(); try{ Thread.currentThread().setContextClassLoader(classLoader); // doBusiness() } finally { Thread.currentThread().setContextClassLoader(originClassLoader); } }}","categories":[{"name":"java基础","slug":"java基础","permalink":"https://calebzhao.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://calebzhao.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"https://calebzhao.github.io/tags/jvm/"}]},{"title":"Java中的Type详解","slug":"Java中的Type详解","date":"2019-12-29T08:52:40.000Z","updated":"2020-01-10T04:43:18.135Z","comments":true,"path":"2019/12/29/Java中的Type详解/","link":"","permalink":"https://calebzhao.github.io/2019/12/29/Java%E4%B8%AD%E7%9A%84Type%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"反射相关接口 下面就把Type的来龙去脉彻底弄清楚 TypeType是所有类型的父接口, 如原始类型(raw types,对应Class)、 参数化类型(parameterized types, 对应ParameterizedType)、 数组类型(array types,对应GenericArrayType)、 类型变量(type variables, 对应TypeVariable)和基本(原生)类型(primitive types, 对应Class), 子接口有ParameterizedType, TypeVariable, GenericArrayType, WildcardType, 实现类有Class Class getGenericSuperclass()：获取某个类继承的父类的类型(返回Type) getGenericInterfaces()：获取某个类实现的所有接口的类型，返回的是接口的类型数组(Type[]) java1234567891011121314151617181920212223242526272829303132package com.calebzhao.test;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.Arrays;public class SpringTypeTest { interface IParent1 { } interface IParent2 { } public class Children extends Parent implements IParent1, IParent2 { } public static void main(String[] args) { // 获取Children类继承的父类的类型 Type genericSuperclassType = Children.class.getGenericSuperclass(); // com.calebzhao.test.SpringTypeTest$Parent System.out.println(genericSuperclassType); // 获取Children类实现的接口的类型 Type[] genericInterfaces = Children.class.getGenericInterfaces(); // [com.calebzhao.test.SpringTypeTest$IParent1, com.calebzhao.test.SpringTypeTest$IParent2] System.out.println(Arrays.toString(genericInterfaces)); }} ParameterizedType参数化类型, 如下面的这些都是泛型： java123456789Map map;Set set1;Class clz;Holder holder;List list;static class Holder{} 而类似于下面这样的不是 ParameterizedType： java12Set set;List aList; ParameterizedType 的几个主要方法如下: Type getRawType(): 返回承载该泛型信息的对象, 如上面那个Map承载范型信息的对象是Map Type[] getActualTypeArguments(): 返回实际泛型类型列表, 如上面那个Map实际范型列表中有两个元素, 都是String Type getOwnerType(): 这个比较少用到，返回的是这个 ParameterizedType 所在的类的 Type （注意当前的 ParameterizedType 必须属于所在类的 member）， 比如 Map map 这个 ParameterizedType 的 getOwnerType() 为 null，而 Map.Entryentry 的 getOwnerType() 为 Map类的Type。 示例1： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.calebzhao.test;import java.lang.reflect.Field;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.Map;public class TypeTest { Map map; // Map map 这个 ParameterizedType 的 getOwnerType() 为 null， // 而 Map.Entry entry 的 getOwnerType() 为 Map 所属于的 Type。 Map.Entry entry; public static void main(String[] args) throws Exception { // ------------map--------------------- Field f = TypeTest.class.getDeclaredField(\"map\"); // java.util.Map System.out.println(f.getGenericType()); // true System.out.println(f.getGenericType() instanceof ParameterizedType); ParameterizedType pType = (ParameterizedType) f.getGenericType(); // interface java.util.Map System.out.println(pType.getRawType()); for (Type type : pType.getActualTypeArguments()) { // 打印2行，分别是 // class java.lang.String // class java.lang.Double System.out.println(type); } // null System.out.println(pType.getOwnerType()); System.out.println(\"\\n------------entry--------------------------------------------------------------\"); Field e = TypeTest.class.getDeclaredField(\"entry\"); // java.util.Map$Entry System.out.println(e.getGenericType()); // true System.out.println(e.getGenericType() instanceof ParameterizedType); ParameterizedType eType = (ParameterizedType) e.getGenericType(); // interface java.util.Map$Entry System.out.println(eType.getRawType()); for (Type type : eType.getActualTypeArguments()) { // 打印2行，分别是 // class java.lang.String // class java.lang.Long System.out.println(type); } // interface java.util.Map System.out.println(eType.getOwnerType()); }} 示例2 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.calebzhao.test;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.Arrays;public class SpringTypeTest { /** * 测试继承获取泛型 * @param */ class Parent{ } interface IParent1 { } interface IParent2 { } public class Children extends Parent implements IParent1, IParent2 { } public static void main(String[] args) { // 获取Children类继承的父类的类型 Type genericSuperclassType = Children.class.getGenericSuperclass(); // com.calebzhao.test.SpringTypeTest$Parent System.out.println(genericSuperclassType); if (genericSuperclassType instanceof ParameterizedType) { Type[] actualTypeArguments = ((ParameterizedType) genericSuperclassType) .getActualTypeArguments(); for (Type argumentType : actualTypeArguments) { System.out.println(\"父类ParameterizedType.getActualTypeArguments:\" + argumentType); } } System.out.println(\"------------------------分割线---------------------------------------\"); // 获取Children类实现的接口的类型 Type[] genericInterfacesTypes = Children.class.getGenericInterfaces(); // [com.calebzhao.test.SpringTypeTest$IParent1, com.calebzhao.test.SpringTypeTest$IParent2] System.out.println(Arrays.toString(genericInterfacesTypes)); for (Type interfaceType : genericInterfacesTypes) { if (interfaceType instanceof ParameterizedType) { Type[] actualTypeArguments = ((ParameterizedType) interfaceType) .getActualTypeArguments(); for (Type argumentType : actualTypeArguments) { System.out.println(\"父接口ParameterizedType.getActualTypeArguments:\" + argumentType); } } } }} 控制台输出： TypeVariable类型变量, 泛型信息在编译时会被转换为一个特定的类型, 而TypeVariable就是用来反映在JVM编译该泛型前的信息.它的声明是这样的: public interface TypeVariable extends Type也就是说它跟GenericDeclaration有一定的联系, 我是这么理解的:TypeVariable是指在GenericDeclaration中声明的、这些东西中的那个变量T、C; 它有如下方法: Type[] getBounds(): 获取类型变量的上边界, 若未明确声明上边界则默认为Object D getGenericDeclaration(): 获取声明该类型变量实体 String getName(): 获取在源码中定义时的名字 注意: 类型变量在定义的时候只能使用extends进行(多)边界限定, 不能用super; 为什么边界是一个数组? 因为类型变量可以通过&进行多个上边界限定，因此上边界有多个java1234567891011121314151617181920212223242526272829public class TestType { K key; V value; public static void main(String[] args) throws Exception { // 获取字段的类型 Field fk = TestType.class.getDeclaredField(\"key\"); Field fv = TestType.class.getDeclaredField(\"value\"); Assert.that(fk.getGenericType() instanceof TypeVariable, \"必须为TypeVariable类型\"); Assert.that(fv.getGenericType() instanceof TypeVariable, \"必须为TypeVariable类型\"); TypeVariable keyType = (TypeVariable)fk.getGenericType(); TypeVariable valueType = (TypeVariable)fv.getGenericType(); // getName 方法 System.out.println(keyType.getName()); // K System.out.println(valueType.getName()); // V // getGenericDeclaration 方法 System.out.println(keyType.getGenericDeclaration()); // class com.test.TestType System.out.println(valueType.getGenericDeclaration()); // class com.test.TestType // getBounds 方法 System.out.println(\"K 的上界:\"); // 有两个 for (Type type : keyType.getBounds()) { // interface java.lang.Comparable System.out.println(type); // interface java.io.Serializable } System.out.println(\"V 的上界:\"); // 没明确声明上界的, 默认上界是 Object for (Type type : valueType.getBounds()) { // class java.lang.Object System.out.println(type); } }} GenericArrayType 泛型数组,组成数组的元素中有范型则实现了该接口; 它的组成元素是ParameterizedType或TypeVariable类型,它只有一个方法: Type getGenericComponentType(): 返回数组的组成对象, 即被JVM编译后实际的对象 java123456789101112131415public class TestType { public static void main(String[] args) throws Exception { Method method = Test.class.getDeclaredMethods()[0]; // public void com.test.Test.show(java.util.List[],java.lang.Object[],java.util.List,java.lang.String[],int[]) System.out.println(method); Type[] types = method.getGenericParameterTypes(); // 这是 Method 中的方法 for (Type type : types) { System.out.println(type instanceof GenericArrayType); } }}class Test { public void show(List[] pTypeArray, T[] vTypeArray, List list, String[] strings, int[] ints) { }} 第一个参数List[]的组成元素List是ParameterizedType类型, 打印结果为true 第二个参数T[]的组成元素T是TypeVariable类型, 打印结果为true 第三个参数List不是数组, 打印结果为false 第四个参数String[]的组成元素String是普通对象, 没有范型, 打印结果为false 第五个参数int[] pTypeArray的组成元素int是原生类型, 也没有范型, 打印结果为false WildcardType通配符泛型, 比如? extends Number 和 ? super Integer 它有如下方法: Type[] getUpperBounds(): 获取范型变量的上界 Type[] getLowerBounds(): 获取范型变量的下界 注意: 现阶段通配符只接受一个上边界或下边界, 返回数组是为了以后的扩展, 实际上现在返回的数组的大小是1 java1234567891011121314151617181920212223public class TestType { private List a; // // a没有下界, 取下界会抛出ArrayIndexOutOfBoundsException private Listsuper String> b; public static void main(String[] args) throws Exception { Field fieldA = TestType.class.getDeclaredField(\"a\"); Field fieldB = TestType.class.getDeclaredField(\"b\"); // 先拿到范型类型 Assert.that(fieldA.getGenericType() instanceof ParameterizedType, \"\"); Assert.that(fieldB.getGenericType() instanceof ParameterizedType, \"\"); ParameterizedType pTypeA = (ParameterizedType) fieldA.getGenericType(); ParameterizedType pTypeB = (ParameterizedType) fieldB.getGenericType(); // 再从范型里拿到通配符类型 Assert.that(pTypeA.getActualTypeArguments()[0] instanceof WildcardType, \"\"); Assert.that(pTypeB.getActualTypeArguments()[0] instanceof WildcardType, \"\"); WildcardType wTypeA = (WildcardType) pTypeA.getActualTypeArguments()[0]; WildcardType wTypeB = (WildcardType) pTypeB.getActualTypeArguments()[0]; // 方法测试 System.out.println(wTypeA.getUpperBounds()[0]); // class java.lang.Number System.out.println(wTypeB.getLowerBounds()[0]); // class java.lang.String // 看看通配符类型到底是什么, 打印结果为: ? extends java.lang.Number System.out.println(wTypeA); }} 再写几个边界的例子: List, 上界为class java.lang.Number, 属于Class类型 List>, 上界为java.util.List, 属于ParameterizedType类型 List>, 上界为java.util.List, 属于ParameterizedType类型 List, 上界为T, 属于TypeVariable类型 List, 上界为T[], 属于GenericArrayType类型它们最终统一成Type作为数组的元素类型 原子类型java1234567891011121314public class TypeTest { int a = 3; Integer b = 3; public static void main(String[] args) throws Exception { Field fielda = TypeTest.class.getDeclaredField(\"a\"); System.out.println(fielda.getType().isPrimitive()); // true Field fieldb = TypeTest.class.getDeclaredField(\"b\"); System.out.println(fieldb.getType().isPrimitive()); // false }} Type及其子接口的来历 泛型出现之前的类型没有泛型的时候，只有原始类型。此时，所有的原始类型都通过字节码文件类Class类进行抽象。Class类的一个具体对象就代表一个指定的原始类型。 泛型出现之后的类型泛型出现之后，扩充了数据类型。从只有原始类型扩充了参数化类型、类型变量类型、限定符类型 、泛型数组类型。 与泛型有关的类型不能和原始类型统一到Class的原因产生泛型擦除的原因原始类型和新产生的类型都应该统一成各自的字节码文件类型对象。但是由于泛型不是最初Java中的成分。如果真的加入了泛型，涉及到JVM指令集的修改，这是非常致命的。 Java中如何引入泛型为了使用泛型又不真正引入泛型，Java采用泛型擦除机制来引入泛型。Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦。但是，一旦编译完成，所有的和泛型有关的类型全部擦除。 Class不能表达与泛型有关的类型因此，与泛型有关的参数化类型、类型变量类型、限定符类型 、泛型数组类型这些类型编译后全部被打回原形，在字节码文件中全部都是泛型被擦除后的原始类型，并不存在和自身类型对应的字节码文件。所以和泛型相关的新扩充进来的类型不能被统一到Class类中。 与泛型有关的类型在Java中的表示为了通过反射操作这些类型以迎合实际开发的需要，Java就新增了ParameterizedType, TypeVariable, GenericArrayType, WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型。 引入Type的原因为了程序的扩展性，最终引入了Type接口作为Class和ParameterizedType, TypeVariable,GenericArrayType, WildcardType这几种类型的总的父接口。这样可以用Type类型的参数来接受以上五种子类的实参或者返回值类型就是Type类型的参数。统一了与泛型有关的类型和原始类型Class Type接口中没有方法的原因从上面看到，Type的出现仅仅起到了通过多态来达到程序扩展性提高的作用，没有其他的作用。因此Type接口的源码中没有任何方法。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://calebzhao.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://calebzhao.github.io/tags/java/"},{"name":"Type","slug":"Type","permalink":"https://calebzhao.github.io/tags/Type/"}]},{"title":"spring.factories自动化配置归类","slug":"spring.factories自动化配置归类","date":"2019-12-29T08:51:55.000Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2019/12/29/spring.factories自动化配置归类/","link":"","permalink":"https://calebzhao.github.io/2019/12/29/spring.factories%E8%87%AA%E5%8A%A8%E5%8C%96%E9%85%8D%E7%BD%AE%E5%BD%92%E7%B1%BB/","excerpt":"","text":"前言为什么要有这篇文章？ 当我们分析在spring boot源码时，经常会看到SpringFactoriesLoader.loadFactoryNames(xxx.classs)返回了很多自动化配置类的名称，比如EnableAutoConfiguration=xxxx， 虽然可以看到EnableAutoConfiguration具体加载的配置有哪些，但是它的值到底是从哪个项目来的，自动化配置了哪个项目可能还是很模糊，找对应的配置可能还需要花费一定的时间。 自动化配置的地方BootstrapConfiguration spring-cloud-context-2.2.0.RELEASE.jar!\\META-INF\\spring.factories 共4个 properties1234567# Bootstrap componentsorg.springframework.cloud.bootstrap.BootstrapConfiguration=\\org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration,\\org.springframework.cloud.bootstrap.encrypt.EncryptionBootstrapConfiguration,\\org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration spring-cloud-netflix-eureka-client-2.2.0.RELEASE.jar!\\META-INF\\spring.factories共1个 properties12org.springframework.cloud.bootstrap.BootstrapConfiguration=\\org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceBootstrapConfiguration ApplicationListener spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories 共9个 Code1234567891011## Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.ClearCachesApplicationListener,\\org.springframework.boot.builder.ParentContextCloserApplicationListener,\\org.springframework.boot.context.FileEncodingApplicationListener,\\org.springframework.boot.context.config.AnsiOutputApplicationListener,\\org.springframework.boot.context.config.ConfigFileApplicationListener,\\org.springframework.boot.context.config.DelegatingApplicationListener,\\org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\org.springframework.boot.context.logging.LoggingApplicationListener,\\org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener spring-cloud-context-2.2.0.RELEASE.jar!\\META-INF\\spring.factories 共3个 Code12345## Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.cloud.bootstrap.BootstrapApplicationListener,\\org.springframework.cloud.bootstrap.LoggingSystemShutdownListener,\\org.springframework.cloud.context.restart.RestartListener spring-boot-autoconfigure-2.2.1.RELEASE.jar!\\META-INF\\spring.factories 共1个 Code123# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.autoconfigure.BackgroundPreinitializer ApplicationListener自动化配置加载原理我们在编写一个spring boot应用时通常启动的方式是通过SpringApplication.run(xxx.class, args)来启动的， java1234567891011121314151617181920212223242526public class SpringApplication { public SpringApplication(Class... primarySources) { this(null, primarySources); } public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) { this.resourceLoader = resourceLoader; Assert.notNull(primarySources, \"PrimarySources must not be null\"); this.primarySources = new LinkedHashSet(Arrays.asList(primarySources)); this.webApplicationType = WebApplicationType.deduceFromClasspath(); // 关键代码：加载spring.factories中key为ApplicationContextInitializer的自动化配置类的名称 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // 关键代码：加载spring.factories中key为ApplicationListener的自动化配置类的名称 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass(); } public static ConfigurableApplicationContext run(Class primarySource, String... args) { return run(new Class[] { primarySource }, args); } public static ConfigurableApplicationContext run(Class[] primarySources, String[] args) { return new SpringApplication(primarySources).run(args); }} ApplicationContextInitializer spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories Code1234567# Application Context Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\org.springframework.boot.context.ContextIdApplicationContextInitializer,\\org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\\org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer spring-boot-autoconfigure-2.2.1.RELEASE.jar!\\META-INF\\spring.factories 共2个 Code1234# Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener 加载ApplicationContextInitializer的源码见上一节ApplicationListener自动化配置加载原理 EnableAutoConfiguration spring-boot-autoconfigure-2.2.1.RELEASE.jar!\\META-INF\\spring.factories 共2个 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveRestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\...省略org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\ spring-cloud-commons-2.2.0.RELEASE.jar!\\META-INF\\spring.factories Code1234567891011121314151617181920# AutoConfigurationorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.cloud.client.CommonsClientAutoConfiguration,\\org.springframework.cloud.client.ReactiveCommonsClientAutoConfiguration,\\org.springframework.cloud.client.discovery.composite.CompositeDiscoveryClientAutoConfiguration,\\org.springframework.cloud.client.discovery.composite.reactive.ReactiveCompositeDiscoveryClientAutoConfiguration,\\org.springframework.cloud.client.discovery.noop.NoopDiscoveryClientAutoConfiguration,\\org.springframework.cloud.client.discovery.simple.SimpleDiscoveryClientAutoConfiguration,\\org.springframework.cloud.client.discovery.simple.reactive.SimpleReactiveDiscoveryClientAutoConfiguration,\\org.springframework.cloud.client.hypermedia.CloudHypermediaAutoConfiguration,\\org.springframework.cloud.client.loadbalancer.AsyncLoadBalancerAutoConfiguration,\\org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration,\\org.springframework.cloud.client.loadbalancer.reactive.LoadBalancerBeanPostProcessorAutoConfiguration,\\org.springframework.cloud.client.loadbalancer.reactive.ReactorLoadBalancerClientAutoConfiguration,\\org.springframework.cloud.client.loadbalancer.reactive.ReactiveLoadBalancerAutoConfiguration,\\org.springframework.cloud.client.serviceregistry.ServiceRegistryAutoConfiguration,\\org.springframework.cloud.commons.httpclient.HttpClientConfiguration,\\org.springframework.cloud.commons.util.UtilAutoConfiguration,\\org.springframework.cloud.configuration.CompatibilityVerifierAutoConfiguration,\\org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationAutoConfiguration spring-cloud-context-2.2.0.RELEASE.jar!\\META-INF\\spring.factories Code1234567# AutoConfigurationorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\\org.springframework.cloud.autoconfigure.LifecycleMvcEndpointAutoConfiguration,\\org.springframework.cloud.autoconfigure.RefreshAutoConfiguration,\\org.springframework.cloud.autoconfigure.RefreshEndpointAutoConfiguration,\\org.springframework.cloud.autoconfigure.WritableEnvironmentEndpointAutoConfiguration spring-cloud-loadbalancer-2.2.0.RELEASE.jar!\\META-INF\\spring.factories Code12345# AutoConfigurationorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.cloud.loadbalancer.config.LoadBalancerAutoConfiguration,\\org.springframework.cloud.loadbalancer.config.BlockingLoadBalancerClientAutoConfiguration,\\org.springframework.cloud.loadbalancer.config.LoadBalancerCacheAutoConfiguration spring-cloud-openfeign-core-2.2.0.RELEASE.jar!\\META-INF\\spring.factories Code1234567org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.cloud.openfeign.ribbon.FeignRibbonClientAutoConfiguration,\\org.springframework.cloud.openfeign.hateoas.FeignHalAutoConfiguration,\\org.springframework.cloud.openfeign.FeignAutoConfiguration,\\org.springframework.cloud.openfeign.encoding.FeignAcceptGzipEncodingAutoConfiguration,\\org.springframework.cloud.openfeign.encoding.FeignContentGzipEncodingAutoConfiguration,\\org.springframework.cloud.openfeign.loadbalancer.FeignLoadBalancerAutoConfiguration spring-cloud-netflix-ribbon-2.2.0.RELEASE.jar!\\META-INF\\spring.factories Code12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.cloud.netflix.ribbon.RibbonAutoConfiguration spring-cloud-netflix-hystrix-2.2.0.RELEASE.jar!\\META-INF\\spring.factories Code1234org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.cloud.netflix.hystrix.HystrixAutoConfiguration,\\org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerAutoConfiguration,\\org.springframework.cloud.netflix.hystrix.security.HystrixSecurityAutoConfiguration EnableAutoConfiguration自动化配置加载原理在@SpringBootApplication注解上可以看到有@EnableAutoConfiguration注解， SpringBootApplication类的源码如下： java1234567891011@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication { ...省略代码} Code1234567891011```java@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration {} 从上面可以看到它引入了AutoConfigurationImportSelector这个类，该类的具体实现见springboot2-2自动注入文件spring-factories如何加载详解 EnvironmentPostProcessor spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories Code123456# Environment Post Processorsorg.springframework.boot.env.EnvironmentPostProcessor=\\org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\\org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\\org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\\org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor spring-cloud-commons-2.2.0.RELEASE.jar!\\META-INF\\spring.factories Code123# Environment Post Processorsorg.springframework.boot.env.EnvironmentPostProcessor=\\org.springframework.cloud.client.HostInfoEnvironmentPostProcessor PropertySourceLoader spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories Code1234# PropertySource Loadersorg.springframework.boot.env.PropertySourceLoader=\\org.springframework.boot.env.PropertiesPropertySourceLoader,\\org.springframework.boot.env.YamlPropertySourceLoader SpringApplicationRunListener spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories Code1234# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\org.springframework.boot.context.event.EventPublishingRunListener EnableCircuitBreaker spring-cloud-netflix-hystrix-2.2.0.RELEASE.jar!\\META-INF\\spring.factories Code12org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker=\\org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerConfiguration BeanInfoFactory spring-beans-5.2.1.RELEASE.jar!\\META-INF\\spring.factories Code1org.springframework.beans.BeanInfoFactory=org.springframework.beans.ExtendedBeanInfoFactory AutoConfigurationImportListener spring-boot-autoconfigure-2.2.1.RELEASE.jar!\\META-INF\\spring.factories Code123# Auto Configuration Import Listenersorg.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener AutoConfigurationImportFilter spring-boot-autoconfigure-2.2.1.RELEASE.jar!\\META-INF\\spring.factories Code12345# Auto Configuration Import Filtersorg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnBeanCondition,\\org.springframework.boot.autoconfigure.condition.OnClassCondition,\\org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition SpringBootExceptionReporter spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories Code123# Error Reportersorg.springframework.boot.SpringBootExceptionReporter=\\org.springframework.boot.diagnostics.FailureAnalyzers TemplateAvailabilityProvider spring-boot-autoconfigure-2.2.1.RELEASE.jar!\\META-INF\\spring.factories Code1234567# Template availability providersorg.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider FailureAnalysisReporter spring-boot-2.2.1.RELEASE.jar!\\META-INF\\spring.factories Code123# FailureAnalysisReportersorg.springframework.boot.diagnostics.FailureAnalysisReporter=\\org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"https://calebzhao.github.io/categories/spring-boot/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/tags/spring-cloud/"},{"name":"spring boot","slug":"spring-boot","permalink":"https://calebzhao.github.io/tags/spring-boot/"},{"name":"spring","slug":"spring","permalink":"https://calebzhao.github.io/tags/spring/"}]},{"title":"Class对象的getXXXClass和getXXXName","slug":"Class对象的getXXXClass和getXXXName","date":"2019-12-29T08:51:55.000Z","updated":"2020-01-10T04:43:18.135Z","comments":true,"path":"2019/12/29/Class对象的getXXXClass和getXXXName/","link":"","permalink":"https://calebzhao.github.io/2019/12/29/Class%E5%AF%B9%E8%B1%A1%E7%9A%84getXXXClass%E5%92%8CgetXXXName/","excerpt":"","text":"getXXXClass方法获取class对象在讲解具体的方法之前，我们先介绍一下java类（接口）的划分方法。java的class对象分为5种，这一点在getEnclosingClass方法的注释中有写明，分别是： a. Top类 b. Nested类：嵌套类，即静态成员类 c. Inner类：内部类，即普通成员类 d. Local类：局部类，在方法中定义的类 e. Anonymous：匿名类 Class对象有3个和name相关的方法，分别是getClass, getDeclaringClass和getEnclosingClass，下面我们仔细看一下这3个方法有什么区别。 getClass方法Code1234567891011121314151617181920212223242526272829303132```class.getClass()```返回的自然是```java.lang.Class```。## getDeclaringClass方法从注释可以看出，```class.getDeclaringClass()```方法返回了声明class对象的类，只有当class对象的类A是另一个类B的成员类，该方法才能返回值，返回该成员类所在的类（即类B），否则返回null值。如果class对象是local class，是在类B的方法里定义的，同样返回null值，而不会返回类B。```java/** * If the class or interface represented by this {@code Class} object * is a member of another class, returns the {@code Class} object * representing the class in which it was declared. This method returns * null if this class or interface is not a member of any other class. If * this {@code Class} object represents an array class, a primitive * type, or void,then this method returns null. * @return the declaring class for this class * @throws SecurityException * If a security manager, s, is present and the caller's * class loader is not the same as or an ancestor of the class * loader for the declaring class and invocation of {@link * SecurityManager#checkPackageAccess s.checkPackageAccess()} * denies access to the package of the declaring class * @since JDK1.1 */@CallerSensitivepublic Class getDeclaringClass() throws SecurityException { final Class candidate = getDeclaringClass0(); if (candidate != null) candidate.checkPackageAccess( ClassLoader.getClassLoader(Reflection.getCallerClass()), true); return candidate;} getEnclosingClass方法返回该class对象的立即封闭类，即该类实在哪个类里定义的，与getDeclaringClass不同的是getEnclosingClass并不要求该class一定是成员类。 java12345678910111213141516171819202122@CallerSensitivepublic Class getEnclosingClass() throws SecurityException { EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo(); Class enclosingCandidate; if (enclosingInfo == null) { // This is a top level or a nested class or an inner class (a, b, or c) enclosingCandidate = getDeclaringClass(); } else { Class enclosingClass = enclosingInfo.getEnclosingClass(); // This is a local class or an anonymous class (d or e) if (enclosingClass == this || enclosingClass == null) throw new InternalError(\"Malformed enclosing method information\"); else enclosingCandidate = enclosingClass; } if (enclosingCandidate != null) enclosingCandidate.checkPackageAccess( ClassLoader.getClassLoader(Reflection.getCallerClass()), true); return enclosingCandidate;} 总结一下： 示例代码： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.calebzhao.openfeign;import org.junit.Test;import java.util.Arrays;public class ClassTest { private Object obj; static class A { } class B { } interface C{ void run(); } public void method1(){ Class cClass = new C(){ @Override public void run() { System.out.println(\"run\"); } }.getClass(); System.out.println(cClass.getClass()); System.out.println(cClass.getEnclosingClass()); System.out.println(cClass.getDeclaringClass()); System.out.println(Arrays.toString(cClass.getDeclaredClasses())); } public void method2(){ class D{ } Class d = D.class; System.out.println(d.getClass()); System.out.println(d.getEnclosingClass()); System.out.println(d.getDeclaringClass()); System.out.println(Arrays.toString(d.getDeclaredClasses())); } @Test public void testClassTest() { System.out.println(\"*************ClassTest*******************\\n\"); Class testClass = ClassTest.class; System.out.println(testClass.getClass()); System.out.println(testClass.getEnclosingClass()); System.out.println(testClass.getDeclaringClass()); System.out.println(Arrays.toString(testClass.getDeclaredClasses())); System.out.println(\"\\n*************A*******************\\n\"); Class aClass = A.class; System.out.println(aClass.getClass()); System.out.println(aClass.getEnclosingClass()); System.out.println(aClass.getDeclaringClass()); System.out.println(Arrays.toString(aClass.getDeclaredClasses())); System.out.println(\"\\n*************B*******************\\n\"); Class bClass = B.class; System.out.println(bClass.getClass()); System.out.println(bClass.getEnclosingClass()); System.out.println(bClass.getDeclaringClass()); System.out.println(Arrays.toString(bClass.getDeclaredClasses())); System.out.println(\"\\n*************C*******************\\n\"); method1(); System.out.println(\"\\n*************D***********\\n\"); method2(); }} 输出结果如下: Code1234567891011121314151617181920212223242526272829303132333435363738*************ClassTest*******************class java.lang.Classnullnull[interface com.calebzhao.openfeign.ClassTest$C, class com.calebzhao.openfeign.ClassTest$B, class com.calebzhao.openfeign.ClassTest$A]*************A*******************class java.lang.Classclass com.calebzhao.openfeign.ClassTestclass com.calebzhao.openfeign.ClassTest[]*************B*******************class java.lang.Classclass com.calebzhao.openfeign.ClassTestclass com.calebzhao.openfeign.ClassTest[]*************C*******************class java.lang.Classclass com.calebzhao.openfeign.ClassTestnull[]*************D***********class java.lang.Classclass com.calebzhao.openfeign.ClassTestnull[]进程已结束，退出代码 0 getXXXName方法返回名称在讲具体的区别之前，先明确对象的描述符概念。在class文件里，字段表集合里存储了类的属性和方法，并且通过描述符来区分不同的对象类型。对于基本数据结构，描述符用一个大写字母表示；对于对象，描述符用L+类的全限定名表示，并以分号结束。描述符在class类中getName方法的注释中也有描述。 Class对象有3个和name相关的方法，分别是getSimpleName, getName和getCanonicalName，下面我们仔细看一下这3个方法有什么区别。 getName在class类里，getName方法通过调用native方法getName0获得，返回class对象在虚拟机里面的表示。 对于top class，getName为:类的全限定名，如：test.Test。 对于nested class和inner class，getName为：getEnclosingClass的getName + $ + 类名，如test.Test$Inner。 对于anonymous class，getName为：getEnclosingClass的getName + $ + 虚拟机分配的类名（虚拟机对于每一个类中的匿名类会按顺序分配给1，2之类的类名，如test.Test$1。 对于local class，getName为：getEnclosingClass的getName + $ + 虚拟机分配的前缀+类名（由于local class是属于方法的，一个类中的不同方法下的local class类名是有可能相同的，所以虚拟机会在类名前面自动加上按方法加上1，2之类的排序），如test.Test$2LocalClass。 对于基本数据结构的class对象，getName为：基本数据结构的名称，如boolean。 对于数组的class对象，getName为：[ + 元素类型的描述符，如[Ljava.lang.String;(带分号)，[Z。如果是多维数组，则带有多个[。 getSimpleName方法从代码可以看出 对于数组的class对象，返回元素类型的getSimpleName+[]。 对于非top class的对象，获取getEnclosingClass，从getName中截去getEnclosingClass的getName，截去$符号，然后截去字符串前面的所有数字。 对于top class的对象，返回类名。 java123456789101112131415161718public String getSimpleName() { if (isArray()) return getComponentType().getSimpleName()+\"[]\"; String simpleName = getSimpleBinaryName(); if (simpleName == null) { // top level class simpleName = getName(); return simpleName.substring(simpleName.lastIndexOf(\".\")+1); // strip the package name } int length = simpleName.length(); if (length < 1 || simpleName.charAt(0) != '$') throw new InternalError(\"Malformed class name\"); int index = 1; while (index < length && isAsciiDigit(simpleName.charAt(index))) index++; // Eventually, this is the empty string iff this is an anonymous class return simpleName.substring(index);} java1234567891011private String getSimpleBinaryName() { Class enclosingClass = getEnclosingClass(); if (enclosingClass == null) // top level class return null; // Otherwise, strip the enclosing class' name try { return getName().substring(enclosingClass.getName().length()); } catch (IndexOutOfBoundsException ex) { throw new InternalError(\"Malformed class name\", ex); }} getCanonicalName方法 对于数组的class对象，检查元素类型的getCanonicalName，如果是null，则返回null；否则元素类型的getCanonicalName + []。 对于local class和anonymous class，返回null。 对于top class，返回getName。 获取getEnclosingClass的getCanonicalName作为canonicalName，为null则返回null；否则getCanonicalName + . + getSimpleName。 java1234567891011121314151617181920public String getCanonicalName() { if (isArray()) { String canonicalName = getComponentType().getCanonicalName(); if (canonicalName != null) return canonicalName + \"[]\"; else return null; } if (isLocalOrAnonymousClass()) return null; Class enclosingClass = getEnclosingClass(); if (enclosingClass == null) { // top level class return getName(); } else { String enclosingName = enclosingClass.getCanonicalName(); if (enclosingName == null) return null; return enclosingName + \".\" + getSimpleName(); }} 总结一下： spring包里的classMetadata在spring的org.springframework.core.type包下的ClassMetadata接口里有一些与我们上述内容相关的方法，这些方法在spring的源码中经常会遇到，我们通过其实现类StandardClassMetadata一并解释一下： isIndependent 从方法名称上可以看出，判断对应的类是否是独立的，不需要依赖其它类。如果是top class或nested class，视为Independent，返回true；否则返回false。 java123456@Overridepublic boolean isIndependent() { return (!hasEnclosingClass() || (this.introspectedClass.getDeclaringClass() != null && Modifier.isStatic(this.introspectedClass.getModifiers())));} hasEnclosingClass 从方法名称上可以看出，判断getEnclosingClass是否存在。如果是top class返回false，否则返回true。 java1234@Overridepublic boolean hasEnclosingClass() { return (this.introspectedClass.getEnclosingClass() != null);} getEnclosingClassName 从方法名称上可以看出，获取getEnclosingClass的getName。如果是top class返回null，否则返回getEnclosingClass的getName。 java123456@Override@Nullablepublic String getEnclosingClassName() { Class enclosingClass = this.introspectedClass.getEnclosingClass(); return (enclosingClass != null ? enclosingClass.getName() : null);} getClassName 从方法名称上可以看出对于class对象的getName。 java1234@Overridepublic String getClassName() { return this.introspectedClass.getName();}","categories":[{"name":"java基础","slug":"java基础","permalink":"https://calebzhao.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://calebzhao.github.io/tags/java/"}]},{"title":"1、springboot2.2自动注入文件spring.factories如何加载详解","slug":"1、springboot2-2自动注入文件spring-factories如何加载详解","date":"2019-12-29T08:50:34.000Z","updated":"2020-01-10T04:43:18.135Z","comments":true,"path":"2019/12/29/1、springboot2-2自动注入文件spring-factories如何加载详解/","link":"","permalink":"https://calebzhao.github.io/2019/12/29/1%E3%80%81springboot2-2%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E6%96%87%E4%BB%B6spring-factories%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"1.首先看下启动类：java123456@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class); }} 启动类使用@SpringBootApplication注解，再看下这个注解内容: java12345678910111213141516171819202122232425@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication { @AliasFor(annotation = EnableAutoConfiguration.class) Class[] exclude() default {}; @AliasFor(annotation = EnableAutoConfiguration.class) String[] excludeName() default {}; @AliasFor(annotation = ComponentScan.class, attribute = \"basePackages\") String[] scanBasePackages() default {}; @AliasFor(annotation = ComponentScan.class, attribute = \"basePackageClasses\") Class[] scanBasePackageClasses() default {}; @AliasFor(annotation = Configuration.class) boolean proxyBeanMethods() default true;} 再进入@EnableAutoConfiguration中查看 java123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration { ...省略} 发现加载了一个AutoConfigurationImportSelector.class类 温馨提示：所有实现ImportSelector的类，都会在启动时被org.springframework.context.annotation.ConfigurationClassParser中的processImports```进行实例化，并执行selectImports`方法。 2、AutoConfigurationImportSelector中的selectImportsjava12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered { private static final AutoConfigurationEntry EMPTY_ENTRY = new AutoConfigurationEntry(); private static final String[] NO_IMPORTS = {}; private static final String PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE = \"spring.autoconfigure.exclude\"; private ConfigurableListableBeanFactory beanFactory; private Environment environment; private ClassLoader beanClassLoader; private ResourceLoader resourceLoader; @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); /** 1、入口关键代码**/ AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } AnnotationAttributes attributes = getAttributes(annotationMetadata); /** 2、获取所有jar包中的spring.factories文件中的key为EnableAutoConfiguration的值*/ List configurations = getCandidateConfigurations(annotationMetadata, attributes); /** 移除重复的配置值 **/ configurations = removeDuplicates(configurations); /** 获取注解上配置的要排序的class的全限定name*/ Set exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); /**移除需要排除的自动配置类*/ configurations.removeAll(exclusions); /**过滤自动配置类*/ configurations = filter(configurations, autoConfigurationMetadata); /**触发事件，通知相关监听该事件的listener*/ fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } protected boolean isEnabled(AnnotationMetadata metadata) { if (getClass() == AutoConfigurationImportSelector.class) { return getEnvironment().getProperty(EnableAutoConfiguration.ENABLED_OVERRIDE_PROPERTY, Boolean.class, true); } return true; } protected Class getAnnotationClass() { return EnableAutoConfiguration.class; } protected List getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) { /** 3、这里的SpringFactoriesLoader.loadFactoryNames是重点*/ List configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations; } protected Class getSpringFactoriesLoaderFactoryClass() { /**要自动化配置的key*/ return EnableAutoConfiguration.class; } 从上述代码可以看到获取自动化配置相关的类最终是调用SpringFactoriesLoader.loadFactoryNames(Class cls, ClassLoader classLoader);实现的 3、 SpringFactoriesLoader如何加载java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public final class SpringFactoriesLoader { /**spring.factories的位置*/ public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\"; private static final Log logger = LogFactory.getLog(SpringFactoriesLoader.class); /** * 缓存扫描后的结果， 注意这个cache是static修饰的，说明是多个实例共享的 * 其中MultiValueMap的key就是spring.factories中的key（比如org.springframework.boot.autoconfigure.EnableAutoConfiguration）, * 其值就是key对应的value以逗号分隔后得到的List集合（这里用到了MultiValueMap，他是guava的一种多值map， 类似Map） */ private static final Map cache = new ConcurrentReferenceHashMap(); private SpringFactoriesLoader() { } /** * AutoConfigurationImportSelector里最终调用的就是这个方法， * 这里的factoryType是EnableAutoConfiguration.class， * classLoader是AutoConfigurationImportSelector里的beanClassLoader */ public static List loadFactoryNames(Class factoryType, @Nullable ClassLoader classLoader) { String factoryTypeName = factoryType.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList()); } /** * 加载 spring.factories文件的核心实现 */ private static Map loadSpringFactories(@Nullable ClassLoader classLoader) { // 先从缓存获取，如果获取到了说明之前已经被加载过 MultiValueMap result = cache.get(classLoader); if (result != null) { return result; } try { // 找到所有jar中的spring.factories文件的地址 Enumeration urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap(); // 循环处理每一个spring.factories文件 while (urls.hasMoreElements()) { URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); // 加载spring.factories文件中的内容到Properties对象中 Properties properties = PropertiesLoaderUtils.loadProperties(resource); // 遍历spring.factories内容中的所有的键值对 for (Map.Entry entry : properties.entrySet()) { // 获得spring.factories内容中的key（比如org.springframework.boot.autoconfigure.EnableAutoConfiguratio） String factoryTypeName = ((String) entry.getKey()).trim(); // 获取value， 然后按英文逗号(,)分割得到value数组并遍历 for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) { // 存储结果到上面的多值Map中(MultiValueMap) result.add(factoryTypeName, factoryImplementationName.trim()); } } } cache.put(classLoader, result); return result; } catch (IOException ex) { throw new IllegalArgumentException(\"Unable to load factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex); } }} 4、spring.factories加载过程总结 我们自己会使用@SpringBootApplication、@EnableDiscoryClient等注解 这些注解一般会再引入`@Import(AutoConfigurationImportSelector.class)```这样的类 AutoConfigurationImportSelector这样的Selector会执行其中的String[] selectImports(AnnotationMetadata annotationMetadata)方法来加载spring.factories中的自动化配置，方法内部会调用SpringFactoriesLoader.loadFactoryNames(Class factoryType, this.beanClassLoader)来真正加载spring.factories SpringFactoriesLoader.loadFactoryNames(Class factoryType, this.beanClassLoader)扫描所有jar中的META-INF/spring.factories文件，将内容存储到一个MultiValueMap中缓存起来，下次加载时直接从缓存中找","categories":[{"name":"spring boot","slug":"spring-boot","permalink":"https://calebzhao.github.io/categories/spring-boot/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"https://calebzhao.github.io/tags/spring-boot/"}]},{"title":"2、spring cloud ribbon源码分析","slug":"2、spring-cloud-ribbon源码分析","date":"2019-12-29T08:48:27.000Z","updated":"2020-01-10T04:43:18.135Z","comments":true,"path":"2019/12/29/2、spring-cloud-ribbon源码分析/","link":"","permalink":"https://calebzhao.github.io/2019/12/29/2%E3%80%81spring-cloud-ribbon%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"、RestTemplate调用原理 1、调用restTemlate.get() 2、进入RestTemplate的拦截器 java12345678910111213141516public class InterceptingClientHttpRequest{ private class InterceptingRequestExecution implements ClientHttpRequestExecution @Override public ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException { if (this.iterator.hasNext()) { ClientHttpRequestInterceptor nextInterceptor = this.iterator.next(); return nextInterceptor.intercept(request, body, this); } else { ...省略 } }} 3、 进入LoadBalancerInterceptor 拦截器，其中LoadBalancerClient的实现一般为RibbonLoadBalancerClient java12345678910111213public class LoadBalancerInterceptor implements ClientHttpRequestInterceptor { public ClientHttpResponse intercept(final HttpRequest request, final byte[] body, final ClientHttpRequestExecution execution) throws IOException { final URI originalUri = request.getURI(); String serviceName = originalUri.getHost(); Assert.state(serviceName != null,\"Request URI does not contain a valid hostname: \" + originalUri); return this.loadBalancer.execute(serviceName, this.requestFactory.createRequest(request, body, execution)); } }} 4、进入ribbon的客户端负载均衡实现，RibbonLoadBalancerClient.execute()方法 java123456789101112131415161718public class RibbonLoadBalancerClient implements LoadBalancerClient { public T execute(String serviceId, LoadBalancerRequest request, Object hint) throws IOException { // 获取所有实例列表 ILoadBalancer loadBalancer = this.getLoadBalancer(serviceId); // 按照负载均衡算法选择1个实例 Server server = this.getServer(loadBalancer, hint); if (server == null) { throw new IllegalStateException(\"No instances available for \" + serviceId); } else { RibbonLoadBalancerClient.RibbonServer ribbonServer = new RibbonLoadBalancerClient.RibbonServer(serviceId, server, this.isSecure(server, serviceId), this.serverIntrospector(serviceId).getMetadata(server)); # 向选择的实例真正发送请求 return this.execute(serviceId, (ServiceInstance)ribbonServer, (LoadBalancerRequest)request); } }}","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/tags/spring-cloud/"},{"name":"ribbon","slug":"ribbon","permalink":"https://calebzhao.github.io/tags/ribbon/"}]},{"title":"spring-cloud-commons 源码分析","slug":"spring-cloud-commons-源码分析","date":"2019-12-29T08:47:48.000Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2019/12/29/spring-cloud-commons-源码分析/","link":"","permalink":"https://calebzhao.github.io/2019/12/29/spring-cloud-commons-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"SpringCloud组件内部一定会有spring-cloud-commons 和 spring-cloud-context 这两个依赖中的一个。比如 spring-cloud-netflix-eureka-server, spring-cloud-netflix-eureka-client, spring-cloud-netflix-ribbon。它们内部的这两个依赖都是optional。这些组件对应的starter内部使用了spring-cloud-starter 依赖，因为spring-cloud-starter依赖内部依赖了spring-cloud-context、spring-cloud-commons和spring-boot-starter(springboot全套架构)。 本文将分析spring-cloud-commons模块。关于spring-cloud-context将在下一篇文章中分析。 spring-cloud-commons模块是spring在分布式领域上(服务发现，服务注册，断路器，负载均衡)的规范定义(spring-cloud-netflix是具体的实现，也就是Netflix OSS里的各种组件实现了这个commons规范)，可以被所有的Spring Cloud客户端使用(比如服务发现领域的eureka，consul)。下面将根据包名来分析一下内部的一些接口和类。 1、actuator功能actuator子包里提供了一个id为 features 的 FeaturesEndpoint。该Endpoint里会展示应用具体的feature。具体的内容在HasFeatures集合属性中，HasFeatures内部包含 List abstractFeatures { List list = new ArrayList( restTemplate.getInterceptors()); list.add(loadBalancerInterceptor); restTemplate.setInterceptors(list); }; }} LoadBalancerInterceptor拦截器内部会对request请求进行拦截。拦截器内部使用LoadBalancerClient完成请求的调用，这里调用的时候需要的LoadBalancerRequest由LoadBalancerRequestFactory构造，LoadBalancerRequestFactory内部使用LoadBalancerRequestTransformer对request进行转换。 5.3 Retrying Failed RequestsRestTemplate可以配置请求失败后的重试策略；默认这个逻辑是禁止的，如果需要可以开启，只需要添加 Spring Retry到classpath; 如果spring retry已经在classpath，你想要禁用这个retry的功能，那么可以配置spring.cloud.loadbalancer.retry.enabled=false 如果想要自定义一个BackOffPolicy,需要创建一个LoadBalancedRetryFactory并覆写方法createBackOffPolicy; eg: Code123456789101112@Configurationpublic class MyConfiguration { @Bean LoadBalancedRetryFactory retryFactory() { return new LoadBalancedRetryFactory() { @Override public BackOffPolicy createBackOffPolicy(String service) { return new ExponentialBackOffPolicy(); } }; }} 5.4 Multiple RestTemplate objects如何创建一个支持负载均衡的RestTemplate和不支持负载均衡的RestTemplate以及注入的方式？看下面的列子： Code1234567891011121314151617181920212223242526272829303132@Configurationpublic class MyConfiguration { @LoadBalanced @Bean RestTemplate loadBalanced() { return new RestTemplate(); } @Primary @Bean RestTemplate restTemplate() { return new RestTemplate(); }}public class MyClass { @Autowired private RestTemplate restTemplate; @Autowired @LoadBalanced private RestTemplate loadBalanced; public String doOtherStuff() { return loadBalanced.getForObject(\"http://stores/stores\", String.class); } public String doStuff() { return restTemplate.getForObject(\"http://example.com\", String.class); }} @Primary的作用是在使用@Autowired注入时，如果发现了多个类型的bean, 就选择使用了@Primary的bean 如果遇到了这个异常java.lang.IllegalArgumentException: Can not set org.springframework.web.client.RestTemplate field com.my.app.Foo.restTemplate to com.sun.proxy.$Proxy89,可以尝试注入类型修改RestOperations或者设置spring.aop.proxyTargetClass=true 6、hypermedia功能springcloud对hateoas在服务发现领域上的支持。 关于hateoas可以参考一些资料： https://github.com/spring-projects/spring-hateoas https://spring.io/guides/gs/rest-hateoas/ 其它注解、接口、类 @SpringCloudApplication注解 整合了@SpringBootApplication、@EnableDiscoveryClient、@EnableCircuitBreaker这3个注解，说明@SpringCloudApplication注解表示一个分布式应用注解 ServiceInstance接口 表示服务发现系统里的一个服务实例 DefaultServiceInstance类 实现了ServiceInstance接口，是个默认的服务实例的实现 HostInfoEnvironmentPostProcessor类 属于EnvironmentPostProcessor。这个postprocessor会在`Environment里加上当前vm的hostname和ip信息 CommonsClientAutoConfiguration类 自动化配置类。在该模块的 META-INF/spring.factories里配置，key为org.springframework.boot.autoconfigure.EnableAutoConfiguration。所以默认会被加载，内部会构造一些HealthIndicator，一些Endpoint Spring Cloud Alibaba内部的spring-cloud-alibaba-nacos-discovery模块实现了spring-cloud-commons规范，提供了基于Nacos的服务发现，服务注册功能。Nacos是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/tags/spring-cloud/"}]},{"title":"Spring Cloud Context总览","slug":"Spring Cloud Context总览","date":"2019-12-29T08:46:33.000Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2019/12/29/Spring Cloud Context总览/","link":"","permalink":"https://calebzhao.github.io/2019/12/29/Spring%20Cloud%20Context%E6%80%BB%E8%A7%88/","excerpt":"","text":"spring cloud 中的许多特性都已经被spring boot实现，其他一些特性主要是通过spring cloud context 和 spring cloud commons来实现的。spring cloud context提供了一些常用的公共类以及spring cloud 特有的服务(bootstrap context, encryption, refresh scope, and environment endpoints)；spring cloud commons提供了一系列的抽象类和公共类，供spring cloud不同的实现组件去使用(such as Spring Cloud Netflix and Spring Cloud Consul).。 1. Spring Cloud Context: Application Context Services通过spring boot 构建 spring application已经很方便了，她还提供了一些监控、管理相关的endpoint; 由于 spring cloud 是建立在spring boot基础之上的，所以spring boot 的功能spring cloud都满足，此外还提供了一些特有的特性，这些特性可能在所有的spring cloud组件中都会（或者偶尔）使用到 1.1 The Bootstrap Application Contextspring cloud 应用中创建一个 bootstrap context，她是作为了主应用的 parent context ；主要负责从外部资源（主要指配置中心）加载配置以及在解码本地的配置文件。appliction context 和 bootstrap context 共享了相同Environment. 默认情况下，bootstrap properties(从配置中心加载的属性) 有更高的优先级，所以它们不能被本地的配置所覆盖。 bootstrap context使用了和主应用的 context 不同的配置方式，使用的是 bootstrap.yml 而不是 application.yml，这主要是为了保证两个context的配置可以很好的分离；下面是 bootstrap.yml 的例子： yml123456spring: application: name: foo cloud: config: uri: ${SPRING_CONFIG_URI:http://localhost:8888} 如果需要禁用 bootstrap context ，我们可以设置环境变量spring.cloud.bootstrap.enabled=false 1.2 Application Context Hierarchies如果你通过SpringApplication 或者 SpringApplicationBuilder来构建你的应用，那么Bootstrap context 将会作为application context 的 parent context。子容器会继承从父容器中的属性，新增的属性有： bootstrap : 如果在Bootstrap context有任何非空的属性,那么这些属性的优先级都更高，比如说从 spring cloud config 加载的配置，默认优先级就比本地配置高；后面会提到如何覆盖这些属性 applicationConfig : 如果你配置bootstrap.yml, 那么bootstrap.yml中的属性会用来配置 Bootstrap context；当Bootstrap context配置完成后就会把这些属性添加到application context 中，这些属性的优先级会比配置在application.yml 中的低由于bootstrap.yml 的优先级比较低，所以可以用来设置一些属性的默认值 spring cloud 允许你扩展ApplicationContext ,例如可以使用 ApplicationContext已有的接口或者使用SpringApplicationBuilder提供的方法(parent(), child() and sibling())；这个bootstrap context是所有容器的父容器 1.3 Changing the Location of Bootstrap Properties能够通过设置环境变量spring.cloud.bootstrap.name（默认是bootstrap）配置引导文件（bootstrap.yml）的名字，通过 spring.cloud.bootstrap.location(默认是空)配置路径。例如在环境变量中配置： Code12spring.cloud.bootstrap.name=startspring.cloud.bootstrap.location=classpath:/test/ 以上配置表明会加载classpath:/test/start.yml(start.properties) 1.4 Overriding the Values of Remote Properties通过bootstrap context从远程添加的属性默认情况下是不能被本地配置所覆盖的。如果你想要使用系统变量或者配置文件来覆盖远程的属性，在远程配置中设置属性spring.cloud.config.allowOverride=true(注意：在本地文件中设置是无效的)来授权，同时需要配置哪些可以覆盖： Code12345#远程属性不覆盖任何本地属性（本地任何属性都可以覆盖远程属性）spring.cloud.config.overrideNone=true #远程属性不覆盖任何本地系统属性（本地环境变量，命令行参数可以覆盖远程属性，本地配置文件属性不能覆盖远程属性）spring.cloud.config.overrideSystemProperties=false 1.5 Customizing the Bootstrap Configurationbootstrap context通过/META-INF/spring.factories配置的类初始化的所有的Bean都会在SpingApplicatin启动前加入到它的上下文里去。spring.factories中key 使用 org.springframework.cloud.bootstrap.BootstrapConfiguration, 所有需要用来配置bootstrap context的配置类用逗号分隔；可以通过@Order来更改初始化序列，默认是”last” spring-cloud-context.jar包的/META-INF/spring.factories源码如下： Code123456789101112131415161718# AutoConfigurationorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\\org.springframework.cloud.autoconfigure.LifecycleMvcEndpointAutoConfiguration,\\org.springframework.cloud.autoconfigure.RefreshAutoConfiguration,\\org.springframework.cloud.autoconfigure.RefreshEndpointAutoConfiguration,\\org.springframework.cloud.autoconfigure.WritableEnvironmentEndpointAutoConfiguration# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.cloud.bootstrap.BootstrapApplicationListener,\\org.springframework.cloud.bootstrap.LoggingSystemShutdownListener,\\org.springframework.cloud.context.restart.RestartListener# Bootstrap componentsorg.springframework.cloud.bootstrap.BootstrapConfiguration=\\org.springframework.cloud.bootstrap.config.PropertySourceBootstrapConfiguration,\\org.springframework.cloud.bootstrap.encrypt.EncryptionBootstrapConfiguration,\\org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration 首先使用spring.factories中配置的类来创建bootstrap context，然后所有使用@Bean注解的ApplicationContextInitializer将会被添加 main application context 1.6 Customizing the Bootstrap Property Sources默认情况下外部化配置都是从配置中心获取属性，但是也可以通过实现PropertySourceLocator来实现添加属性到bootstrap context（需要把实现类添加到spring.factories）；比如可以从不同的数据库或者服务器获取配置。 Code12345678910@Configurationpublic class CustomPropertySourceLocator implements PropertySourceLocator { @Override public PropertySource locate(Environment environment) { return new MapPropertySource(\"customProperty\", Collections.singletonMap(\"property.from.sample.custom.source\", \"worked as intended\")); }} 如果你把这个类打包到了一个jar里面，添加下面的配置到META-INF/spring.factories里面，那么所有依赖了这个jar的都会有customProperty这个配置 Code1org.springframework.cloud.bootstrap.BootstrapConfiguration=sample.custom.CustomPropertySourceLocator 1.8 Environment Changes应用可以监听EnvironmentChangeEvent来响应环境变量被改变的事件。一旦EnvironmentChangeEvent事件被触发，应用程序将会做这些事情： 重新绑定使用了@ConfigurationProperties的类 根据logging.level.*来设置应用的日志级别默认情况下，Config Client不轮询Environment的改变。一般情况，不建议使用这种方式来监测变化（虽然你可以通过@Scheduled注解来设置）。对于可扩展的应用程序，使用广播EnvironmentChangeEvent到所有实例的方式，好过轮询的方式。（比如使用Spring Cloud Bus项目）。 1.9 Refresh Scope当有配置发生变化的时候，使用了@RefreshScope的类将会被处理；这个特性解决了有状态bean只能在初始化注入配置的问题。例如：比如，在使用DataSource获得一个数据库连接的是时候，当通过Environment修改数据库连接字符串的时候，我们可以通过执行@RefreshScope来根据修改的配置获取一个新的URL的连接。Refresh scope beans是延迟初始化的，在第一次使用的时候才初始化，这个scope充当了初始值的缓存；为了在下一次调用时强制初始化，必须使缓存无效。RefreshScope在容器中是一个bean, 提供了一个public方法refreshAll()，通过清理当前的缓存来刷新，可以通过访问/refresh来触发刷新；也可以使用bean的名字来刷新refresh(String)，要使用还需要暴露出这个endpoint Code12345management: endpoints: web: exposure: include: refresh 注意：@RefreshScope注解在一个@Configuration类上面，在重新初始化的时候需要注意到可以相互依赖造成的冲突。 1.11 Endpoints相对于Spring Boot Actuator的应用，添加了一些管理端点： Code1234POST to /actuator/env 更新Environment重新加载@ConfigurationProperties和日志级别/actuator/refresh 重新初始化添加了@RefreshScope 的bean/actuator/restart 重启初始化ApplicationContext，重启 (默认是禁用的)/actuator/pause 调用ApplicationContext生命周期的方法stop()和start() 如果禁用了/actuator/restart，那么/actuator/pause和/actuator/resume都会被禁用 作者：9527华安 链接：https://www.jianshu.com/p/a8b255c9feae 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/tags/spring-cloud/"}]},{"title":"3、Spring Cloud Discovery 源码分析（Eureka）","slug":"Spring Cloud Discovery 源码分析（Eureka）","date":"2019-12-29T08:38:12.000Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2019/12/29/Spring Cloud Discovery 源码分析（Eureka）/","link":"","permalink":"https://calebzhao.github.io/2019/12/29/Spring%20Cloud%20Discovery%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88Eureka%EF%BC%89/","excerpt":"","text":"我们在将一个普通的Spring Boot应用注册到Eureka Server中，或是从Eureka Server中获取服务列表时，主要就做了两件事： 在应用主类he中配置了@EnableDiscoveryClient注解 在application.properties中用eureka.client.serviceUrl.defaultZone参数指定了服务注册中心的位置 顺着上面的线索，我们先查看具体实现: @EnableDiscoveryClient的源码如下:java123456789101112131415161718/** * Annotation to enable a DiscoveryClient implementation. * @author Spencer Gibb */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(EnableDiscoveryClientImportSelector.class)public @interface EnableDiscoveryClient { /** * If true, the ServiceRegistry will automatically register the local server. * @return - {@code true} if you want to automatically register. */ boolean autoRegister() default true;} @EnableDiscoveryClient注解的作用主要是用来引入EnableDiscoveryClientImportSelector这个类 EnableDiscoveryClientImportSelector的源码： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @author Spencer Gibb */@Order(Ordered.LOWEST_PRECEDENCE - 100)public class EnableDiscoveryClientImportSelector extends SpringFactoryImportSelector { @Override public String[] selectImports(AnnotationMetadata metadata) { String[] imports = super.selectImports(metadata); AnnotationAttributes attributes = AnnotationAttributes.fromMap( metadata.getAnnotationAttributes(getAnnotationClass().getName(), true)); boolean autoRegister = attributes.getBoolean(\"autoRegister\"); if (autoRegister) { List importsList = new ArrayList(Arrays.asList(imports)); importsList.add( \"org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationConfiguration\"); imports = importsList.toArray(new String[0]); } else { Environment env = getEnvironment(); if (ConfigurableEnvironment.class.isInstance(env)) { ConfigurableEnvironment configEnv = (ConfigurableEnvironment) env; LinkedHashMap map = new LinkedHashMap(); map.put(\"spring.cloud.service-registry.auto-registration.enabled\", false); MapPropertySource propertySource = new MapPropertySource( \"springCloudDiscoveryClient\", map); configEnv.getPropertySources().addLast(propertySource); } } return imports; } @Override protected boolean isEnabled() { return getEnvironment().getProperty(\"spring.cloud.discovery.enabled\", Boolean.class, Boolean.TRUE); } @Override protected boolean hasDefaultFactory() { return true; }} EnableDiscoveryClientImportSelector继承了SpringFactoryImportSelector并指定了泛型EnableDiscoveryClient. 这里的泛型是重点. SpringFactoryImportSelector源码 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Selects configurations to load, defined by the generic type T. Loads implementations * using {@link SpringFactoriesLoader}. * * @param type of annotation class * @author Spencer Gibb * @author Dave Syer */public abstract class SpringFactoryImportSelector implements DeferredImportSelector, BeanClassLoaderAware, EnvironmentAware { private final Log log = LogFactory.getLog(SpringFactoryImportSelector.class); private ClassLoader beanClassLoader; private Class annotationClass; private Environment environment; @SuppressWarnings(\"unchecked\") protected SpringFactoryImportSelector() { this.annotationClass = (Class) GenericTypeResolver .resolveTypeArgument(this.getClass(), SpringFactoryImportSelector.class); } @Override public String[] selectImports(AnnotationMetadata metadata) { if (!isEnabled()) { return new String[0]; } AnnotationAttributes attributes = AnnotationAttributes.fromMap( metadata.getAnnotationAttributes(this.annotationClass.getName(), true)); Assert.notNull(attributes, \"No \" + getSimpleName() + \" attributes found. Is \" + metadata.getClassName() + \" annotated with @\" + getSimpleName() + \"?\"); // Find all possible auto configuration classes, filtering duplicates List factories = new ArrayList(new LinkedHashSet(SpringFactoriesLoader .loadFactoryNames(this.annotationClass, this.beanClassLoader))); if (factories.isEmpty() && !hasDefaultFactory()) { throw new IllegalStateException(\"Annotation @\" + getSimpleName() + \" found, but there are no implementations. Did you forget to include a starter?\"); } if (factories.size() > 1) { // there should only ever be one DiscoveryClient, but there might be more than // one factory this.log.warn(\"More than one implementation \" + \"of @\" + getSimpleName() + \" (now relying on @Conditionals to pick one): \" + factories); } return factories.toArray(new String[factories.size()]); } protected abstract boolean isEnabled(); ...省略} 这里只截取了部分变量和方法， SpringFactoryImportSelector是spring cloud common包中的一个抽象类, 主要作用是检查泛型T是否有指定的factory实现, 即spring.factories中有对应类的配置并启动自动化配置（由SpringFactoriesLoader加载并解析spring.factories文件, 具体加载原理见springboot2.2自动注入文件spring.factories如何加载详解） spring.factories 在spring-cloud-netflix-eureka-client.jar!/META-INF/spring.factories中EnableDiscoveryClient的指定factory实现是 properties12345678910org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.cloud.netflix.eureka.config.EurekaClientConfigServerAutoConfiguration,\\org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceAutoConfiguration,\\org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration,\\org.springframework.cloud.netflix.ribbon.eureka.RibbonEurekaAutoConfiguration,\\org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration,\\org.springframework.cloud.netflix.eureka.reactive.EurekaReactiveDiscoveryClientConfigurationorg.springframework.cloud.bootstrap.BootstrapConfiguration=\\org.springframework.cloud.netflix.eureka.config.EurekaDiscoveryClientConfigServiceBootstrapConfiguration EnableAutoConfiguration中包含了EurekaClientAutoConfiguration, EurekaClientAutoConfiguration会为```EurekaDiscoveryClientConfiguration`的实例依赖进行初始化。 下面对spring.factories中的eureka自动化配置一个个分析源码： EurekaClientConfigServerAutoConfiguration 配置服务器自动化配置java12345678910111213141516171819202122232425@Configuration(proxyBeanMethods = false)@EnableConfigurationProperties@ConditionalOnClass({ EurekaInstanceConfigBean.class, EurekaClient.class, ConfigServerProperties.class })public class EurekaClientConfigServerAutoConfiguration { @Autowired(required = false) private EurekaInstanceConfig instance; @Autowired(required = false) private ConfigServerProperties server; @PostConstruct public void init() { if (this.instance == null || this.server == null) { return; } String prefix = this.server.getPrefix(); if (StringUtils.hasText(prefix) && !StringUtils .hasText(this.instance.getMetadataMap().get(\"configPath\"))) { this.instance.getMetadataMap().put(\"configPath\", prefix); } }} 从源码看到注入了EurekaInstanceConfig instance配置，EurekaInstanceConfig这个bean是在org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration#eurekaInstanceConfigBean()中创建的， 另外 init()方法上有@PostConstruct注解，说明在创建这个bean后执行了init()方法， 方法内部获取ConfigServerProperties 中的prefix, 如果eureka.instance.metadata.configPath没有配置，则使用prefix的值。 EurekaClientAutoConfiguration 客户端自动化配置 实例化application.yml中eureka.instance及eureka.client相关属性配置的bean以及创建EurekaClient java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180@Configuration(proxyBeanMethods = false)@EnableConfigurationProperties@ConditionalOnClass(EurekaClientConfig.class)@Import(DiscoveryClientOptionalArgsConfiguration.class)@ConditionalOnProperty(value = \"eureka.client.enabled\", matchIfMissing = true)@ConditionalOnDiscoveryEnabled@AutoConfigureBefore({ NoopDiscoveryClientAutoConfiguration.class, CommonsClientAutoConfiguration.class, ServiceRegistryAutoConfiguration.class })@AutoConfigureAfter(name = { \"org.springframework.cloud.autoconfigure.RefreshAutoConfiguration\", \"org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration\", \"org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationAutoConfiguration\" })public class EurekaClientAutoConfiguration { // spring cloud commons中的HasFeatures, 声明了使用了Eureka Client这个特性 @Bean public HasFeatures eurekaFeature() { return HasFeatures.namedFeature(\"Eureka Client\", EurekaClient.class); } /** * 关键配置：eureka.client为前缀的相关配置属性bean(EurekaClientConfig的实现) */ @Bean @ConditionalOnMissingBean(value = EurekaClientConfig.class, search = SearchStrategy.CURRENT) public EurekaClientConfigBean eurekaClientConfigBean(ConfigurableEnvironment env) { EurekaClientConfigBean client = new EurekaClientConfigBean(); if (\"bootstrap\".equals(this.env.getProperty(\"spring.config.name\"))) { // We don't register during bootstrap by default, but there will be another // chance later. client.setRegisterWithEureka(false); } return client; } /** * 关键配置：eureka.instance位前缀的配置属性bean（EurekaInstanceConfig的实现） */ @Bean @ConditionalOnMissingBean(value = EurekaInstanceConfig.class, search = SearchStrategy.CURRENT) public EurekaInstanceConfigBean eurekaInstanceConfigBean(InetUtils inetUtils, ManagementMetadataProvider managementMetadataProvider) { // 获取配置的主机名 String hostname = getProperty(\"eureka.instance.hostname\"); // 是否优先使用ip地址注册到注册中心 boolean preferIpAddress = Boolean .parseBoolean(getProperty(\"eureka.instance.prefer-ip-address\")); // 指定ip地址 String ipAddress = getProperty(\"eureka.instance.ip-address\"); // 是否启用安全端口 boolean isSecurePortEnabled = Boolean .parseBoolean(getProperty(\"eureka.instance.secure-port-enabled\")); // servlet上下文路径 String serverContextPath = env.getProperty(\"server.servlet.context-path\", \"/\"); // 启动端口号，如果没配置则默认8080 int serverPort = Integer.parseInt( env.getProperty(\"server.port\", env.getProperty(\"port\", \"8080\"))); // 管理端口号 Integer managementPort = env.getProperty(\"management.server.port\", Integer.class); // 管理上下文路径 String managementContextPath = env .getProperty(\"management.server.servlet.context-path\"); // jmx端口号 Integer jmxPort = env.getProperty(\"com.sun.management.jmxremote.port\", Integer.class); // 最终返回的bean EurekaInstanceConfigBean instance = new EurekaInstanceConfigBean(inetUtils); instance.setNonSecurePort(serverPort); // 实例id， 默认为:主机名:服务名:[实例id | 端口号] // 具体格式为${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id}或erver.port} instance.setInstanceId(getDefaultInstanceId(env)); // 是否优先使用ip地址 instance.setPreferIpAddress(preferIpAddress); instance.setSecurePortEnabled(isSecurePortEnabled); // ip地址 if (StringUtils.hasText(ipAddress)) { instance.setIpAddress(ipAddress); } // 安全端口号是否启用 if (isSecurePortEnabled) { instance.setSecurePort(serverPort); } // 主机名设置 if (StringUtils.hasText(hostname)) { instance.setHostname(hostname); } // 实例状态页url路径 String statusPageUrlPath = getProperty(\"eureka.instance.status-page-url-path\"); // 健康检查url路径 String healthCheckUrlPath = getProperty(\"eureka.instance.health-check-url-path\"); if (StringUtils.hasText(statusPageUrlPath)) { instance.setStatusPageUrlPath(statusPageUrlPath); } if (StringUtils.hasText(healthCheckUrlPath)) { instance.setHealthCheckUrlPath(healthCheckUrlPath); } ...省略代码 setupJmxPort(instance, jmxPort); return instance; } /** * 关键配置：实例注册的实现bean（spring cloud commons项目中ServiceRegistry的实现） */ @Bean public EurekaServiceRegistry eurekaServiceRegistry() { return new EurekaServiceRegistry(); } /** * 关键配置：启动时自动注册服务实现(spring cloud commons项目中AutoServiceRegistration的实现）) */ @Bean @ConditionalOnBean(AutoServiceRegistrationProperties.class) @ConditionalOnProperty( value = \"spring.cloud.service-registry.auto-registration.enabled\", matchIfMissing = true) public EurekaAutoServiceRegistration eurekaAutoServiceRegistration( ApplicationContext context, EurekaServiceRegistry registry, EurekaRegistration registration) { return new EurekaAutoServiceRegistration(context, registry, registration); } @Configuration(proxyBeanMethods = false) @ConditionalOnMissingRefreshScope protected static class EurekaClientConfiguration { @Autowired private ApplicationContext context; @Autowired private AbstractDiscoveryClientOptionalArgs optionalArgs; /** * 关键配置：实例化netflix的EurekaClient， 提供最终的服务注册发现功能， 该类具体源码后续分析。 * * 在该类的构造方法中会做非常多的事情： * 1、时候会根据eureka.client.serviceUrl的值依次遍历得到eureka server的地址向eureka server发送url路径 * 为/apps的rest请求来获取已注册的服务信息，得到一个Applications对象，最终存储到localRegionApps属性中， * 如果获取失败则尝试使用当前zone的下一个url地址重新发送请求，直到成果(如果是集群，即eureka.client.serviceUrl的值是逗号分隔的多个地址)， 但是最多重试3次 * * 2、 然后启动一系列的定时任务（cluster resolvers, heartbeat, instanceInfo replicator, fetch），具体源码 * 后面会分析，这里只要知道什么时候第一次获取的服务注册信息、以后怎么更新的服务注册信息，存到哪就可以了。 */ @Bean(destroyMethod = \"shutdown\") @ConditionalOnMissingBean(value = EurekaClient.class, search = SearchStrategy.CURRENT) public EurekaClient eurekaClient(ApplicationInfoManager manager, EurekaClientConfig config) { return new CloudEurekaClient(manager, config, this.optionalArgs, this.context); } @Bean @ConditionalOnMissingBean(value = ApplicationInfoManager.class, search = SearchStrategy.CURRENT) public ApplicationInfoManager eurekaApplicationInfoManager(EurekaInstanceConfig config) { InstanceInfo instanceInfo = new InstanceInfoFactory().create(config); return new ApplicationInfoManager(config, instanceInfo); } /** * 关键配置：注册服务实例到注册中心时的承载实例信息的类（spring cloud commons项目中Registration的实现） */ @Bean @org.springframework.cloud.context.config.annotation.RefreshScope @ConditionalOnBean(AutoServiceRegistrationProperties.class) @ConditionalOnProperty(value = \"spring.cloud.service-registry.auto-registration.enabled\", matchIfMissing = true) public EurekaRegistration eurekaRegistration(EurekaClient eurekaClient, CloudEurekaInstanceConfig instanceConfig, ApplicationInfoManager applicationInfoManager, @Autowired(required = false) ObjectProvider healthCheckHandler) { return EurekaRegistration.builder(instanceConfig).with(applicationInfoManager) .with(eurekaClient).with(healthCheckHandler).build(); } }} EurekaInstanceConfigBean 实例配置信息实例化eureka.instance为前缀的配置信息EurekaInstanceConfigBean(实现了EurekaInstanceConfig) 用户承载eureka.instance配置信息的EurekaInstanceConfigBean类的源码如下： Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import static org.springframework.cloud.commons.util.IdUtils.getDefaultInstanceId;@ConfigurationProperties(\"eureka.instance\")public class EurekaInstanceConfigBean implements CloudEurekaInstanceConfig, EnvironmentAware { private static final String UNKNOWN = \"unknown\"; // 当前机器信息 private HostInfo hostInfo; // 应用名，setEnvironment(Enviroment)方法会设置该属性为spring.application.name的值 private String appname = UNKNOWN; // 默认心跳时间， 每隔30秒客户端向服务端发送1次心跳，告诉服务端自己还活着， // 如果服务端在指定的leaseExpirationDurationInSeconds时间内还没有收到来自客户端的心跳，则服务端会从自己内部移除该实例, 这会导致禁止与该实例通信 private int leaseRenewalIntervalInSeconds = 30; // 租约有效期，默认90秒，服务端从上一次心跳时间开始算起若经过90秒还没有收到来自客户端的心跳则会移除该实例 // 该时间设置的过长会导致即使客户端已经死了，服务端仍然认为他还活着，那么当服务消费者真正访问该服务提供者实例时就会把请求路由给可已经死去的服务提供者，导致服务调用失败 // 将此值设置得太小可能意味着，由于临时网络故障，实例可能会从流量中删除(比如10秒， 那么如果由于网络波动导致某次没能成功续约，但是客户端并不是真正死了，可能过一会就恢复了，服务端由于这1次网络波动没收到心跳就把客户端剔除了使得服务不可用就浪费了1个服务实例) private int leaseExpirationDurationInSeconds = 90; // 虚拟主机名，setEnvironment(Enviroment)方法会设置该属性为spring.application.name的值 private String virtualHostName = UNKNOWN; // 实例id， 由EurekaClientAutoConfiguration设置默认值及最终值 private String instanceId; // 实例元数据 private Map metadataMap = new HashMap(); // 实例ip地址，由EurekaClientAutoConfiguration设置最终值，默认值由构造方法设置(若存在则设置） private String ipAddress; // 状态页url路径 private String statusPageUrlPath = actuatorPrefix + \"/info\" // 健康检查页面地址 private String healthCheckUrlPath = actuatorPrefix + \"/health\"; // 命名空间 private String namespace = \"eureka\"; // 主机名，默认值由构造方法设置，最终值由EurekaClientAutoConfiguration设置（若存在则设置） private String hostname; // 是否优先使用ip地址注册，最终值由EurekaClientAutoConfiguration设置 private boolean preferIpAddress = false; // 实例初始状态 private InstanceStatus initialStatus = InstanceStatus.UP; // 实例环境变量， 当前类实现了EnvironmentAware接口，通过setEnvironment(Environment environment)回调方法赋值 private Environment environment; public EurekaInstanceConfigBean(InetUtils inetUtils) { this.inetUtils = inetUtils; // 获取主机信息 this.hostInfo = this.inetUtils.findFirstNonLoopbackHostInfo(); // 设置默认的ip地址，由EurekaClientAutoConfiguration覆盖 this.ipAddress = this.hostInfo.getIpAddress(); //设置默认主机名，由EurekaClientAutoConfiguration覆盖 this.hostname = this.hostInfo.getHostname(); } // 当前类实现了EnvironmentAware接口 @Override public void setEnvironment(Environment environment) { this.environment = environment; //取spring.application.name的值 String springAppName = this.environment.getProperty(\"spring.application.name\", \"\"); if (StringUtils.hasText(springAppName)) { setAppname(springAppName); setVirtualHostName(springAppName); setSecureVirtualHostName(springAppName); } }} 从EurekaInstanceConfigBean的构造方法中可以看到它接收1个参数InetUtils, this.hostInfo = this.inetUtils.findFirstNonLoopbackHostInfo();这行代码使用传入的InetUtils获取主机信息， 接下来分析InetUtils网络工具类源码。 InetUtils网络工具类Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class InetUtils implements Closeable { public HostInfo findFirstNonLoopbackHostInfo() { InetAddress address = findFirstNonLoopbackAddress(); if (address != null) { return convertAddress(address); } HostInfo hostInfo = new HostInfo(); hostInfo.setHostname(this.properties.getDefaultHostname()); hostInfo.setIpAddress(this.properties.getDefaultIpAddress()); return hostInfo; } public InetAddress findFirstNonLoopbackAddress() { InetAddress result = null; try { int lowest = Integer.MAX_VALUE; // 通过jdk的NetworkInterface获取所有网络接口 for (Enumeration nics = NetworkInterface .getNetworkInterfaces(); nics.hasMoreElements();) { NetworkInterface ifc = nics.nextElement(); // 当前遍历的网络接口是否已启用 if (ifc.isUp()) { this.log.trace(\"Testing interface: \" + ifc.getDisplayName()); // 找出索引最小的网络接口 if (ifc.getIndex() < lowest || result == null) { lowest = ifc.getIndex(); } else if (result != null) { continue; } // 判断是否需要忽略当前网络接口 if (!ignoreInterface(ifc.getDisplayName())) { // 不忽略当前网络接口，获取当前网络接口的所有网络地址 for (Enumeration addrs = ifc .getInetAddresses(); addrs.hasMoreElements();) { InetAddress address = addrs.nextElement(); // 是ipv4地址，且不是本地回环地址(127.xxx.xxx.xx这种地址)， 且是优先需要使用的地址 if (address instanceof Inet4Address && !address.isLoopbackAddress() && isPreferredAddress(address)) { this.log.trace(\"Found non-loopback interface: \" + ifc.getDisplayName()); result = address; } } } // @formatter:on } } } catch (IOException ex) { this.log.error(\"Cannot get first non-loopback address\", ex); } if (result != null) { return result; } try { return InetAddress.getLocalHost(); } catch (UnknownHostException e) { this.log.warn(\"Unable to retrieve localhost\"); } return null; }} org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration#eurekaInstanceConfigBean方法中获取EurekaInstanceConfigBean实例时设置了实例id(instance.setInstanceId(getDefaultInstanceId(env));)中的getDefaultInstanceId()方法是IdUtils类中的方法，这里的getDefaultInstanceId()方法是静态导入的，所以没有看到通过Class.methods()这种形式调用，IdUtils的实现源码如下： IdUtils 实例id工具类java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final class IdUtils { public static String getDefaultInstanceId(PropertyResolver resolver) { return getDefaultInstanceId(resolver, true); } // 默认实例id(主机名:服务名:[实例id | 端口号]) // 具体格式为${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id}或${server.port} public static String getDefaultInstanceId(PropertyResolver resolver, boolean includeHostname) { String vcapInstanceId = resolver.getProperty(\"vcap.application.instance_id\"); if (StringUtils.hasText(vcapInstanceId)) { return vcapInstanceId; } String hostname = null // 实例id是否包含主机名，上面重载的getDefaultInstanceId方法内部传递的第2个参数为true，所以会包含主机名 ; if (includeHostname) { hostname = resolver.getProperty(\"spring.cloud.client.hostname\"); } // spring.application.name的属性值 String appName = resolver.getProperty(\"spring.application.name\"); // 值为${spring.cloud.client.hostname}:${spring.application.name} , 把hostname和appName用冒号拼接起来 String namePart = combineParts(hostname, SEPARATOR, appName); // 值为${spring.application.instance_id}或${server.port} String indexPart = resolver.getProperty(\"spring.application.instance_id\", resolver.getProperty(\"server.port\")); // 把namePart和indexPart用冒号拼接起来 // ${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id}或${server.port} return combineParts(namePart, SEPARATOR, indexPart); } public static String combineParts(String firstPart, String separator, String secondPart) { String combined = null; if (firstPart != null && secondPart != null) { combined = firstPart + separator + secondPart; } else if (firstPart != null) { combined = firstPart; } else if (secondPart != null) { combined = secondPart; } return combined; }} EurekaClientConfigBean 客户端配置 实例化eureka.client为前缀的配置信息EurekaClientConfigBean(实现了EurekaClientConfig) java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167@ConfigurationProperties(EurekaClientConfigBean.PREFIX)public class EurekaClientConfigBean implements EurekaClientConfig, Ordered { private static final int MINUTES = 60; // 配置前缀 public static final String PREFIX = \"eureka.client\"; // 默认eureka server的地址 public static final String DEFAULT_URL = \"http://localhost:8761\" + DEFAULT_PREFIX + \"/\"; // 表示默认zone的名称 // region可以理解为数据中心, zone可以理解为1个数据中的机房， instance理解为具体主机 // 例如 亚马逊、阿里云2个数据中心 // 阿里云有多个跨区的机房，如北京、广东 // 而1个机房里又有很多主机（实例） public static final String DEFAULT_ZONE = \"defaultZone\"; // 每隔多长时间从eureka server拉取1次注服务册信息，单位秒 private int registryFetchIntervalSeconds = 30; // 指示将实例更改信息复制到eureka服务器的频率(以秒为单位) private int instanceInfoReplicationIntervalSeconds = 30; // 指示最初(以秒为单位)将实例信息复制到eureka需要多长时间 private int initialInstanceInfoReplicationIntervalSeconds = 40; // 指定多久1次轮训eureka server服务器信息的变更， Eureka服务器可以被添加或移除，该设置可以控制Eureka客户端应该多快知道eureka server的添加和移除。 private int eurekaServiceUrlPollIntervalSeconds = 5 * MINUTES; // 代理端口 private String proxyPort; // 代理主机 private String proxyHost; // 代理用户名 private String proxyUserName; // 代理密码 private String proxyPassword; // 从eureka server读信息的超时时间设置 private int eurekaServerReadTimeoutSeconds = 8; // 与eureka server建立连接的超时时间设置 private int eurekaServerConnectTimeoutSeconds = 5; // 从eureka server获取注册信息的后备实现（须实现BackupRegistry接口） private String backupRegistryImpl; /** * 指示eureka客户端是否应该使用DNS机制获取要与之通信的eureka服务器列表。 * 当更新DNS名称以拥有其他服务器时，将在eureka客户端轮询eurekaServiceUrlPollIntervalSeconds中指定的信息之后立即使用该信息。 */ private boolean useDnsForFetchingServiceUrls = false; /** * 获取用来构造服务url的上下文路径，以便在eureka的服务器地址列表来源于dns时与eureka进行通信，当从eurekaServerServiceUrls返回服务url信息时该配置是不需要的。 * * 当useDnsForFetchingServiceUrls设置为true时，将使用DNS机制，eureka客户端希望DNS以某种方式配置，以便它能够动态获取变化的eureka服务器。 */ private String eurekaServerURLContext; /** * 获取用来构造服务url的端口，以便在eureka的服务器地址列表来源于dns时与eureka进行通信，当从eurekaServerServiceUrls返回服务url信息时该配置是不需要的。 * * 当useDnsForFetchingServiceUrls设置为true时，将使用DNS机制，eureka客户端希望DNS以某种方式配置，以便它能够动态获取变化的eureka服务器。 */ private String eurekaServerPort; /** * 获取要查询的DNS名称，以获得eureka服务器的列表。如果契约通过实现serviceUrls返回服务url，则不需要此信息。 * * 当useDnsForFetchingServiceUrls设置为true时，将使用DNS机制，eureka客户端希望DNS以某种方式配置，以便它能够动态获取变化的eureka服务器。 * 更改在运行时有效。 * private String eurekaServerDNSName; // 数据中心名称 private String region = \"us-east-1\"; // 指定与eureka server建立的http连接在关闭前可以空闲多少时间（以秒位单位） private int eurekaConnectionIdleTimeoutSeconds = 30; // 心跳线程池的初始大小 private int heartbeatExecutorThreadPoolSize = 2 // 心跳执行器指数回退相关属性。它是重试延迟的最大乘法器值，用于发生一系列超时的情况。 private int heartbeatExecutorExponentialBackOffBound = 10; // cacheRefreshExecutor线程池的初始大小。 private int cacheRefreshExecutorThreadPoolSize = 2; // cacheRefreshExecutor执行器指数回退相关属性。它是重试延迟的最大乘法器值，用于发生一系列超时的情况。 private int cacheRefreshExecutorExponentialBackOffBound = 10; // eureka服务地址，这里设置了默认值defaultZone=http://localhost:8761/eureka/ private Map serviceUrl = new HashMap(); { this.serviceUrl.put(DEFAULT_ZONE, DEFAULT_URL); } // 指定当前实例是否应该将它自己的信息注册到eureka server中用于服务发现 private boolean registerWithEureka = true; // 指定当前实例是否应出于延迟和/或其他原因尝试使用同一区域中的eureka服务器。 // 理想情况下，eureka客户端被配置为与同一区域中的服务器通信 // 正如 registryFetchIntervalSeconds 指定的那样，这些更改在运行时在下一个注册表获取周期生效 private boolean preferSameZoneEureka = true; // 用逗号分隔的区域(region)列表，用于获取eureka注册信息， 必须为每个region定义可用机房（availability zones）来作为availabilityZones的返回值，如果不这样做会导致启动失败 private String fetchRemoteRegionsRegistry; // 获取此实例所在区域的可用性区域列表(在AWS数据中心中使用)。 // 正如 registryFetchIntervalSeconds 指定的那样，这些更改在运行时在下一个注册表获取周期生效 private Map availabilityZones = new HashMap(); // 指定是否在筛选只具有 instanceatus UP 状态的实例的应用程序后获取应用程序。 private boolean filterOnlyUpInstances = true; // 指定当前客户端是否应该从eureka server获取服务注册信息 private boolean fetchRegistry = true; // 指定服务端是否可以将一个客户端请求重定向到后备服务器或者集群中 private boolean allowRedirects = false; // 如果设置为true，通过ApplicationInfoManager进行的本地状态更新将触发按需(但速率有限)注册/更新到远程eureka服务器。 private boolean onDemandUpdateStatusChange = true; /** * 根据region获取机房列表， 如果找不到则返回默认机房(defaultZone) */ @Override public String[] getAvailabilityZones(String region) { // 根据region获取机房列表 String value = this.availabilityZones.get(region); if (value == null) { // 默认机房 value = DEFAULT_ZONE; } return value.split(\",\"); } /** * 根据机房获取eureka server地址， 一个机房可以部署多台eureka server组成高可用集群 */ @Override public List getEurekaServerServiceUrls(String myZone) { // 根据机房id获取eureka server地址（逗号分隔的多个url） String serviceUrls = this.serviceUrl.get(myZone); if (serviceUrls == null || serviceUrls.isEmpty()) { // 使用默认机房(defaultZone)的eureka server地址 serviceUrls = this.serviceUrl.get(DEFAULT_ZONE); } if (!StringUtils.isEmpty(serviceUrls)) { // 用逗号分隔 final String[] serviceUrlsSplit = StringUtils .commaDelimitedListToStringArray(serviceUrls); List eurekaServiceUrls = new ArrayList(serviceUrlsSplit.length); for (String eurekaServiceUrl : serviceUrlsSplit) { // eureka server地址如果不是以/结尾则追加/ if (!endsWithSlash(eurekaServiceUrl)) { eurekaServiceUrl += \"/\"; } eurekaServiceUrls.add(eurekaServiceUrl.trim()); } return eurekaServiceUrls; } return new ArrayList(); }} Eureka 中的 region 和 Zone背景像亚马逊这种大型的跨境电商平台，会有很多个机房。这时如果上线一个服务的话，我们希望一个机房内的服务优先调用同一个机房内的服务，当同一个机房的服务不可用的时候，再去调用其它机房的服务，以达到减少延时的作用。于是亚马逊的 AWS 提供了 region 和 zone 两个概念 概念 region：可以简单理解为地理上的分区。比如亚洲地区，或者华北地区，再或者北京地区等等，没有具体大小的限制，根据项目具体的情况，可以自行划分region。 zone：可以简单理解为 region 内的具体机房，比如说 region 划分为华北地区，然后华北地区有两个机房，就可以在此 region 之下划分出 zone1、zone2 两个 zone eureka 也借用了 region 和 zone 的概念 分区服务架构图 如图所示，有一个 region:华北地区，下面有两个机房，机房A 和机房B每个机房内有一个 Eureka Server 集群 和两个服务提供者 ServiceA 和 ServerB现在假设 serverA 需要调用 ServerB 服务，按照就近原则，serverA 会优先调用同一个 zone 内的 ServiceB，当 ServiceB 不可用时，才会去调用另一个 zone 内的 ServiceB Eureka 中 Regin 和 Zone 的相关配置 服务注册：要保证服务注册到同一个zone内的注册中心，因为如果注册到别zone的注册中心的话，网络延时比较大，心跳检测很可能出问题。 服务调用：要保证优先调用同一个zone内的服务，只有在同一个zone内的服务不可用时，才去调用别zone的服务。yml1234567891011eureka: client: # 尽量向同一区域的 eureka 注册,默认为true prefer-same-zone-eureka: true #地区 region: huabei availability-zones: huabei: zone-1,zone-2 service-url: zone-1: http://localhost:30000/eureka/ zone-2: http://localhost:30001/eureka/ 当存在多个注册中心时，选择逻辑为: 如果 prefer-same-zone-eureka 为 false，按照 service-url 下的 list 取第一个注册中心来注册，并和其维持心跳检测，不再向list内的其它的注册中心注册和维持心跳。只有在第一个注册失败的情况下，才会依次向其它的注册中心注册，总共重试3次，如果3个service-url都没有注册成功，则注册失败。注册失败后每隔一个心跳时间，会再次尝试。 如果 prefer-same-zone-eureka 为true，先通过 region 取 availability-zones 内的第一个zone，然后通过这个zone取 service-url 下的list，并向list内的第一个注册中心进行注册和维持心跳，不再向list内的其它的注册中心注册和维持心跳。只有在第一个注册失败的情况下，才会依次向其它的注册中心注册，总共重试3次，如果3个service-url都没有注册成功，则注册失败。注册失败后每隔一个心跳时间，会再次尝试。 为了保证服务注册到同一个 zone 的注册中心，一定要注意 availability-zones 的顺序，必须把同一 zone 写在最前面 服务调用yml123456789eureka: instance: # 服务和注册中心的心跳间隔时间，默认为30s lease-renewal-interval-in-seconds: 30 # 服务和注册中心的心跳超时时间，默认为90s lease-expiration-duration-in-seconds: 90 metadata-map: # 当前服务所属的 zone zone: zone1 服务消费者和服务提供者分别属于哪个zone，均是通过 eureka.instance.metadata-map.zone 来判定的。 服务消费者会先通过 ribbon 去注册中心拉取一份服务提供者的列表，然后通过 eureka.instance.metadata-map.zone 指定的 zone 进行过滤，过滤之后如果同一个 zone 内的服务提供者有多个实例，则会轮流调用。 只有在同一个 zone 内的所有服务提供者都不可用时，才会调用其它zone内的服务提供者。 作者：我妻礼弥链接：https://juejin.im/post/5d68b73af265da03b12061be来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 EurekaClient以下图片来自Netflix官方，图中显示Eureka Client会向注册中心发起Get Registry请求来获取服务列表：在org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration中实例化了该bean, 源码如下：Code1234567891011121314151617181920212223242526272829public class EurekaClientAutoConfiguration{ @Configuration(proxyBeanMethods = false) @ConditionalOnMissingRefreshScope protected static class EurekaClientConfiguration { @Autowired private ApplicationContext context; @Autowired private AbstractDiscoveryClientOptionalArgs optionalArgs; /** * 关键配置：实例化netflix的EurekaClient， 提供最终的服务注册发现功能， 该类具体源码后续分析。 * * 在该类的构造方法中会做非常多的事情： * 1、时候会根据eureka.client.serviceUrl的值依次遍历得到eureka server的地址向eureka server发送url路径 * 为/apps的rest请求来获取已注册的服务信息，得到一个Applications对象，最终存储到localRegionApps属性中， * 如果获取失败则尝试使用当前zone的下一个url地址重新发送请求，直到成果(如果是集群，即eureka.client.serviceUrl的值是逗号分隔的多个地址)， 但是最多重试3次 * * 2、 然后启动一系列的定时任务（cluster resolvers, heartbeat, instanceInfo replicator, fetch），具体源码 * 后面会分析，这里只要知道什么时候第一次获取的服务注册信息、以后怎么更新的服务注册信息，存到哪就可以了。 */ @Bean(destroyMethod = \"shutdown\") @ConditionalOnMissingBean(value = EurekaClient.class, search = SearchStrategy.CURRENT) public EurekaClient eurekaClient(ApplicationInfoManager manager, EurekaClientConfig config) { return new CloudEurekaClient(manager, config, this.optionalArgs, this.context); } } 下面看EurekaClient这个类的源码，注意重点是该类的构造方法创建了一系列的定时任务（心跳、更新服务注册信息、根据dns更新serviceUrl、注册实例信息到eurekaserver）以及注册了事件监听器StatusChangeListener用于监听实例自身状态变化，当发生变化时上报服务实例信息到eureka server 该类的继承关系如下： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326@Singletonpublic class DiscoveryClient implements EurekaClient { // 用于执行如下几种列定时任务：更新服务地址、 private final ScheduledExecutorService scheduler; // additional executors for supervised subtasks private final ThreadPoolExecutor heartbeatExecutor; private final ThreadPoolExecutor cacheRefreshExecutor; // 存储调用/apps这个Url从eureka server获取的服务注册信息， 返回的信息被封装成Applications对象 // 而Applications对象内部会持有private final AbstractQueue applications;这个队列，1个Application代表1个服务，1个服务可能有多个实例， private final AtomicReference localRegionApps = new AtomicReference(); ...省略部分代码 @Inject DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args, Provider backupRegistryProvider, EndpointRandomizer endpointRandomizer) { this.applicationInfoManager = applicationInfoManager; InstanceInfo myInfo = applicationInfoManager.getInfo(); clientConfig = config; staticClientConfig = clientConfig; transportConfig = config.getTransportConfig(); instanceInfo = myInfo; ...省略部分代码 try { // default size of 2 - 1 each for heartbeat and cacheRefresh scheduler = Executors.newScheduledThreadPool(2, new ThreadFactoryBuilder() .setNameFormat(\"DiscoveryClient-%d\") .setDaemon(true) .build()); heartbeatExecutor = new ThreadPoolExecutor( 1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue(), new ThreadFactoryBuilder() .setNameFormat(\"DiscoveryClient-HeartbeatExecutor-%d\") .setDaemon(true) .build() ); // use direct handoff cacheRefreshExecutor = new ThreadPoolExecutor( 1, clientConfig.getCacheRefreshExecutorThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue(), new ThreadFactoryBuilder() .setNameFormat(\"DiscoveryClient-CacheRefreshExecutor-%d\") .setDaemon(true) .build() ); // use direct handoff eurekaTransport = new EurekaTransport(); scheduleServerEndpointTask(eurekaTransport, args); AzToRegionMapper azToRegionMapper; if (clientConfig.shouldUseDnsForFetchingServiceUrls()) { azToRegionMapper = new DNSBasedAzToRegionMapper(clientConfig); } else { azToRegionMapper = new PropertyBasedAzToRegionMapper(clientConfig); } if (null != remoteRegionsToFetch.get()) { azToRegionMapper.setRegionsToFetch(remoteRegionsToFetch.get().split(\",\")); } instanceRegionChecker = new InstanceRegionChecker(azToRegionMapper, clientConfig.getRegion()); } catch (Throwable e) { throw new RuntimeException(\"Failed to initialize DiscoveryClient!\", e); } // 关键代码：第1次发送/apps这个rest请求从eureka server获取所有的服务注册信息，并封装到Applications对象中，然后存储到localRegionApps这个属性中 if (clientConfig.shouldFetchRegistry() && !fetchRegistry(false)) { fetchRegistryFromBackup(); } // 在所有的后台 任务启动前调用并执行前置注册处理器 if (this.preRegistrationHandler != null) { this.preRegistrationHandler.beforeRegistration(); } // 是否应该将自己注册到eureka server中，并且强制在初始化的时候注册，默认false，不会进入if中 if (clientConfig.shouldRegisterWithEureka() && clientConfig.shouldEnforceRegistrationAtInit()) { try { if (!register() ) { throw new IllegalStateException(\"Registration error at startup. Invalid server response.\"); } } catch (Throwable th) { logger.error(\"Registration error at startup: {}\", th.getMessage()); throw new IllegalStateException(th); } } // finally, init the schedule tasks (e.g. cluster resolvers, heartbeat, instanceInfo replicator, fetch // 关键代码：初始化定时任务（比如：集群解析、心跳、实例信息复制、更新服务注册信息） initScheduledTasks(); // 将自己放到单例对象DiscoveryManager中，这样可以在任意位置很方便的获取EurekaClient的相关信息 DiscoveryManager.getInstance().setDiscoveryClient(this); // 存储客户端配置信息到DiscoveryManager中 DiscoveryManager.getInstance().setEurekaClientConfig(config); } /** * 服务注册实现 */ boolean register() throws Throwable { EurekaHttpResponse httpResponse; try { httpResponse = eurekaTransport.registrationClient.register(instanceInfo); } catch (Exception e) { logger.warn(PREFIX + \"{} - registration failed {}\", appPathIdentifier, e.getMessage(), e); throw e; } } /** * 发送/apps请求到eureka server获取所有服务注册信息，并存储到localRegionApps属性中 * 在第一次调用时会获取全部的服务注册信息，以后调用该方法只会获取增量的服务注册信息 */ private boolean fetchRegistry(boolean forceFullRegistryFetch) { Applications applications = getApplications(); if (clientConfig.shouldDisableDelta() // 是否禁用增量获取 || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress())) || forceFullRegistryFetch // 是否强制刷新，获取全量的服务注册信息 || (applications == null) // 是否已经获取过服务注册信息 || (applications.getRegisteredApplications().size() == 0) || (applications.getVersion() == -1)) { // 没有获取过 // 获取全量的服务注册信息 getAndStoreFullRegistry(); } else { //获取增量的服务注册信息 getAndUpdateDelta(applications); } ...省略部分代码 } /** * 服务发现： * * 发送/apps请求到eureka server全量获取所有服务注册信息，并存储到localRegionApps属性中 */ private void getAndStoreFullRegistry() throws Throwable { Applications apps = null; EurekaHttpResponse httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == null // 真正发送/apps请求获取服务注册信息 ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get()) : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get()); if (httpResponse.getStatusCode() == Status.OK.getStatusCode()) { apps = httpResponse.getEntity(); } if (apps == null) { logger.error(\"The application is null for some reason. Not storing this information\"); } else if (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) { // 1、 filterAndShuffle方法返回的Applications对象中除了维护全部的服务注册信息集合外， // 这里还通过过滤操作维护了一个服务状态正常的服务注册信息集合 // 2、将Applications对象存储到localRegionApps属性中 localRegionApps.set(this.filterAndShuffle(apps)); logger.debug(\"Got full registry with apps hashcode {}\", apps.getAppsHashCode()); } else { logger.warn(\"Not updating applications as another thread is updating it already\"); } } /** * 返回localRegionApps属性中保存的服务注册信息 */ @Override public Applications getApplications() { return localRegionApps.get(); } /** * 初始化所有的定时任务 */ private void initScheduledTasks() { // 是否需要从eureka server获取服务注册信息 if (clientConfig.shouldFetchRegistry()) { // registry cache refresh timer int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds(); int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound(); // 启动定时任务， 获取服务注册信息 scheduler.schedule( new TimedSupervisorTask( \"cacheRefresh\", scheduler, cacheRefreshExecutor, registryFetchIntervalSeconds, TimeUnit.SECONDS, expBackOffBound, // 获取服务注册信息的任务 new CacheRefreshThread() ), registryFetchIntervalSeconds, TimeUnit.SECONDS); } // 是否应该将自己注册到eureka server上，如果需要则启动心跳线程向服务端发送/renew请求进行续约 if (clientConfig.shouldRegisterWithEureka()) { int renewalIntervalInSecs = instanceInfo.getLeaseInfo().getRenewalIntervalInSecs(); int expBackOffBound = clientConfig.getHeartbeatExecutorExponentialBackOffBound(); logger.info(\"Starting heartbeat executor: \" + \"renew interval is: {}\", renewalIntervalInSecs); // 启动心跳定时任务 scheduler.schedule( new TimedSupervisorTask( \"heartbeat\", scheduler, heartbeatExecutor, renewalIntervalInSecs, TimeUnit.SECONDS, expBackOffBound, // 发送/renew请求的任务 new HeartbeatThread() ), renewalIntervalInSecs, TimeUnit.SECONDS); // 上报自身信息到eureka server的定时任务， 它实现了Runnable接口 instanceInfoReplicator = new InstanceInfoReplicator( this, instanceInfo, clientConfig.getInstanceInfoReplicationIntervalSeconds(), 2); // burstSize // 监听本地实例状态变更（如由UP变为DOWN状态） statusChangeListener = new ApplicationInfoManager.StatusChangeListener() { @Override public String getId() { return \"statusChangeListener\"; } @Override public void notify(StatusChangeEvent statusChangeEvent) { if (InstanceStatus.DOWN == statusChangeEvent.getStatus() || InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) { // log at warn level if DOWN was involved logger.warn(\"Saw local status change event {}\", statusChangeEvent); } else { logger.info(\"Saw local status change event {}\", statusChangeEvent); } // 实例自身状态发生变更，立即注册实例信息到eureka server instanceInfoReplicator.onDemandUpdate(); } }; if (clientConfig.shouldOnDemandUpdateStatusChange()) { // 注册实例状态变更监听器， 在com.netflix.appinfo.ApplicationInfoManager#setInstanceStatus中发布了该事件 applicationInfoManager.registerStatusChangeListener(statusChangeListener); } // 内部会使用Future next = scheduler.schedule(this, initialDelayMs, TimeUnit.SECONDS);启动当前定时任务 instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds()); } else { logger.info(\"Not registering with Eureka server per configuration\"); } } @VisibleForTesting void refreshRegistry() { try { ...省略部分代码 // 重新从eureka server获取服务注册列表 boolean success = fetchRegistry(remoteRegionsModified); if (success) { registrySize = localRegionApps.get().size(); lastSuccessfulRegistryFetchTimestamp = System.currentTimeMillis(); } } catch (Throwable e) { logger.error(\"Cannot fetch registry from server\", e); } ｝ /** * 用于服务注册定时任务，见com.netflix.discovery.InstanceInfoReplicator#run * 该方法会重新获取本地配置信息变化，如果变化了会调用com.netflix.appinfo.InstanceInfo#setIsDirty() * 将实例状态设置已变更脏数据状态，以便InstanceInfoReplicator任务感知到实例状态变化将心的实例信息注册到eureka server */ void refreshInstanceInfo() { // 刷新hostname、ipAddress变更信息 applicationInfoManager.refreshDataCenterInfoIfRequired(); // 刷新租约配置变更（leaseExpirationDurationInSeconds、leaseRenewalIntervalInSeconds） applicationInfoManager.refreshLeaseInfoIfRequired(); ...省略部分代码 ｝ /** * 从eureka server刷新服务注册信息的线程 */ class CacheRefreshThread implements Runnable { public void run() { refreshRegistry(); } } /** * 心跳线程任务 */ private class HeartbeatThread implements Runnable { public void run() { if (renew()) { lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis(); } } }} InstanceInfoReplicator InstanceInfoReplicator是个任务类，负责将自身的信息周期性的上报到Eureka server； 有两个场景触发上报：周期性任务、服务状态变化(onDemandUpdate被调用)，因此，在同一时刻有可能有两个上报的任务同时出现； 单线程执行上报的操作，如果有多个上报任务，也能确保是串行的； 有频率限制，通过burstSize参数来控制； 先创建的任务总是先执行，但是onDemandUpdate方法中创建的任务会将周期性任务给丢弃掉；java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/*** 用于更新本地instanceinfo并将其复制到远程服务器的任务。这个任务的属性是:* 1. 使用单个更新线程进行配置，以确保对远程服务器进行连续更新* 2. 可以通过onDemandUpdate()按需调度更新任务* 3. 任务处理的速率受到burstSize的限制* 4. 新的更新任务总是在较早的更新任务之后自动调度。但是，如果启动了随需应变任务，* 则会丢弃调度的自动更新任务(并在* 新的随需应变更新之后调度新的自动更新任务)。*/class InstanceInfoReplicator implements Runnable { private final DiscoveryClient discoveryClient; private final InstanceInfo instanceInfo; private final int replicationIntervalSeconds; private final ScheduledExecutorService scheduler; private final AtomicReference scheduledPeriodicRef; private final AtomicBoolean started; private final RateLimiter rateLimiter; private final int burstSize; private final int allowedRatePerMinute; InstanceInfoReplicator(DiscoveryClient discoveryClient, InstanceInfo instanceInfo, int replicationIntervalSeconds, int burstSize) { this.discoveryClient = discoveryClient; this.instanceInfo = instanceInfo; //线程池，core size为1，使用DelayedWorkQueue队列 this.scheduler = Executors.newScheduledThreadPool(1, new ThreadFactoryBuilder() .setNameFormat(\"DiscoveryClient-InstanceInfoReplicator-%d\") .setDaemon(true) .build()); this.scheduledPeriodicRef = new AtomicReference(); this.started = new AtomicBoolean(false); this.rateLimiter = new RateLimiter(TimeUnit.MINUTES); this.replicationIntervalSeconds = replicationIntervalSeconds; this.burstSize = burstSize; //通过周期间隔，和burstSize参数，计算每分钟允许的任务数 this.allowedRatePerMinute = 60 * this.burstSize / this.replicationIntervalSeconds; } /** * 启动定时任务（通过scheduledPeriodicRef持有的引用可以获得启动的任务，并可以取消该定时任务） */ public void start(int initialDelayMs) { if (started.compareAndSet(false, true)) { // cas更新设置为为已启用状态 /** * setIsDirty()方法的作用是：设置脏标志，以便在下一次心跳时将实例信息传送到发现服务器，com.netflix.appinfo.InstanceInfo#setIsDirty()内部代码为： * * isInstanceInfoDirty = true; * lastDirtyTimestamp = System.currentTimeMillis(); */ // 这里是为了启动后立即将实例信息上报到eureka server instanceInfo.setIsDirty(); // 启动定时任务， 执行run方法中的逻辑 Future next = scheduler.schedule(this, initialDelayMs, TimeUnit.SECONDS); // 持有启动的任务，后续可以获得该任务然后调用其cancel方法取消执行 scheduledPeriodicRef.set(next); } } /** * com.netflix.discovery.DiscoveryClient#initScheduledTasks类中的statusChangeListener实例状态事件监听器中的notify放啊会调用该方法，当实例状态发生变化时立即同步（取消定时未完成的任务）实例信息到eureka server */ public boolean onDemandUpdate() { // 没有达到频率限制才会执行 if (rateLimiter.acquire(burstSize, allowedRatePerMinute)) { if (!scheduler.isShutdown()) { //提交一个任务 scheduler.submit(new Runnable() { @Override public void run() { logger.debug(\"Executing on-demand update of local InstanceInfo\"); // 获取正在执行的定时任务 Future latestPeriodic = scheduledPeriodicRef.get(); // 如果当前定时任务启动了，但是还没有执行完成，则立即取消任务 if (latestPeriodic != null && !latestPeriodic.isDone()) { logger.debug(\"Canceling the latest scheduled update, it will be rescheduled at the end of on demand update\"); // 取消本次正在执行的定时任务（仅仅是取消本次任务，下一个任务周期到了仍然会继续执行） latestPeriodic.cancel(false); } // 直接调用run方法将变更的实例信息注册到eureka server InstanceInfoReplicator.this.run(); } }); return true; } else { //如果超过了设置的频率限制，本次onDemandUpdate方法就提交任务了 logger.warn(\"Ignoring onDemand update due to stopped scheduler\"); return false; } } else { logger.warn(\"Ignoring onDemand update due to rate limiter\"); return false; } } /** * 关键代码：将服务信息注册到eureka server的实现 */ public void run() { try { // 刷新本地实例配置信息，如果本地配置信息发生了变化则调用com.netflix.appinfo.InstanceInfo#setIsDirty()将当前实例状态改为脏数据状态，以便下一步判断是否发生实例状态变化将实例信息注册到服务端 discoveryClient.refreshInstanceInfo(); // 当前任务启动时start()方法会将实例信息状态设置为脏数据状态 // 判断实例信息是否发生变化 Long dirtyTimestamp = instanceInfo.isDirtyWithTime(); if (dirtyTimestamp != null) { // 关键代码：服务注册，将实例信息注册到eureka server discoveryClient.register(); // 清除脏数据状态 instanceInfo.unsetIsDirty(dirtyTimestamp); } } catch (Throwable t) { logger.warn(\"There was a problem with the instance info replicator\", t); } finally { Future next = scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS); scheduledPeriodicRef.set(next); } }} EurekaDiscoveryClientConfiguration （DiscoveryClient自动化配置） spring cloud commons与eureka集成的自动化配置核心类 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Configuration(proxyBeanMethods = false)@EnableConfigurationProperties@ConditionalOnClass(EurekaClientConfig.class)@ConditionalOnProperty(value = \"eureka.client.enabled\", matchIfMissing = true)@ConditionalOnDiscoveryEnabled@ConditionalOnBlockingDiscoveryEnabledpublic class EurekaDiscoveryClientConfiguration { /** * 最最关键的配置：服务发现的具体实现bean（spring cloud commons项目中DiscoveryClient的具体实现） * 这里注入的EurekaClient和EurekaClientConfig参数都是在EurekaClientAutoConfiguration中实例化bean的， * * 该类的作用是适配spring cloud commons中的DiscoveryClient与eureka， 起到一个桥梁作用， * 本身EurekaDiscoveryClient中的代码非常简洁，都是调用了netflix自身的EurekaClient, 所有关键的服务发现、 * 服务注册、心跳都是在EurekaClient的构造方法中实现的（启用了一系列的定时任务、注册服务状态变更监听器） */ @Bean @ConditionalOnMissingBean public EurekaDiscoveryClient discoveryClient(EurekaClient client, EurekaClientConfig clientConfig) { return new EurekaDiscoveryClient(client, clientConfig); } /** * 监听了RefreshScopeRefreshedEvent事件 */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass(RefreshScopeRefreshedEvent.class) protected static class EurekaClientConfigurationRefresher implements ApplicationListener { /** * netflix原生的服务注册、获取服务列表等操作实现 */ @Autowired(required = false) private EurekaClient eurekaClient; /** * 进行实例自动注册到注册中心的处理逻辑实现（spring cloud commons项目AutoServiceRegistration的实现） */ @Autowired(required = false) private EurekaAutoServiceRegistration autoRegistration; public void onApplicationEvent(RefreshScopeRefreshedEvent event) { // This will force the creation of the EurkaClient bean if not already created // to make sure the client will be reregistered after a refresh event if (eurekaClient != null) { eurekaClient.getApplications(); } if (autoRegistration != null) { // register in case meta data changed this.autoRegistration.stop(); this.autoRegistration.start(); } } }} EurekaRegistration 实例信息， Registration的实现 实现了spring cloud commons项目中的Registration接口，代表要注册的实例信息 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class EurekaRegistration implements Registration { private final EurekaClient eurekaClient; private final AtomicReference cloudEurekaClient = new AtomicReference(); private final CloudEurekaInstanceConfig instanceConfig; private final ApplicationInfoManager applicationInfoManager; private ObjectProvider healthCheckHandler; /** * 获取实例id, 通过调用instanceConfig实现 * 由EurekaClientAutoConfiguration中的EurekaInstanceConfigBean实例化设置的默认值为 * ${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id}或${server.port} */ @Override public String getInstanceId() { return this.instanceConfig.getInstanceId(); } /** * 获取服务id, 通过调用instanceConfig实现，值为${spring.application.name} * 来源于org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean#setEnvironment中的setAppname方法 */ @Override public String getServiceId() { return this.instanceConfig.getAppname(); } /** * 获取实例主机名，来源于EurekaInstanceConfigBean的构造方法中的this.hostname = this.hostInfo.getHostname();赋的值 */ @Override public String getHost() { return this.instanceConfig.getHostName(false); } /** * 获取实例端口号，来源于org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration#eurekaInstanceConfigBean中的instance.setNonSecurePort(serverPort); */ @Override public int getPort() { if (this.instanceConfig.getSecurePortEnabled()) { return this.instanceConfig.getSecurePort(); } return this.instanceConfig.getNonSecurePort(); } /** * 是否安全连接，来源类同上，由instance.setSecurePortEnabled(isSecurePortEnabled);方法设置值的 */ @Override public boolean isSecure() { return this.instanceConfig.getSecurePortEnabled(); } /** * 调用的是spring cloud commons项目中方法 * String uri = String.format(\"%s://%s:%s\", scheme, instance.getHost(), instance.getPort()); */ @Override public URI getUri() { return DefaultServiceInstance.getUri(this); } @Override public Map getMetadata() { return this.instanceConfig.getMetadataMap(); }} 总结spring-cloud-nextflix-eureka-client启动流程： @EnableDiscoveryClient引入EnableDiscoveryClientImportSelector spring-cloud-netflix-eureka-client-2.2.0.RELEASE.jar!\\META-INF\\spring.factories中会自动化配置EurekaClientConfigServerAutoConfiguration、EurekaDiscoveryClientConfigServiceAutoConfiguration、EurekaClientAutoConfiguration、EurekaDiscoveryClientConfiguration、RibbonEurekaAutoConfiguration等几个类 EurekaClientAutoConfiguration 会实例化如下几个类： EurekaInstanceConfigBean读取application.yml中eureka.instance为前缀的配置 EurekaServiceRegistryspring cloud commons项目ServiceRegisity接口的实现 EurekaAutoServiceRegistrationspring cloud commons项目AutoServiceRegistration接口的实现 EurekaClientnetfliex的服务发现、服务注册、心跳实现，构造方法中会发送第一次rest请求，全量获取所有服务注册信息，然后启动一系列定时任务（心跳、刷新服务发现信息、实例状态变化时注册注册实例信息） ApplicationInfoManager持有实例信息 EurekaRegistrationspring cloud commons项目Registration接口的实现","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/tags/spring-cloud/"}]},{"title":"feign使用教程","slug":"feign使用教程","date":"2019-12-29T08:37:44.000Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2019/12/29/feign使用教程/","link":"","permalink":"https://calebzhao.github.io/2019/12/29/feign%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"简介Feign是一款java的Restful客户端组件，Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于Retrofit, JAXRS-2.0和WebSocket。Feign 最初是为了降低统一绑定Denominator 到 HTTP API 的复杂度，不区分是否支持 ReSTfulness。 为什么选择Feign而不是其他你可以使用 Jersey 和 CXF 这些来写一个 Rest 或 SOAP 服务的java客服端。你也可以直接使用 Apache HttpClient 来实现。但是 Feign 的目的是尽量的减少资源和代码来实现和 HTTP API 的连接。通过自定义的编码解码器以及错误处理，你可以编写任何基于文本的 HTTP API。 Feign工作机制Feign 通过注解注入一个模板化请求进行工作。只需在发送之前关闭它，参数就可以被直接的运用到模板中。然而这也限制了 Feign，只支持文本形式的API，它在响应请求等方面极大的简化了系统。同时，它也是十分容易进行单元测试的。 基本用法基本的使用如下所示，一个对于canonical Retrofit sample的适配。 java1234567891011121314151617181920212223242526272829303132333435interface GitHub { @RequestLine(\"GET /repos/{owner}/{repo}/contributors\") List contributors(@Param(\"owner\") String owner, @Param(\"repo\") String repo); @RequestLine(\"POST /repos/{owner}/{repo}/issues\") void createIssue(Issue issue, @Param(\"owner\") String owner, @Param(\"repo\") String repo);}public static class Contributor { String login; int contributions;}public static class Issue { String title; String body; List assignees; int milestone; List labels;}public class MyApp { public static void main(String... args) { GitHub github = Feign.builder() .decoder(new GsonDecoder()) .target(GitHub.class, \"https://api.github.com\"); // Fetch and print a list of the contributors to this library. List contributors = github.contributors(\"OpenFeign\", \"feign\"); for (Contributor contributor : contributors) { System.out.println(contributor.login + \" (\" + contributor.contributions + \")\"); } }} 注解 Annotation Target Usage @RequestLine Method 为请求定义HttpMethod 以及UriTemplate，被{expression}包裹的表达式可以通过方法上的@Param注解解析为真实的值 @Param Parameter 定义一个模板变量的值，其值通过用于在解析模板表达式变量时使用，如果该注解在模板表达式中被使用到了，则不会作为form表单提交参数，否则作为表单提交参数 @Headers Method， Type 定义HeaderTemplate， 是定义HeaderTemplate的一种变种，使用@Param注解的值来解析@Headers注解中对应的表达式， 当该注解被使用在类上时，该模板将被应用于所有的方法上， 注解被用在方法上时，该模板只会在被该注解标识的方法上生效 @QueryMap Parameter 定义了key-value键值对的Map对象或者 POJO，以扩展成查询字符串 @HeaderMap Parameter 定义了key-value键值对的Map对象，以扩展到Http Header @Body Method 定义1个模板,该模板类似于UriTemplate 或HeaderTemplate，使用@Params注解的值来解析@Body注解中对应的的表达式 重写请求行当Feign被创建时如果需要将一个请求发送到不同的主机，就需要提供它，或者你想为每个请求提供一个目标主机，包含一个 java.net.URI参数，Feign 将使用这个值作为请求目标。 java12@RequestLine(\"POST /repos/{owner}/{repo}/issues\")void createIssue(URI host, Issue issue, @Param(\"owner\") String owner, @Param(\"repo\") String repo); 模板和表达式(Template And Expression)Feign 表达式由 URI 模板 -RFC 6570定义的简单字符串表达式(级别1)所表示。 表达式使用其相应的 带有Param 注解的方法参数展开。 例子 java12345678910111213141516171819202122232425public interface GitHub { @RequestLine(\"GET /repos/{owner}/{repo}/contributors\") List contributors(@Param(\"owner\") String owner, @Param(\"repo\") String repository); class Contributor { String login; int contributions; }}public class MyApp { public static void main(String[] args) { GitHub github = Feign.builder() .decoder(new GsonDecoder()) .target(GitHub.class, \"https://api.github.com\"); /* The owner and repository parameters will be used to expand the owner and repo expressions * defined in the RequestLine. * * the resulting uri will be https://api.github.com/repos/OpenFeign/feign/contributors */ github.contributors(\"OpenFeign\", \"feign\"); }} 表达式必须用大括号{}括起来，可以包含正则表达式模式，中间用冒号分隔: 以限制解析值。 示例owner必须按字母顺序排列。 { owner: [ a-zA-Z ] * } 请求参数展开Code和 ```@QueryMap``` 模板遵循一级模板的[URITemplate-RFC 6570](https://tools.ietf.org/html/rfc6570 \"URITemplate-RFC 6570\")规范，它指定了以下内容:12345678910111213- 省略未解析的表达式- 如果尚未通过```@Param```注解对所有文字和变量值进行编码或标记为已编码，则所有文字和变量值均经过pct编码。# 未定义 vs 空值(Undefined vs Empty)未定义表达式是指表达式的值为显式```null```或未提供任何值(```\"\"```)的表达式。 根据[URITemplate-RFC 6570](https://tools.ietf.org/html/rfc6570 \"URITemplate-RFC 6570\")，可以为表达式提供一个空值。当 Feign 解析一个表达式时，它首先确定该值是否已定义，如果已定义，那么将保留该查询参数。 如果未定义，则删除该查询参数。 有关完整的细节，请参见下文。- 空字符串(Empty String)```javapublic void test() { Map parameters = new LinkedHashMap(); parameters.put(\"param\", \"\"); this.demoClient.test(parameters);} 结果 Code1http://localhost:8080/test?param= 没有值(Missing)java1234public void test() { Map parameters = new LinkedHashMap(); this.demoClient.test(parameters);} 结果Code1http://localhost:8080/test 未定义的(Undefined)java12345public void test() { Map parameters = new LinkedHashMap(); parameters.put(\"param\", null); this.demoClient.test(parameters);} 结果Code1http://localhost:8080/test 更多示例请参见高级用法。 斜杠(/)呢?默认情况下,@requestline 和@querymap 模板不编码斜杠 / 字符。 若要更改此行为，请将@requestline 上的 decodeSlash 属性设置为 false。 加号(+)呢？根据 URI 规范，URI 的路径和查询片段中都允许使用 + 符号，但是查询上的符号处理可能不一致。 在一些遗留系统中，+ 等价于一个空格。 Feign 采用了现代系统的方式来处理，在现代系统中，一个 + 符号不应该表示一个空格，当在一个查询字符串中找到+时，它被显式地编码为%2B如果您希望使用 + 作为空格，那么可以使用文本字符或直接将值编码为%2B 定制请求参数展开(Expander)Code注解有一个可选的属性扩展器，允许对单个参数的扩展进行完全控制。 ```expander``` 属性必须引用一个```Expander``` 接口的实现类:1234```javapublic interface Expander { String expand(Object value);} 此方法的结果遵循上述相的规则。如果结果为 null 或空字符串(\"\")，则省略该值。 如果值没有经过 pct 编码，那么也会像上面的规则那样做。 更多示例请参见 自定义@Param扩展。 请求头(Header)展开Code和 ```HeaderMap``` 模板遵循与 [请求参数扩展](https://github.com/OpenFeign/feign#request-parameter-expansion \"请求参数扩展\") 相同的规则，但有以下修改:12345678910111213- 省略未解析的表达式。 如果header的结果为空值，则删除整个header- 未执行 pct 编码有关示例，请参阅[Headers](https://github.com/OpenFeign/feign#headers \"Headers\")。> #### 关于```@Param``` 参数及其名称的说明: > 所有名称相同的表达式，不管它们在@requestline、@querymap、@bodytemplate 或@headers 上的位置如何，都将解析为相同的值。 在下面的示例中，contentType 的值将用于解析头部和路径表达式:> ```java> public interface ContentService {> @RequestLine(\"GET /api/documents/{contentType}\")> @Headers(\"Accept: {contentType}\")> String getDocumentByType(@Param(\"contentType\") String type);> }> 在设计接口时要牢记这一点。 请求体(Body)展开请求体(Body)模板遵循与请求参数展开相同的规则，具有以下修改: 省略未解析的表达式 展开的值在放到请求正文之前不会通过Encoder 编码器传值 必须指定Content-Type请求头，实例请参阅 请求体模板 自定义Feign 有许多可以自定义的方面。举个简单的例子，你可以使用 Feign.builder() 来构造一个拥有你自己组件的API接口。如下: 1234567interface Bank { @RequestLine(\"POST /account/{id}\") Account getAccountInfo(@Param(\"id\") String id);}...// AccountDecoder 是自己实现的一个DecoderBank bank = Feign.builder().decoder(new AccountDecoder()).target(Bank.class, \"https://api.examplebank.com\"); 多种接口Feign可以提供多种API接口，这些接口都被定义为Target(默认的实现是 HardCodedTarget), 它允许在执行请求前动态发现和装饰该请求。 举个例子，下面的这个模式允许使用当前url和身份验证token来装饰每个发往身份验证中心服务的请求。 java1CloudDNS cloudDNS = Feign.builder().target(new CloudIdentityTarget(user, apiKey)); 示例Code包含了[GitHub](https://github.com/OpenFeign/feign/blob/master/example-github \"GitHub\") 和 [Wikipedia](https://github.com/OpenFeign/feign/blob/master/example-wikipedia \"Wikipedia\") 客户端的实现样例.相似的项目也同样在实践中运用了Feign。尤其是它的示例后台程序[example daemon](https://github.com/Netflix/denominator/tree/master/example-daemon \"example daemon\")。12345678910111213# Feign集成模块Feign 可以和其他的开源工具集成工作。你可以将这些开源工具集成到 Feign 中来。目前已经有的一些模块如下:# GsonGson 包含了一个编码器和一个解码器，这个可以被用于JSON格式的API。添加 ```GsonEncoder``` 以及 ```GsonDecoder``` 到你的 ```Feign.Builder``` 中， 如下:```javaGsonCodec codec = new GsonCodec();GitHub github = Feign.builder() .encoder(new GsonEncoder()) .decoder(new GsonDecoder()) .target(GitHub.class, \"https://api.github.com\"); JacksonJackson 包含了一个编码器和一个解码器，这个可以被用于JSON格式的API。添加 JacksonEncoder 以及 JacksonDecoder 到你的 Feign.Builder 中， 如下: 1234GitHub github = Feign.builder() .encoder(new JacksonEncoder()) .decoder(new JacksonDecoder()) .target(GitHub.class, \"https://api.github.com\"); Maven依赖: xml123456 com.netflix.feigngroupId> feign-jacksonartifactId> 8.18.0version>dependency> SaxCode用于解析XML,并兼容普通JVM和Android。下面是一个配置sax来解析响应的例子:123456```javaapi = Feign.builder() .decoder(SAXDecoder.builder() .registerContentHandler(UserIdHandler.class) .build()) .target(Api.class, \"https://apihost\"); Maven依赖: xml12345 com.netflix.feigngroupId> feign-saxartifactId> 8.18.0version>dependency> JAXBJAXB 包含了一个编码器和一个解码器，这个可以被用于XML格式的API。添加 JAXBEncoder 以及 JAXBDecoder 到你的 Feign.Builder 中， 如下: 1234api = Feign.builder() .encoder(new JAXBEncoder()) .decoder(new JAXBDecoder()) .target(Api.class, \"https://apihost\"); Maven依赖: xml123456 com.netflix.feigngroupId> feign-jaxbartifactId> 8.18.0version>dependency> JAX-RSJAXRSContract 使用 JAX-RS 规范重写覆盖了默认的注解处理。下面是一个使用 JAX-RS 的例子: 12345678interface GitHub { [@GET](https://my.oschina.net/get) @Path(\"/repos/{owner}/{repo}/contributors\") List contributors(@PathParam(\"owner\") String owner, @PathParam(\"repo\") String repo);}GitHub github = Feign.builder() .contract(new JAXRSContract()) .target(GitHub.class, \"https://api.github.com\"); Maven依赖: xml123456 com.netflix.feigngroupId> feign-jaxrsartifactId> 8.18.0version>dependency> OkHttpCode使用 OkHttp 来发送 Feign 的请求，OkHttp 支持 SPDY (SPDY是Google开发的基于TCP的传输层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验),并有更好的控制http请求。123456要让 Feign 使用 OkHttp ，你需要将 OkHttp 加入到你的环境变量中区，然后配置 ```Feign``` 使用 ```OkHttpClient```，如下:```javaGitHub github = Feign.builder() .client(new OkHttpClient()) .target(GitHub.class, \"https://api.github.com\"); Maven依赖: xml123456 com.netflix.feigngroupId> feign-okhttpartifactId> 8.18.0version>dependency> RibbonCode重写了 Feign 客户端的对URL的处理，其添加了 智能路由以及一些其他由Ribbon提供的弹性功能。1集成Ribbon需要你将ribbon的客户端名称当做url的host部分来传递，如下： // myAppProd是你的ribbon client nameMyService api = Feign.builder().client(RibbonClient.create()).target(MyService.class, “","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/tags/spring-cloud/"},{"name":"feign","slug":"feign","permalink":"https://calebzhao.github.io/tags/feign/"}]},{"title":"Feign源码学习","slug":"Feign源码学习","date":"2019-12-29T08:37:10.000Z","updated":"2020-01-10T04:43:18.135Z","comments":true,"path":"2019/12/29/Feign源码学习/","link":"","permalink":"https://calebzhao.github.io/2019/12/29/Feign%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"feign介绍Feign是一款java的Restful客户端组件，Feign使得 Java HTTP 客户端编写更方便。Feign 灵感来源于Retrofit, JAXRS-2.0和WebSocket。feign在github上有近5K个star，是一款相当优秀的开源组件，虽然相比Retrofit的近30K个star，逊色了太多，但是spring cloud集成了feign，使得feign在java生态中比Retrofit使用的更加广泛。 feign的基本原理是在接口方法上加注解，定义rest请求，构造出接口的动态代理对象，然后通过调用接口方法就可以发送http请求，并且自动解析http响应为方法返回值，极大的简化了客户端调用rest api的代码。官网的示例如下： Code123456789101112131415161718192021 interface GitHub { @RequestLine(\"GET /repos/{owner}/{repo}/contributors\") List contributors(@Param(\"owner\") String owner, @Param(\"repo\") String repo);}static class Contributor { String login; int contributions;}public static void main(String... args) { GitHub github = Feign.builder() .decoder(new GsonDecoder()) .target(GitHub.class, \"https://api.github.com\"); // Fetch and print a list of the contributors to this library. List contributors = github.contributors(\"OpenFeign\", \"feign\"); for (Contributor contributor : contributors) { System.out.println(contributor.login + \" (\" + contributor.contributions + \")\"); }} feign使用教程请参考官网https://github.com/OpenFeign/feign/ 本文主要是对feign源码进行分析，根据源码来理解feign的设计架构和内部实现技术。 Feign.build构建接口动态代理我们先来看看接口的动态代理是如何构建出来的，下图是主要接口和类的类图： 从上文中的示例可以看到，构建的接口动态代理对象是通过Feign.builder()生成Feign.Builder的构造者对象，然后设置相关的参数，再调用target方法构造的。Feign.Builder的参数包括： java12345678910111213141516171819202122232425262728293031323334353637383940414243//拦截器，组装完RequestTemplate，发请求之前的拦截处理RequestTemplateprivate final List requestInterceptors = new ArrayList();//日志级别private Logger.Level logLevel = Logger.Level.NONE;//契约模型，默认为Contract.Default，用户创建MethodMetadata，用spring cloud就是扩展这个实现springMVC注解private Contract contract = new Contract.Default();//客户端，默认为Client.Default，可以扩展ApacheHttpClient，OKHttpClient，RibbonClient等private Client client = new Client.Default(null, null);//重试设置，默认不设置private Retryer retryer = new Retryer.Default();//日志，可以接入Slf4jprivate Logger logger = new NoOpLogger();//编码器，用于body的编码private Encoder encoder = new Encoder.Default();//解码器，用户response的解码private Decoder decoder = new Decoder.Default();//用@QueryMap注解的参数编码器private QueryMapEncoder queryMapEncoder = new QueryMapEncoder.Default();//请求错误解码器private ErrorDecoder errorDecoder = new ErrorDecoder.Default();//参数配置，主要是超时时间之类的private Options options = new Options();//动态代理工厂private InvocationHandlerFactory invocationHandlerFactory = new InvocationHandlerFactory.Default();//是否decode404private boolean decode404;private boolean closeAfterDecode = true;// 异常隔离策略private ExceptionPropagationPolicy propagationPolicy = NONE; 这块是一个典型的构造者模式，target方法内部先调用build方法新建一个ReflectFeign对象，然后调用ReflectFeign的newInstance方法创建动态代理，代码如下： java123456789101112131415161718192021222324252627282930313233//默认使用HardCodedTargetpublic T target(Class apiType, String url) { return target(new HardCodedTarget(apiType, url));}public T target(Target target) { return build().newInstance(target);}public Feign build() { SynchronousMethodHandler.Factory synchronousMethodHandlerFactory = new SynchronousMethodHandler.Factory( client, retryer, requestInterceptors, logger, logLevel, decode404, closeAfterDecode); // 该类中持有的contract非常重要（对接口及接口的方法上的注解解析） ParseHandlersByName handlersByName = new ParseHandlersByName(contract, options, encoder, decoder, queryMapEncoder, errorDecoder, synchronousMethodHandlerFactory); // handlersByName将所有参数进行封装，并提供解析接口方法的逻辑 // invocationHandlerFactory是Builder的属性，默认值是InvocationHandlerFactory.Default // 用创建java动态代理的InvocationHandler实现 return new ReflectiveFeign(handlersByName, invocationHandlerFactory, queryMapEncoder);} ReflectiveFeign构造函数有三个参数： ParseHandlersByName将builder所有参数进行封装，并提供解析接口方法的逻辑 InvocationHandlerFactory java动态代理的InvocationHandler的工厂类，默认值是InvocationHandlerFactory.Default QueryMapEncoder 接口参数注解@QueryMap时，参数的编码器 ReflectiveFeign.newInstance方法创建接口动态代理对象： java1234567891011121314151617181920212223242526272829303132public T newInstance(Target target) { //targetToHandlersByName是构造器传入的ParseHandlersByName对象，根据target对象生成MethodHandler映射 // 这里的MethodHandler的具体类型是在targetToHandlersByName.apply方法中使用工厂 // SynchronousMethodHandler.Factory创建的SynchronousMethodHandler Map nameToHandler = targetToHandlersByName.apply(target); Map methodToHandler = new LinkedHashMap(); List defaultMethodHandlers = new LinkedList(); //遍历接口所有方法，构建Method->MethodHandler的映射 for (Method method : target.type().getMethods()) { if (method.getDeclaringClass() == Object.class) { // Object类中的方法跳过 continue; } else if(Util.isDefault(method)) { //接口default方法的Handler，这类方法直接调用 DefaultMethodHandler handler = new DefaultMethodHandler(method); defaultMethodHandlers.add(handler); methodToHandler.put(method, handler); } else { methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method))); } } //这里factory是构造其中传入的，创建InvocationHandler InvocationHandler handler = factory.create(target, methodToHandler); //java的动态代理 T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), new Class[]{target.type()}, handler); //将default方法直接绑定到动态代理上 for(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) { // 用到了java7的MethodHandler、Lookup defaultMethodHandler.bindTo(proxy); } return proxy;} 这段代码主要的逻辑是： 创建MethodHandler的映射，这里创建的是实现类SynchronousMethodHandler 通过InvocationHandlerFatory创建InvocationHandler 绑定接口的default方法，通过DefaultMethodHandler绑定 类图中已经画出，SynchronousMethodHandler和DefaultMethodHandler实现了InvocationHandlerFactory.MethodHandler接口，动态代理对象调用方法时，如果是default方法，会直接调用接口方法，因为这里将接口的default方法绑定到动态代理对象上了，其他方法根据方法签名找到SynchronousMethodHandler对象，调用其invoke方法。 Feign.configKey(Class targetType, Method method)的实现源码： java12345678910111213141516171819202122/*** 例如User类中有 void list(Map map，int pageSize)将会生成User#list(User,int)签名* 例如User类中有 void list()将会生成User#list()签名*/public static String configKey(Class targetType, Method method) { StringBuilder builder = new StringBuilder(); // 拼接类名 builder.append(targetType.getSimpleName()); // 拼接#( builder.append('#').append(method.getName()).append('('); for (Type param : method.getGenericParameterTypes()) { param = Types.resolve(targetType, targetType, param); // 拼接参数类型及1个逗号，例如int, builder.append(Types.getRawType(param).getSimpleName()).append(','); } // 删除最后1个逗号 if (method.getParameterTypes().length > 0) { builder.deleteCharAt(builder.length() - 1); } //拼接反括号) return builder.append(')').toString();} TargetTarget源码如下： java123456789101112131415161718192021222324252627282930313233343536373839404142public interface Target { // api 接口类 Class type(); // 名称 String name(); // api接口路径的前缀地址(例如http://localhost:8080)， 发送请求时会用这个地址和@RequestLine中的url路径（/user/list） // 拼接在一起作为请求url(http://localhost:8080/user/list) String url(); public Request apply(RequestTemplate input); /** * Target的默认实现，什么也不做 */ public static class HardCodedTarget implements Target { private final Class type; private final String name; private final String url; public HardCodedTarget(Class type, String url) { // 可以看到这里name默认和url一样 this(type, url, url); } public HardCodedTarget(Class type, String name, String url) { this.type = checkNotNull(type, \"type\"); this.name = checkNotNull(emptyToNull(name), \"name\"); this.url = checkNotNull(emptyToNull(url), \"url\"); } @Override public Request apply(RequestTemplate input) { if (input.url().indexOf(\"http\") != 0) { input.target(url()); } return input.request(); } }} 创建MethodHandler方法处理器SynchronousMethodHandler是feign组件的核心，接口方法调用转换为http请求和解析http响应都是通过SynchronousMethodHandler来执行的，相关类图如下： 创建MethodHandler实现类ParseHandlersByName的代码： java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static final class ParseHandlersByName { private final Contract contract; private final Options options; private final Encoder encoder; private final Decoder decoder; private final ErrorDecoder errorDecoder; private final QueryMapEncoder queryMapEncoder; private final SynchronousMethodHandler.Factory factory; ParseHandlersByName( Contract contract, Options options, Encoder encoder, Decoder decoder, QueryMapEncoder queryMapEncoder, ErrorDecoder errorDecoder, SynchronousMethodHandler.Factory factory) { ...省略 } public Map apply(Target key) { //通过contract解析接口方法，生成MethodMetadata列表，默认的contract解析Feign自定义的http注解 List metadata = contract.parseAndValidatateMetadata(key.type()); Map result = new LinkedHashMap(); for (MethodMetadata md : metadata) { //BuildTemplateByResolvingArgs实现RequestTemplate.Factory，RequestTemplate的工厂 BuildTemplateByResolvingArgs buildTemplate; //根据方法元数据，使用不同的RequestTemplate的工厂 if (!md.formParams().isEmpty() && md.template().bodyTemplate() == null) { //如果有formParam，并且bodyTemplate不为空，请求体为x-www-form-urlencoded格式 //将会解析form参数，填充到bodyTemplate中 buildTemplate = new BuildFormEncodedTemplateFromArgs(md, encoder, queryMapEncoder); } else if (md.bodyIndex() != null) { //如果包含请求体，将会用encoder编码请求体对象 buildTemplate = new BuildEncodedTemplateFromArgs(md, encoder, queryMapEncoder); } else { //没有请求体，不需要编码器，使用默认的RequestTemplate的工厂 buildTemplate = new BuildTemplateByResolvingArgs(md, queryMapEncoder); } //使用工厂SynchronousMethodHandler.Factory创建SynchronousMethodHandler result.put(md.configKey(), factory.create(key, md, buildTemplate, options, decoder, errorDecoder)); } return result; }} 这段代码的逻辑是： 通过Contract解析接口方法，生成MethodMetadata，默认的Contract解析Feign自定义的http注解 根据MethodMetadata方法元数据生成特定的RequestTemplate的工厂 使用SynchronousMethodHandler.Factory工厂创建SynchronousMethodHandler 这里有两个工厂不要搞混淆了，SynchronousMethodHandler工厂和RequestTemplate```工厂，SynchronousMethodHandler的属性包含RequestTemplate`工厂 Contract解析接口方法生成MethodMetadatafeign默认的解析器是Contract.Default继承了Contract.BaseContract，解析生成MethodMetadata方法入口： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371public interface Contract { /** * 解析feign api 类上的所有方法元数据（feign默认是解析其自定义的注解， * spring cloud openfeign继承了feign的默认契约，同时支持spring mvc自己的@Requestmapping主键） */ List parseAndValidatateMetadata(Class targetType); /** * 使用注解实现契约的通用逻辑， SpringMvcContract继承了BaseContract */ abstract class BaseContract implements Contract { /** * 解析targetType类中的所有方法 * @param targetType 我们自己编写的feign api接口（标有@FeignClient注解的类） */ @Override public List parseAndValidatateMetadata(Class targetType) { // api接口不能有泛型 checkState(targetType.getTypeParameters().length == 0, \"Parameterized types unsupported: %s\", targetType.getSimpleName()); // 最多只能有1个父接口，多余1个父接口则抛出异常（不能多继承父接口，只允许单继承接口） checkState(targetType.getInterfaces().length 0, \"Headers annotation was empty on method %s.\", method.getName()); // 由于类和方法上都可以有@Headers注解，所以内部实现（appendHeader）是合并 // 之前已有的headers和这里新增的headers data.template().headers(toMap(headersOnMethod)); } } /** * 处理某个参数上的多个注解（1个参数可能有多个注解）, * 总结，主要处理了如下几个属性: * indexToName --> @Param注解的value属性 * indexToExpanderClass --> @Param注解的expander属性 * indexToEncoded --> @Param注解的encoded属性 * formParams --> @Param注解的value属性 * queryMapIndex --> @QueryMap注解 * queryMapEncoded --> @QueryMap注解的encoded属性 * headerMapIndex --> @HeaderMap注解 * * @param data 元数据，存储方法的相关数据(uri、headers、queries、body。。。) * @param annotations 某1个参数上的所有所有注解（1个参数可能有多个注解） * @param paramIndex 该参数在方法的所有参数中的索引, 从0开始 */ @Override protected boolean processAnnotationsOnParameter(MethodMetadata data, Annotation[] annotations, int paramIndex) { // 参数是否有@Param、@QueryMap、@HeaderMap这几个http注解 boolean isHttpAnnotation = false; for (Annotation annotation : annotations) { // 获取注解的Class对象 Class annotationType = annotation.annotationType(); // 如果处理的是@Param注解 if (annotationType == Param.class) { Param paramAnnotation = (Param) annotation; // 获得@Param注解的value属性值 String name = paramAnnotation.value(); // value属性值不能为空 checkState(emptyToNull(name) != null, \"Param annotation was empty on param %s.\", paramIndex); // 追加（不是替换indexToName）到MethodMetadata的indexToName属性中， // key为参数位置索引， values为@Param注解的value属性值 nameParam(data, name, paramIndex); // @Param注解的expander参数，定义参数的解释器，默认是ToStringExpander， // 调用参数的toString方法 Class expander = paramAnnotation.expander(); // 判断是否自定义了expander解析器 if (expander != Param.ToStringExpander.class) { // 参数自定义了expander解析器，存储起来 data.indexToExpanderClass().put(paramIndex, expander); } // 参数是否已经urlEncoded，如果没有，会使用urlEncoded方式编码 data.indexToEncoded().put(paramIndex, paramAnnotation.encoded()); // 参数上存在http注解 isHttpAnnotation = true; if (!data.template().hasRequestVariable(name)) { // 如果参数不在path里面，不在query里面，不在header里面，就设置到formParam中 data.formParams().add(name); } } // 如果处理的是@QueryMap注解，注解参数对象时，将该参数转换为http请求参数格式发送 else if (annotationType == QueryMap.class) { // 1个方法不能在多个参数上存在@QueryMap注解 checkState(data.queryMapIndex() == null, \"QueryMap annotation was present on multiple parameters.\"); // 记录@QueryMap注解参数的索引 data.queryMapIndex(paramIndex); // @QueryMap注解的对像的值是否已经编码过，如果未编码则后续将url编码 data.queryMapEncoded(QueryMap.class.cast(annotation).encoded()); // 参数上存在http注解 isHttpAnnotation = true; } // 如果处理的是@HeaderMap注解，注解一个Map类型的参数，放入http header中发送 else if (annotationType == HeaderMap.class) { // 1个方法中不能在多个参数上存在@HeaderMap注解 checkState(data.headerMapIndex() == null, \"HeaderMap annotation was present on multiple parameters.\"); // 记录@HeaderMap注解参数的索引 data.headerMapIndex(paramIndex); // 参数上存在http注解 isHttpAnnotation = true; } } // 参数是否有@Param、@QueryMap、@HeaderMap这几个http注解 return isHttpAnnotation; } /** * 将http header用冒号分割 * 例如 Content-Type:text/html、Set-Cookie:uid=123、Set-Cookie:sid=456将变成如下的Map对象 * Content-Type ----> text/html * Set-Cookie ----> uid=123、sid=456 */ private static Map toMap(String[] input) { Map result = new LinkedHashMap(input.length); for (String header : input) { int colon = header.indexOf(':'); String name = header.substring(0, colon); if (!result.containsKey(name)) { result.put(name, new ArrayList(1)); } result.get(name).add(header.substring(colon + 1).trim()); } return result; } }} 代码稍微有点多，但是逻辑很清晰，先处理类上的注解，再处理方法上注解，最后处理方法参数注解，把所有注解的情况都处理到就可以了。 生成的MethodMetadata的结构如下： java123456789101112131415161718192021222324252627282930313233public final class MethodMetadata implements Serializable { //标识方法的key，接口名加方法签名：GitHub#contributors(String,String) private String configKey; //方法返回值类型 private transient Type returnType; //uri参数的位置，方法中可以提供1个java.net.URI类型的参数，发请求时直接使用这个参数 private Integer urlIndex; //body参数的位置，只能有一个未注解的参数为body，否则报错 private Integer bodyIndex; //@HeaderMap注解参数的位置 private Integer headerMapIndex; //@QueryMap注解参数位置 private Integer queryMapIndex; //@QueryMap注解里面encode参数，是否已经urlEncode编码过了 private boolean queryMapEncoded; //body参数的类型 private transient Type bodyType; //RequestTemplate 原型 private RequestTemplate template = new RequestTemplate(); //form请求参数 private List formParams = new ArrayList(); //方法参数位置和名称的map private Map indexToName ; //@Param中注解的expander方法，可以指定解析参数类 private Map indexToExpanderClass ; //参数是否被urlEncode编码过了，@Param中encoded方法 private Map indexToEncoded ; //自定义的Expander private transient Map indexToExpander; ...省略部分代码} Contract也是feign的一个扩展点，一个优秀组件的架构通常是具有很强的扩展性，feign的架构本身很简单，设计的扩展点也很简单方便，所以受到spring的青睐，将其集成到spring cloud中。spring cloud就是通过Contract的扩展(org.springframework.cloud.openfeign.support.SpringMvcContract)，实现使用springMVC的注解接入feign。feign自己还实现了使用jaxrs注解接入feign。 初始化总结上文已经完成了feign初始化结构为动态代理的整个过程，简单的捋一遍： 初始化Feign.Builder传入参数，构造ReflectiveFeign ReflectiveFeign通过内部类ParseHandlersByName的Contract属性，解析接口生成MethodMetadata ParseHandlersByName根据MethodMetadata生成RequestTemplate工厂 ParseHandlersByName创建SynchronousMethodHandler，传入MethodMetadata、RequestTemplate工厂和Feign.Builder相关参数 ReflectiveFeign创建FeignInvocationHandler，传入参数SynchronousMethodHandler，绑定DefaultMethodHandler ReflectiveFeign根据FeignInvocationHandler创建Proxy 关键的几个类是： ReflectiveFeign 初始化入口 FeignInvocationHandler 实现动态代理的InvocHandler SynchronousMethodHandler 方法处理器，方法调用处理器 MethodMetadata 方法元数据 Contract.Default契约解析默认实现 接口调用为方便理解，分析完feign源码后，我将feign执行过程分成三层，如下图： 三层分别为： 代理层 jdk动态代理调用层 转换层 方法转http请求，解码http响应 网络层 http请求发送 java动态代理接口方法调用，会调用到InvocaHandler的invoke方法，feign里面实现类是FeignInvocationHandler，invoke代码如下： java1234567891011121314151617181920212223public class ReflectiveFeign extends Feign { ...省略部分代码 static class FeignInvocationHandler implements InvocationHandler { // 要代理的feign api接口，包含class、host信息 private final Target target; // MethodHandler的具体类型位SynchronousMethodHandler或DefaultMethodHandler private final Map dispatch; FeignInvocationHandler(Target target, Map dispatch) { this.target = checkNotNull(target, \"target\"); this.dispatch = checkNotNull(dispatch, \"dispatch for %s\", target); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { ...省略 部分代码 return dispatch.get(method).invoke(args); } }} 根据方法找到MethodHandler，除接口的default方法外(default方法直接调用，无需feign处理)，找到的是SynchronousMethodHandler对象，然后调用SynchronousMethodHandlerd.invoke方法： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138final class SynchronousMethodHandler implements MethodHandler { private final MethodMetadata metadata; private final Target target; private final Client client; private final Retryer retryer; private final List requestInterceptors; private final Logger logger; private final Logger.Level logLevel; private final RequestTemplate.Factory buildTemplateFromArgs; private final Options options; private final Decoder decoder; private final ErrorDecoder errorDecoder; private final boolean decode404; private final boolean closeAfterDecode; private final ExceptionPropagationPolicy propagationPolicy; @Override public Object invoke(Object[] argv) throws Throwable { //buildTemplateFromArgs是RequestTemplate工程对象，根据方法参数创建RequestTemplate RequestTemplate template = buildTemplateFromArgs.create(argv); Options options = findOptions(argv); //重试设置 Retryer retryer = this.retryer.clone(); while (true) { try { //执行和解码 return executeAndDecode(template, options); } catch (RetryableException e) { try { // 执行executeAndDecode时发生异常，由retryer决定是否继续重试 //（若continueOrPropagate的实现抛出异常则停止重试，否则继续重试） retryer.continueOrPropagate(e); } catch (RetryableException th) { // continueOrPropagate的实现抛出了异常，停止重试 Throwable cause = th.getCause(); if (propagationPolicy == UNWRAP && cause != null) { throw cause; } else { throw th; } } if (logLevel != Logger.Level.NONE) { logger.logRetry(metadata.configKey(), logLevel); } continue; } } } Object executeAndDecode(RequestTemplate template, Options options) throws Throwable { //RequestTemplate转换为Request Request request = targetRequest(template); ...省略部分代码 Response response; long start = System.nanoTime(); try { response = client.execute(request, options); } catch (IOException e) { ...省略部分代码 throw errorExecuting(request, e); } long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start); boolean shouldClose = true; try { ...省略部分代码 //如果接口方法返回的是Response类 if (Response.class == metadata.returnType()) { if (response.body() == null) { return response; } //body不为空，且length>最大缓存值，返回response，但是不能关闭response if (response.body().length() == null || response.body().length() > MAX_RESPONSE_BUFFER_SIZE) { shouldClose = false; return response; } // body的length小于最大缓存值，可以直接读取body字节数组，返回response，可以自动关闭response byte[] bodyData = Util.toByteArray(response.body().asInputStream()); return response.toBuilder().body(bodyData).build(); } //判断响应成功 if (response.status() >= 200 && response.status() < 300) { // 响应成功，方法是否没有返回值 if (void.class == metadata.returnType()) { // 方法返回void类型 return null; } // 方法需要返回值 else { // 解码响应，直接调用decoder解码 Object result = decode(response); //是否应该自动关闭response响应 shouldClose = closeAfterDecode; // 方法最终的返回值 return result; } } // 请求返回了404状态码并且应该解码404响应，并且方法需要返回值 else if (decode404 && response.status() == 404 && void.class != metadata.returnType()) { // 解码404状态的response响应，直接调用decoder解码 Object result = decode(response); shouldClose = closeAfterDecode; return result; } else { // 非2xx的状态或者404状态不解码时，使用errorDecoder解析要抛出的异常 throw errorDecoder.decode(metadata.configKey(), response); } } catch (IOException e) { ...省略部分代码 throw errorReading(request, response, e); } finally { //是否需要关闭response，根据Feign.Builder 参数设置是否要关闭流 if (shouldClose) { //关闭响应 ensureClosed(response.body()); } } } Request targetRequest(RequestTemplate template) { for (RequestInterceptor interceptor : requestInterceptors) { interceptor.apply(template); } return target.apply(template); }} 过程比较简单，生成RquestTemplate -> 转换为Request -> client发请求 -> Decoder解析Response RquestTemplate构建过程先看看RequestTemplate的结构： java1234567891011121314151617181920212223242526public final class RequestTemplate implements Serializable { private static final Pattern QUERY_STRING_PATTERN = Pattern.compile(\"(?); // 请求参数 ?后面的name=value private final Map queries = new LinkedHashMap(); // 请求头 private final Map headers = new TreeMap(String.CASE_INSENSITIVE_ORDER); // 基础url部分 private String target; // url中的#及其后面的部分 private String fragment; private boolean resolved = false; // @RequestLine注解中的请求路径对象，只有路径部分(/user/list)，不包含?后的部分 private UriTemplate uriTemplate; //请求方法 GET/POST等 private HttpMethod method; //字符集 private transient Charset charset = Util.UTF_8; //请求体 private Request.Body body = Request.Body.empty(); //是否decode斜杠，将\"%2F\"反转为\"/\" private boolean decodeSlash = true; //集合格式化，a=b&c=d private CollectionFormat collectionFormat = CollectionFormat.EXPLODED;} 在SynchronousMethodHandler.invoke方法中生成RequestTemplate java12//buildTemplateFromArgs是RequestTemplate.Factory实现类RequestTemplate template = buildTemplateFromArgs.create(argv); Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495- ```BuildTemplateByResolvingArgs``` ```RequestTemplate```工厂- ```BuildEncodedTemplateFromArgs``` ```BuildTemplateByResolvingArgs```的子类 重载```resolve```方法，解析form表单请求- ```BuildFormEncodedTemplateFromArgs``` ```BuildTemplateByResolvingArgs```的子类，重载```resolve```方法，解析body请求----- **BuildTemplateByResolvingArgs的实现**默认的RequestTemplate的工厂，没有请求体，不需要编码器```javaprivate static class BuildTemplateByResolvingArgs implements RequestTemplate.Factory { // @QueryMap注解的参数的编码器 private final QueryMapEncoder queryMapEncoder; // 方法的元数据 protected final MethodMetadata metadata; // @Param注解的expander属性，用于参数转换 private final Map indexToExpander = new LinkedHashMap(); /** * @params argv 调用方法时传递的参数列表 */ @Override public RequestTemplate create(Object[] argv) { RequestTemplate mutable = RequestTemplate.from(metadata.template()); // 方法中有java.net.URI类型的参数, 例如void list(String username, URI url, String queryKey) if (metadata.urlIndex() != null) { // 获取URI类型的参数在参数列表中的位置 int urlIndex = metadata.urlIndex(); // URI类型的参数的实际值不为null checkArgument(argv[urlIndex] != null, \"URI parameter %s was null\", urlIndex); // 使用指定的参数的地址作为请求的基础地址 //（不使用Feign.builder().target(Api.class, 'http://localhost:8080')）中的url地址 mutable.target(String.valueOf(argv[urlIndex])); } // 存储 @Param注解value值 --> 参数实际值 的映射关系，用于后续表达式{expression}的求值 Map varBuilder = new LinkedHashMap(); // indexToName属性是解析@Param注解产生的， // key为@Param注解的参数在参数列表中的索引 // value为@Param注解的value属性 for (Entry entry : metadata.indexToName().entrySet()) { // 获得@Param主键的参数索引 int i = entry.getKey(); // 该位置参数的实际调用时传递的值 Object value = argv[entry.getKey()]; if (value != null) { // 跳过null值 // @Param注解是否有expander属性，即参数值是否需要转换处理（如Date -> String、Enum -> int等等） if (indexToExpander.containsKey(i)) { // 使用expander属性指定的class来转换输入值为另一个值 //（例如传入Date类型的参数，实际请求时需要的是yyyy-MM-dd这种格式的字符串， // 那么就需要写一个DateFormatExpander类来进行转换参数） value = expandElements(indexToExpander.get(i), value); } for (String name : entry.getValue()) { // 存储@Param注解value值 --> 参数实际值 的映射关系，用于后续表达式{expression}的求值 varBuilder.put(name, value); } } } //解析RequestTemplate RequestTemplate template = resolve(argv, mutable, varBuilder); // 为什么单独把queryMap放在这里解析，而不是在resolve方法中，或者在RequestTemplate中？(该问题来源于拍拍贷的博客内容) // 因为@QueryMap注解的参数不需要解析表达式 if (metadata.queryMapIndex() != null) { //判断是否有@QueryMap注解的参数 // 获取@QueryMap注解的参数的实际值 Object value = argv[metadata.queryMapIndex()]; // value可能是Map或者java bean对象，如果参数不是Map类型的则用queryMapEncoder进行编码 Map queryMap = toQueryMap(value); // 合并已有的查询参数和queryMap的参数，追加到RequestTemplate的queries属性中 template = addQueryMapQueryParameters(queryMap, template); } // 为什么单独把headerMap放在这里解析，而不是在resolve方法中，或者在RequestTemplate中？ // 因为@HeaderMap注解的参数不需要解析表达式 // 参数中是否有@HeaderMap注解的参数 if (metadata.headerMapIndex() != null) { // 将@HeaderMap注解的参数的实际值与已有的(@Headers的)header参数合并， // 追加到RequestTemplate的headers属性中 template = addHeaderMapHeaders((Map) argv[metadata.headerMapIndex()], template); } return template; } /** * 注解的表达书求值 * * @params variables 指的是@Param注解value值 --> 参数实际值 的映射关系，用于后续表达式{expression}的求值 */ protected RequestTemplate resolve(Object[] argv, RequestTemplate mutable, Map variables) { // 由RequestTemplate.resolve(Map)实现，真正的去解析注解中的表达式{expression} return mutable.resolve(variables); }} BuildFormEncodedTemplateFromArgs的实现 如果有formParam，并且bodyTemplate不为空，请求体为x-www-form-urlencoded格式 将会解析form参数，填充到bodyTemplate中 该类用于对参数列表中的form参数(未被表达式使用的@Param参数)使用encoder编码 java1234567891011121314151617181920212223242526272829303132333435363738394041424344private static class BuildFormEncodedTemplateFromArgs extends BuildTemplateByResolvingArgs { // Feign.builder().encoder(xx)时设置的编码器 private final Encoder encoder; ...省略部分代码 /** * 注意这里重写了父类BuildTemplateByResolvingArgs中的resolve方法， * create的逻辑仍然使用父类的，这里是使用了模板方法设计模式 * @param variables 指参数上的@Param注解的键值对 */ @Override protected RequestTemplate resolve(Object[] argv, RequestTemplate mutable, Map variables) { // 存储所有的form表单参数的name、value Map formVariables = new LinkedHashMap(); for (Entry entry : variables.entrySet()) { // 判断该参数是否是form表单参数，为什么有这个判断? // 因为@Param注解的参数作为form表单参数是有条件的，不是所有的@Param注解的参数都会作为form表单参数 // @Param注解的参数有2种作用： // 1. 如果@Param注解的参数被表达式所使用，则不会作为form参数, 仅仅是为了解析表达式变量使用的 // 2. 如果@Param注解的参数没有被表达式所使用，则作为form表单参数 if (metadata.formParams().contains(entry.getKey())) { // 拿到所有的form表单参数的name、value formVariables.put(entry.getKey(), entry.getValue()); } } try { // 使用encoder对参数编码 encoder.encode(formVariables, Encoder.MAP_STRING_WILDCARD, mutable); } catch (EncodeException e) { throw e; } catch (RuntimeException e) { throw new EncodeException(e.getMessage(), e); } //调用父类BuildTemplateByResolvingArgs.reslove()处理，对注解中的表达式求值 return super.resolve(argv, mutable, variables); }} BuildEncodedTemplateFromArgs的实现 如果包含请求体，将会用encoder编码请求体对象（参数列表中的参数无任何注解会作为请求体） java12345678910111213141516171819202122232425262728private static class BuildEncodedTemplateFromArgs extends BuildTemplateByResolvingArgs { // Feign.builder().encoder(xx)时设置的编码器 private final Encoder encoder; ...省略部分代码 @Override protected RequestTemplate resolve(Object[] argv, RequestTemplate mutable, Map variables) { // 获取作为body的参数的值 Object body = argv[metadata.bodyIndex()]; // 值不能为空 checkArgument(body != null, \"Body parameter %s was null\", metadata.bodyIndex()); try { // 编码并设置RequestTemplate的body encoder.encode(body, metadata.bodyType(), mutable); } catch (EncodeException e) { throw e; } catch (RuntimeException e) { throw new EncodeException(e.getMessage(), e); } //调用父类BuildTemplateByResolvingArgs.reslove()处理，对注解中的表达式求值 return super.resolve(argv, mutable, variables); }} RequestTemplate解析参数的方法：java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public final class RequestTemplate implements Serializable { private static final Pattern QUERY_STRING_PATTERN = Pattern.compile(\"(?); // 请求参数 ?后面的name=value private final Map queries = new LinkedHashMap(); // 请求头 private final Map headers = new TreeMap(String.CASE_INSENSITIVE_ORDER); // 基础url部分 private String target; // url中的#及其后面的部分 private String fragment; private boolean resolved = false; // @RequestLine注解中的请求路径对象，只有路径部分(/user/list)，不包含?后的部分 private UriTemplate uriTemplate; //请求方法 GET/POST等 private HttpMethod method; //字符集 private transient Charset charset = Util.UTF_8; //请求体 private Request.Body body = Request.Body.empty(); //是否decode斜杠，将\"%2F\"反转为\"/\" private boolean decodeSlash = true; //集合格式化，a=b&c=d private CollectionFormat collectionFormat = CollectionFormat.EXPLODED; /** * 表达式{expression}解析 * * @param variables 所有的@Param注解value值 --> 参数实际值 的映射关系，用于表达式{expression}求值 */ public RequestTemplate resolve(Map variables) { StringBuilder uri = new StringBuilder(); // 得到当前对象一份新的拷贝 RequestTemplate resolved = RequestTemplate.from(this); // 为什么要判断是否非null？, 所有的方法必须要有@RequestLine注解啊， // 即使如@RequestLine(\"GET\")这样不写path这里的uriTemplate也会是空字符串\"\"，而不可能是null啊 if (this.uriTemplate == null) { this.uriTemplate = UriTemplate.create(\"\", !this.decodeSlash, this.charset); } // 解析@RequestLine的属性中的表达式为实际值, 此时的uri为具体url， // 例如 /user/{username} 解析后变成 /user/calebzhao uri.append(this.uriTemplate.expand(variables)); // 判断@RequestLine(\"GET /user/{username}\")是否有查询参数, 注意此时@QueryMap的参数还不在queries属性中 // 为什么不把@QueryMap的处理放在这个方法里就是因为@QueryMap的参数不需要解析表达式变量 if (!this.queries.isEmpty()) { // 初始化1个空Map resolved.queries(Collections.emptyMap()); StringBuilder query = new StringBuilder(); Iterator queryTemplates = this.queries.values().iterator(); while (queryTemplates.hasNext()) { QueryTemplate queryTemplate = queryTemplates.next(); // 解析@QueryMap注解标注的参数的值，然后变成查询字符串，格式如a=b String queryExpanded = queryTemplate.expand(variables); // 有值，需要拼接在url中 if (Util.isNotBlank(queryExpanded)) { query.append(queryExpanded); if (queryTemplates.hasNext()) { // 多个url参数之间的分隔符，如a=b&c=d query.append(\"&\"); } } } String queryString = query.toString(); if (!queryString.isEmpty()) { Matcher queryMatcher = QUERY_STRING_PATTERN.matcher(uri); // 判断uri中是否已有查询字符串? if (queryMatcher.find()) { // @RequestLine(\"GET /user/{username}?appId=123\")中的url路径已有查询字符串? uri.append(\"&\"); } .// 还没有字符串?，则拼接? else { uri.append(\"?\"); } // 拼接查询参数到url中 uri.append(queryString); } } // 到这里uri已经变成/user/calebzhao?appId=123&a=b&c=d这种形式了 // 将上述uri的各部分添加到当前RequestTemplate中， // 重新计算当前RequestTemplate的各个部分的值(uri路径覆盖当前值、queries查询参数覆盖当前值、frament覆盖) // RequestTemplate的各个部分的值如下： // uri ---> /user/calebzhao // quries ---> appId=123、appId=123、a=b、c=d // frament --->空 resolved.uri(uri.toString()); // 有@Headers注解的值，注意此时@HeaderMap注解的参数值还不在headers， // 为什么不把@HeaderMap的处理放在这个方法里就是因为因为@HeaderMap注解的参数值不需要解析表达式 if (!this.headers.isEmpty()) { // header属性初始化为空Map resolved.headers(Collections.emptyMap()); for (HeaderTemplate headerTemplate : this.headers.values()) { // HeaderTemplate的template形如：name空格value1逗号空格value2 ， // 例如set-cookie rid={roleId}, sid={sessionId} // 解析@Headers(\"x-user:{username}\")注解中的表达式{username} String header = headerTemplate.expand(variables); if (!header.isEmpty()) { // 得到的值形如：set-cookie rid=1, sid=2 // 得到第一个空格后面的部分，例如上面例子的rid=1, sid=2 String headerValues = header.substring(header.indexOf(\" \") + 1); if (!headerValues.isEmpty()) { // 存储解析后的header resolved.header(headerTemplate.getName(), headerValues); } } } } // 处理body中的表达式 resolved.body(this.body.expand(variables)); //标记为已解析 resolved.resolved = true; //返回解析后的RequestTemplate return resolved; } /** * 这个方法的作用就是复制requestTemplate，得到一份新的拷贝 */ public static RequestTemplate from(RequestTemplate requestTemplate) { RequestTemplate template = new RequestTemplate(requestTemplate.target, requestTemplate.fragment, requestTemplate.uriTemplate, requestTemplate.method, requestTemplate.charset, requestTemplate.body, requestTemplate.decodeSlash, requestTemplate.collectionFormat); if (!requestTemplate.queries().isEmpty()) { template.queries.putAll(requestTemplate.queries); } if (!requestTemplate.headers().isEmpty()) { template.headers.putAll(requestTemplate.headers); } return template; }} 我们回到SynchronousMethodHandler的invoke方法继续看executeAndDecode的实现 java1234567@Override public Object invoke(Object[] argv) throws Throwable { RequestTemplate template = buildTemplateFromArgs.create(argv); ...省略return executeAndDecode(template, options);} RquestTemplate转换Request先来看看Request的结构，完整的http请求信息的定义： java123456789101112131415161718192021public final class Request { private final HttpMethod httpMethod; private final String url; private final Map headers; private final Body body; public static class Body { private final byte[] data; private final Charset encoding; private final BodyTemplate bodyTemplate; } Request(HttpMethod method, String url, Map headers, Body body) { this.httpMethod = checkNotNull(method, \"httpMethod of %s\", method.name()); this.url = checkNotNull(url, \"url\"); this.headers = checkNotNull(headers, \"headers of %s %s\", method, url); this.body = body; }} SynchronousMethodHandler的targetRequest方法将RequestTemplate转换为Request java12345678Request targetRequest(RequestTemplate template) { //先应用所用拦截器，拦截器是在Feign.Builder中传入的，拦截器可以修改RequestTemplate信息 for (RequestInterceptor interceptor : requestInterceptors) { interceptor.apply(template); } //调用Target的apply方法，默认Target是HardCodedTarget return target.apply(template);} 这块先应用所有拦截器，然后target的apply方法。拦截器和target都是扩展点，拦截器可以在构造好RequestTemplate后和发请求前修改请求信息，target默认使用HardCodedTarget直接发请求，feign还提供了LoadBalancingTarget，适配Ribbon来发请求，实现客户端的负载均衡。 HardCodedTarget java1234567891011121314public static class HardCodedTarget implements Target { private final Class type; private final String name; private final String url; @Override public Request apply(RequestTemplate input) { if (input.url().indexOf(\"http\") != 0) { input.target(url()); } return input.request(); }} RequestTemplate的input方法 java123456public Request request() { if (!this.resolved) { throw new IllegalStateException(\"template has not been resolved.\"); } return Request.create(this.method, this.url(), this.headers(), this.requestBody());} Reques``的create`方法 java123456public static Request create(HttpMethod httpMethod, String url, Map headers, Body body) { return new Request(httpMethod, url, headers, body); } 从代码上可以看到，RequestTemplate基本上直接转为Request，没有做什么逻辑操作。 http请求发送SynchronousMethodHandler中构造好Request后，直接调用client的execute方法发送请求： java1234567Object executeAndDecode(RequestTemplate template, Options options) throws Throwable { ...省略部分代码 response = client.execute(request, options); ...省略部分代码} client是一个Client接口，默认实现类是Client.Default，使用java api中的HttpURLConnection发送http请求。feign还实现了： feign.Client.Proxied ApacheHttpClient OkHttpClient LoadBalancerFeignClient FeignBlockingLoadBalancerClient 接口调用过程总结我们再将接口调用过程捋一遍： 1、接口的动态代理Proxy调用接口方法会执行的FeignInvocationHandler2、FeignInvocationHandler通过方法签名在属性Map dispatch中找到SynchronousMethodHandler，调用invoke方法3、SynchronousMethodHandler的invoke方法根据传入的方法参数，通过自身属性工厂对象RequestTemplate.Factory创建RequestTemplate，工厂里面会用根据需要进行Encode4、SynchronousMethodHandler遍历自身属性RequestInterceptor列表，对RequestTemplate进行改造4、SynchronousMethodHandler调用自身Target属性的apply方法，将RequestTemplate转换为Request对象5、SynchronousMethodHandler调用自身Client的execute方法，传入Request对象6、Client将Request转换为http请求，发送后将http响应转换为Response对象7、SynchronousMethodHandler调用Decoder的方法对Response对象解码后返回8、返回的对象最后返回到Proxy 时序图如下： feign扩展点总结前文分析源代码时，已经提到了feign的扩展点，最后我们再将feign的主要扩展点进行总结一下： Contract 契约 Code12345678910111213 - ```feign.Contract.Default``` feign默认实现 - ```JAXRSContract``` javax.ws.rs注解接口实现 - ```SpringMvcContract```是spring cloud提供SpringMVC注解实现方式。 - ```HystrixDelegatingContract``` hyxtrix注解的实现 - **InvocationHandler** 动态代理handler 通过```InvocationHandlerFactory```注入到```Feign.Builder```中，feign提供了Hystrix的扩展，实现Hystrix接入- **Encoder** 请求body编码器feign已经提供扩展包含： - 默认编码器，只能处理String和byte[] - json编码器```GsonEncoder```、```JacksonEncoder XML编码器JAXBEncoder FormEncoder SpringEncoder SpringFormEncoder PageableSpringEncoder Decoder http响应解码器最基本的有： feign默认的 StringDecoder、OptionalDecoder、feign.codec.Decoder.Default、feign.Feign.ResponseMappingDecoder json解码器 GsonDecoder、JacksonDecoder、JacksonIteratorDecoder XML解码器 JAXBDecoder Stream流解码器 StreamDecoder spring的 SpringDecoder、ResponseEntityDecoder ErrorDecoder 错误解码器 Target 请求转换器feign提供的实现有： HardCodedTarget 默认Target，不做任何处理。 EmptyTarget feign提供的 Client 发送http请求的客户端feign提供的Client实现有： Client.Default 默认实现，使用java api的HttpClientConnection发送http请求 ApacheHttpClient 使用apache的Http客户端发送请求 OkHttpClient 使用OKHttp客户端发送请求 LoadBalancerFeignClient spring-cloud-openfeign的通过负载均衡选择服务发送请求 RequestInterceptor 请求拦截器调用客户端发请求前，修改RequestTemplate，比如为所有请求添加Header就可以用拦截器实现。 BaseRequestInterceptor BasicAuthRequestInterceptor FeignAcceptGzipEncodingInterceptor FeignContentGzipEncodingInterceptor Retryer 重试策略默认的策略是Retryer.Default，包含3个参数： 间隔、 最大间隔 重试次数，第一次失败重试前会sleep输入的间隔时间的，后面每次重试sleep时间是前一次的1.5倍，超过最大时间或者最大重试次数就失败 文章绝大部分内容来源于：http://techblog.ppdai.com/2018/05/14/20180514/本人在其基础上加入自己的理解","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/tags/spring-cloud/"},{"name":"feign","slug":"feign","permalink":"https://calebzhao.github.io/tags/feign/"}]},{"title":"java并发编程入门","slug":"java并发编程入门","date":"2019-12-29T08:06:54.000Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2019/12/29/java并发编程入门/","link":"","permalink":"https://calebzhao.github.io/2019/12/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/","excerpt":"","text":"1、入门介绍1.1、实现线程的2种方式Code123456789101112131415161718192021222324252627package chapter2;/** * @author calebzhao * 2019/6/29 14:05 */public class MyThreadDemo1 { public static void main(String[] args) { new Thread1().start(); new Thread(new Thread2()).start(); }}class Thread1 extends Thread{ @Override public void run() { System.out.println(Thread.currentThread().getName()); }}class Thread2 implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()); }} 1.2、线程的状态（生命周期）1.2.1、线程的5种状态1. 新建(NEW)：新创建了一个线程对象。 2. 可运行(RUNNABLE)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。 3. 运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。 4. 阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： Code123(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 5. 死亡(DEAD)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 1.2.2、线程运行状态图 1). 初始状态 实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态 2). 可运行状态 可运行状态只是说你资格运行，调度程序没有挑选到你，你就永远是可运行状态。 调用线程的start()方法，此线程进入可运行状态。 当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入可运行状态。 当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入可运行状态。 锁池里的线程拿到对象锁后，进入可运行状态。 3). 运行状态 线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。 4). 死亡状态 当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 5). 阻塞状态 当前线程T调用Thread.sleep()方法，当前线程进入阻塞状态。 运行在当前线程里的其它线程t2调用join()方法，当前线程进入阻塞状态。 等待用户输入的时候，当前线程进入阻塞状态。 6). 等待队列(是Object里的方法，但影响了线程) 调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内。 与等待队列相关的步骤和图 线程1获取对象A的锁，正在使用对象A。 线程1调用对象A的wait()方法。 线程1释放对象A的锁，并马上进入等待队列。 锁池里面的对象争抢对象A的锁。 线程5获得对象A的锁，进入synchronized块，使用对象A。 线程5调用对象A的notifyAll()方法，唤醒所有线程，所有线程进入锁池。||||| 线程5调用对象A的notify()方法，唤醒一个线程，不知道会唤醒谁，被唤醒的那个线程进入锁池。 notifyAll()方法所在synchronized结束，线程5释放对象A的锁。 锁池里面的线程争抢对象锁，但线程1什么时候能抢到就不知道了。||||| 原本锁池+第6步被唤醒的线程一起争抢对象锁。 7). 锁池状态 当前线程想调用对象A的同步方法时，发现对象A的锁被别的线程占有，此时当前线程进入锁池状态。简言之，锁池里面放的都是想争夺对象锁的线程。 当一个线程1被另外一个线程2唤醒时，1线程进入锁池状态，去争夺对象锁。 锁池是在同步的环境下才有的概念，一个对象对应一个锁池。1.3. **sleep、yield、join、wait的比较** Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入阻塞，但不释放对象锁，millis后线程自动苏醒进入可运行状态。作用：给其它线程执行机会的最佳方式。 Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的cpu时间片，由运行状态变会可运行状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。 t.join()/t.join(long millis)，当前线程里调用其它线程1的join方法，当前线程阻塞，但不释放对象锁，直到线程1执行完毕或者millis时间到，当前线程进入可运行状态。 obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout)timeout时间到自动唤醒。 obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。1.4、Thread.sleep(long time)Thread.sleep(long time)方法的作用是让当前正在执行的线程休眠(让出CPU时间片)指定的毫秒数。 需要注意的是： 调用sleep()方法时，如果当前线程持有锁不会导致当前线程释放锁。 sleep不释放锁 线程是进入阻塞状态还是就绪状态？ 答案是进入阻塞状态，确切的说Thread在Java的TIMED_WAITING状态（但这个状态其实并没那么重要，可以认为是java的内部细节，用户不用太操心）。往下一层，在不同OS上底层的sleep的实现细节不太一样。但是大体上就是挂起当前的线程，然后设置一个信号或者时钟中断到时候唤醒。sleep后的的Thread在被唤醒前是不会消耗任何CPU的（确切的说，大部分OS都会这么实现，除非某个OS的实现偷懒了）。这点上，wait对当前线程的效果差不多是一样的，也会暂停调度，等着notify或者一个超时的时间。期间CPU也不会被消耗。 2、多线程实现银行叫号排队2.1 版本1Code123456789101112131415package chapter2.version1;/** * @author calebzhao * 2019/6/29 8:58 */public class Bank { public static void main(String[] args) { TicketWindow ticketWindow = new TicketWindow(\"1号窗口\"); TicketWindow ticketWindow2 = new TicketWindow(\"2号窗口\"); TicketWindow ticketWindow3 = new TicketWindow(\"3号窗口\"); ticketWindow.start(); ticketWindow2.start(); ticketWindow3.start(); }} Code123456789101112131415161718192021222324252627282930package chapter2.version1;/** * @author calebzhao * 2019/6/29 8:58 */public class TicketWindow extends Thread { private static int MAX = 50; private static int current = 1; private String name; public TicketWindow(String name){ this.name = name; } @Override public void run() { while (current < MAX){ System.out.println(\"窗口：\" + name +\" 当前叫号:\" + current); current++; try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } }} 此版本中注意TicketWindow 类的成员变量current 为static, 表示无论实例化这个类多少次，都共享同一份变量，因为这个变量是在类加载的时候就已经创建好的。为了让多个线程消耗同一个current 所以才定义为static的，不然每个线程的current都是各自的，与其他线程不相关。 以上代码把业务与线程紧密掺杂在一起，为了让多个线程访问同一份current把他定义为static明显是不合适的。 2.2 版本2Code1234567891011121314151617181920package chapter2.version2;/** * @author calebzhao * 2019/6/29 8:58 */public class Bank { public static void main(String[] args) { // 有线程安全问题， 多个线程同时访问到current变量 TicketWindow ticketWindow = new TicketWindow(); Thread windowThread1 = new Thread(ticketWindow, \"1号窗口\"); Thread windowThread2 = new Thread(ticketWindow, \"2号窗口\"); Thread windowThread3 = new Thread(ticketWindow, \"3号窗口\"); windowThread1.start(); windowThread2.start(); windowThread3.start(); } } Code123456789101112131415161718192021222324252627package chapter2.version2;/** * @author calebzhao * 2019/6/29 9:02 */public class TicketWindow implements Runnable { private int MAX = 50; private int current = 1; @Override public void run() { while (current < MAX){ System.out.println(\"窗口：\" + Thread.currentThread().getName() +\" 当前叫号:\" + current); current++; try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } } 这里TicketWindow 并不是继承Thread, 这样启动线程多次线程可以共享同一份TicketWindow 实例， 把业务逻辑与线程启动拆分清晰明了。注：以上2个版本均存在线程安全性问题，这是由于current变量在run()方法可能被多个线程同时访问， 可能多个线程同时执行到 Code1System.out.println(\"窗口：\" + Thread.currentThread().getName() +\" 当前叫号:\" + current); 这行代码，导致不同的线程打印出了一样的叫号值，比如运行以上程序会输出如下结果： 3、守护线程要点：守护线程会随着父线程的退出而退出， 守护线程适宜一些辅助性的工作，而不能把核心工作的线程设置为守护线程。 Code123456789101112131415161718192021222324252627package chapter2;/** * @author calebzhao * 2019/6/29 14:07 */public class DeemonThreadDemo { public static void main(String[] args) { Thread thread = new Thread(){ @Override public void run() { while (true){ System.out.println(\"hello\"); } } }; // 设置为守护线程 thread.setDaemon(true); thread.start(); System.out.println(\"主线程退出\"); }} 从代码中可以看到thread 中的代码有while(true){ }语句， 在我们的映像中while(true)是死循环应该永远不退出，永远打印hello, 但是从输出结果可以看到运行一段时间后就没有再打印了，说明父线程结束执行了，子线程也随机退出了。 4、Thread.join()Thread.join() 作用：调用join()方法的线程会等到他自己执行结束才会继续往后执行 Thread.join(time) 作用：调用join(time)方法的线程会等到他自己执行指定时间后就会继续往后执行， 4.1 无限等待Code123456789101112131415161718192021222324252627282930package chapter2;/** * @author calebzhao * 2019/6/29 14:32 */public class ThreadJoinDemo { public static void main(String[] args) throws InterruptedException { Thread thread1 = new Thread(() -> { for (int i =0; i < 500; i++){ System.out.println(Thread.currentThread().getName() + \":\" + i); } }); Thread thread2 = new Thread(() -> { for (int i =0; i < 500; i++){ System.out.println(Thread.currentThread().getName() + \":\" + i); } }); thread1.start(); thread2.start(); thread1.join(); thread2.join(); System.out.println(\"所有线程已结束执行\"); }} ) thread1 和thread2交互执行， 而main线程的打印结果一定是在2个线程全部执行完后才打印结果。 4.2 等待指定时间Code12345678910111213141516171819202122232425262728package chapter2;/** * @author calebzhao * 2019/6/29 14:32 */public class ThreadJoinDemo2 { public static void main(String[] args) throws InterruptedException { Thread thread1 = new Thread(() -> { System.out.println(Thread.currentThread().getName() +\"开始执行\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +\"结束执行\"); }); thread1.start(); // 虽然join了， 但是只会等待指定的时间，而不会无限等待 thread1.join(1000); System.out.println(\"主线程等到1000毫秒就执行到了，而无需等到thread1执行完毕\"); }} 5、中断线程的几种方式5.1、介绍Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package chapter2;import org.junit.Test;/** * @author calebzhao * 2019/6/29 14:53 */public class ThreadInterrupt { public static void main(String[] args) { Thread thread = new Thread(() ->{ while (true){ try { Thread.sleep(1000); } catch (InterruptedException e) { System.out.println(\"线程被打断\"); e.printStackTrace(); // 中断后让其退出while循环， 这样来控制线程的退出 break; } } }); thread.start(); System.out.println(thread.isInterrupted()); // 打断thread线程的sleep, 让thread1不再继续sleep thread.interrupt(); System.out.println(thread.isInterrupted()); System.out.println(\"主线程退出\"); } @Test public void test2(){ Object MONITOR = new Object(); Thread thread = new Thread(() ->{ while (true){ synchronized (MONITOR){ try { MONITOR.wait(100); } catch (InterruptedException e) { System.out.println(\"线程被打断\" + Thread.interrupted()); e.printStackTrace(); } } } }); thread.start(); System.out.println(thread.isInterrupted()); thread.interrupt(); System.out.println(thread.isInterrupted()); System.out.println(\"主线程退出\"); } @Test public void test3(){ Thread thread1 = new Thread(() -> { System.out.println(Thread.currentThread().getName() +\"开始执行\"); while (true){ } }); Thread main = Thread.currentThread(); Thread thread2 = new Thread(() -> { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } // 目前是main线程在等待thread1线程，所以需要打断main线程，才能让main线程不再继续等待而是继续往后执行 main.interrupt(); System.out.println(\"interrupt\"); }); thread1.start(); thread2.start(); try { // main线程会等待thread1线程执行完毕才能继续往后执行 thread1.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"主线程执行到了\"); }} 5.2、通过whilte(running) { }变量控制Code1234567891011121314151617181920212223242526272829303132333435363738394041424344package chapter2;import org.junit.Test;/** * @author calebzhao * 2019/6/29 15:34 */public class ThreadCloseDemo { class Worker implements Runnable{ private volatile boolean running = true; @Override public void run() { // 这里有问题， 假如doSomething()非常耗时， 下一次执行while (running)没有机会得到执行，没法立即中断 while (running){ // 假如执行doSomething()方法 } System.out.println(\"退出死循环\"); } public void shutdown(){ this.running = false; } } @Test public void close1(){ Worker worker = new Worker(); Thread thread = new Thread(worker); thread.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } worker.shutdown(); System.out.println(\"主线程执行完毕\"); }} test1()的执行结果： 5.3、通过Thread.interrupt()控制Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546package chapter2;import org.junit.Test;/** * @author calebzhao * 2019/6/29 15:34 */public class ThreadCloseDemo2 { class Worker2 implements Runnable{ private volatile boolean running = true; @Override public void run() { while (true){ if (Thread.currentThread().isInterrupted()){ break; } // 这里有问题， 假如doSomething()非常耗时， 上面的代码根本没有机会得到执行，没法立即中断 // doSomething() } System.out.println(\"退出死循环\"); } } @Test public void close2(){ Worker2 worker = new Worker2(); Thread thread = new Thread(worker); thread.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } thread.interrupt(); System.out.println(\"主线程执行完毕\"); }} 5.4、暴力终止Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package chapter2;import org.junit.Test;/** * @author calebzhao * 2019/6/29 16:06 */public class ThreadCloseDemo2 { class ThreadService{ private Thread executeThread; private boolean running = true; public void execute(Runnable task){ executeThread = new Thread(() -> { Thread workerThread = new Thread(task); workerThread.setDaemon(true); workerThread.start(); // try { // 让executeThread等待workerThread结束执行才往后执行 // 假如workerThread比较耗时，由于守护线程是依附于父线程的，假如这里不join， // 那么可能会产生workerThread还没有真正执行完，executeThread线程就执行完了，导致workerThread也跟着退出了 workerThread.join(); } catch (InterruptedException e) { // e.printStackTrace(); } //executeThread线程被打断等待 或者 workerThread正常执行结束 this.running = false; }); executeThread.start(); } public void shutdown(long timeout){ long beginTime = System.currentTimeMillis(); // workerThread还在执行 while (running){ // 判断是否等待超时 if (System.currentTimeMillis() - beginTime >= timeout){ // 等待超时了， 中断executeThread的等待会使this.running = false;执行到， // executeThread执行完毕导致workerThread守护线程跟着退出 executeThread.interrupt(); //退出while循环 break; } try { Thread.sleep(1); } catch (InterruptedException e) { // 说明main线程被打断了 e.printStackTrace(); break; } } } public boolean isRunning(){ return this.running; } } /** * 必须等待3秒后才结束执行 */ @Test public void test1() { ThreadService threadService = new ThreadService(); threadService.execute(() -> { // 这是一个非常非常耗时的操作 while (true){ } }); //让线程2秒后立即中断执行 long begin = System.currentTimeMillis(); threadService.shutdown(3000); long end = System.currentTimeMillis(); System.out.println(\"耗时： \" + (end - begin)); System.out.println(\"主线程执行结果\"); } /** * 跟随threadService的执行而结束，无需等待3秒（1秒后就可以执行主线程后续的代码） */ @Test public void test2() { ThreadService threadService = new ThreadService(); threadService.execute(() -> { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } }); //让线程2秒后立即中断执行 long begin = System.currentTimeMillis(); threadService.shutdown(3000); long end = System.currentTimeMillis(); System.out.println(\"耗时： \" + (end - begin)); System.out.println(\"主线程执行结果\"); }} 5.5、interrupt()、interrupted()、isInterrupted()区别与原理5.5.1、结论 interrupt()方法：用于中断线程的，调用该方法的线程的状态将被置为”中断”状态。注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理。支持线程中断的方法（也就是线程中断后会抛出InterruptedException的方法，比如Thread.sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常,并将线程的中断状态为设置为false。 interrupted()：返回线程是否处于已中断状态并清除中断状态 isInterrupted()：返回线程是否处于已中断状态 5.5.2、原理以下内容来源于 https://my.oschina.net/itblog/blog/787024 Code1234567891011121314151617181920212223242526public class Interrupt { public static void main(String[] args) throws Exception { Thread t = new Thread(new Worker()); t.start(); Thread.sleep(200); t.interrupt(); System.out.println(\"Main thread stopped.\"); } public static class Worker implements Runnable { public void run() { System.out.println(\"Worker started.\"); try { Thread.sleep(500); } catch (InterruptedException e) { System.out.println(\"Worker IsInterrupted: \" + Thread.currentThread().isInterrupted()); } System.out.println(\"Worker stopped.\"); } }} 内容很简单：主线程main启动了一个子线程Worker，然后让worker睡500ms，而main睡200ms，之后main调用worker线程的interrupt方法去中断worker，worker被中断后打印中断的状态。下面是执行结果： Code1234Worker started.Main thread stopped.Worker IsInterrupted: falseWorker stopped. Worker明明已经被中断，而isInterrupted()方法竟然返回了false，为什么呢？ 在stackoverflow上搜索了一圈之后，发现有网友提到：可以查看抛出InterruptedException方法的JavaDoc（或源代码），于是我查看了Thread.sleep方法的文档，doc中是这样描述这个InterruptedException异常的： InterruptedException - if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown. 注意到后面这句“当抛出这个异常的时候，中断状态已被清除”。所以isInterrupted()方法应该返回false。可是有的时候，我们需要isInterrupted这个方法返回true，怎么办呢？这里就要先说说interrupt, interrupted和isInterrupted的区别了： interrupt方法是用于中断线程的，调用该方法的线程的状态将被置为”中断”状态。注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出InterruptedException的方法，比如这里的sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。这个观点可以通过这篇文章证实： 再来看看interrupted方法的实现： Code123public static boolean interrupted() { return currentThread().isInterrupted(true);} 和isInterrupted的实现： Code123public boolean isInterrupted() { return isInterrupted(false);} 这两个方法一个是static的，一个不是，但实际上都是在调用同一个方法，只是interrupted方法传入的参数为true，而iInterrupted传入的参数为false。那么这个参数到底是什么意思呢？来看下这个isInterrupted(boolean)方法的实现： Code123456/** * Tests if some Thread has been interrupted. The interrupted state * is reset or not based on the value of ClearInterrupted that is * passed. */private native boolean isInterrupted(boolean ClearInterrupted); 这是一个native方法，看不到源码没有关系，参数名字ClearInterrupted已经清楚的表达了该参数的作用—-是否清除中断状态。方法的注释也清晰的表达了“中断状态将会根据传入的ClearInterrupted参数值确定是否重置”。所以，静态方法interrupted将会清除中断状态（传入的参数ClearInterrupted为true），而实例方法isInterrupted则不会（传入的参数ClearInterrupted为false）。回到刚刚的问题：很明显，如果要isInterrupted这个方法返回true，通过在调用isInterrupted方法之前再次调用interrupt()方法来恢复这个中断的状态即可： Code12345678910111213141516171819202122232425262728293031323334public class Interrupt { public static void main(String[] args) throws Exception { Thread t = new Thread(new Worker()); t.start(); Thread.sleep(200); t.interrupt(); System.out.println(\"Main thread stopped.\"); } public static class Worker implements Runnable { public void run() { System.out.println(\"Worker started.\"); try { Thread.sleep(500); } catch (InterruptedException e) { Thread curr = Thread.currentThread(); //再次调用interrupt方法中断自己，将中断状态设置为“中断” curr.interrupt(); System.out.println(\"Worker IsInterrupted: \" + curr.isInterrupted()); System.out.println(\"Worker IsInterrupted: \" + curr.isInterrupted()); System.out.println(\"Static Call: \" + Thread.interrupted());//clear status System.out.println(\"---------After Interrupt Status Cleared----------\"); System.out.println(\"Static Call: \" + Thread.interrupted()); System.out.println(\"Worker IsInterrupted: \" + curr.isInterrupted()); System.out.println(\"Worker IsInterrupted: \" + curr.isInterrupted()); } System.out.println(\"Worker stopped.\"); } }} 执行结果： Code12345678910Worker started.Main thread stopped.Worker IsInterrupted: trueWorker IsInterrupted: trueStatic Call: true---------After Interrupt Status Cleared----------Static Call: falseWorker IsInterrupted: falseWorker IsInterrupted: falseWorker stopped. 从执行结果也可以看到，前两次调用isInterrupted方法都返回true，说明isInterrupted方法不会改变线程的中断状态，而接下来调用静态的interrupted()方法，第一次返回了true，表示线程被中断，第二次则返回了false，因为第一次调用的时候已经清除了中断状态。最后两次调用isInterrupted()方法就肯定返回false了。 那么，在什么场景下，我们需要在catch块里面中断线程（重置中断状态）呢？ 答案是：如果不能抛出InterruptedException（就像这里的Thread.sleep语句放在了Runnable的run方法中，这个方法不允许抛出任何受检查的异常），但又想告诉上层调用者这里发生了中断的时候，就只能在catch里面重置中断状态了。 Code12345678910111213141516171819public class TaskRunner implements Runnable { private BlockingQueue queue; public TaskRunner(BlockingQueue queue) { this.queue = queue; } public void run() { try { while (true) { Task task = queue.take(10, TimeUnit.SECONDS); task.execute(); } } catch (InterruptedException e) { // Restore the interrupted status Thread.currentThread().interrupt(); } }} 那么问题来了：为什么要在抛出InterruptedException的时候清除掉中断状态呢？ 这个问题没有找到官方的解释，估计只有Java设计者们才能回答了。但这里的解释似乎比较合理：一个中断应该只被处理一次（你catch了这个InterruptedException，说明你能处理这个异常，你不希望上层调用者看到这个中断）。 参考地址： https://my.oschina.net/itblog/blog/787024 http://stackoverflow.com/questions/7142665/why-does-thread-isinterrupted-always-return-false http://stackoverflow.com/questions/2523721/why-do-interruptedexceptions-clear-a-threads-interrupted-status http://www.ibm.com/developerworks/library/j-jtp05236/ http://blog.csdn.net/z69183787/article/details/25076033 6、synchronized6.1、示例代码Code12345678910111213141516171819202122232425262728293031323334package chapter2;/** * @author calebzhao * 2019/6/29 17:11 */public class SynchronizedDemo { private static final Object LOCK = new Object(); public static void main(String[] args) { Runnable runnable = () -> { synchronized (LOCK){ System.out.println(Thread.currentThread().getName() +\"正在执行\"); try { Thread.sleep(60_000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +\"执行结束\"); } }; Thread thread1 = new Thread(runnable); Thread thread2 = new Thread(runnable); Thread thread3 = new Thread(runnable); thread1.start(); thread2.start(); thread3.start(); System.out.println(\"主线程执行结束\"); }} 6.2、通过jconsole查看通过在cmd输入jconsole命令显示如下界面： 选中本地进程中刚刚运行的java程序， 进入主界面 可以看到 Thread-0 、Thread-1、Thread-2运行的三个线程，点击对应线程右边可以看到“拥有者 Thread-0” 6.3、通过jps、jstack查看 启动程序后： 第1步：输入jps命令， 查看当前正在运行的java进程 第2步: 输入jstack [pid] 可以看到有三个线程 Thread-1、Thread-2均处于BLOCKED(on object nonitor)状态、而Thread-0处于TIMED_WATING(sleepint)状态（因为Thread.sleep()的作用） 6.4、通过javap -c [xxxx.class]命令查看汇编指令 6.5 this锁含义：指在方法上面加上synchronized 关键字 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package chapter2;/** * @author calebzhao * 2019/6/29 17:56 */public class ThisLockDemo { public static void main(String[] args) { ThisLock thisLock = new ThisLock(); Thread thread1 = new Thread(() -> { thisLock.m1(); }); Thread thread2 = new Thread(() -> { thisLock.m2(); }); thread1.start(); thread2.start(); System.out.println(\"主线程结束执行\"); }}class ThisLock{ public synchronized void m1(){ System.out.println(Thread.currentThread().getName() +\" m1开始执行\"); try { Thread.sleep(10_000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +\" m1结束执行\"); } public synchronized void m2(){ System.out.println(Thread.currentThread().getName() +\" m2开始执行\"); try { Thread.sleep(10_000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +\" m2结束执行\"); }} 运行结果： 可以看到Thread-1 m2的执行必须要等待Thread-0 m1执行完毕后才能执行， 说明同一个类在方法上面加上synchronized关键字所使用的的锁是this锁 6.6 class锁介绍：在static方法上加synchronized关键所使用的的锁是class锁 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package chapter2;/** * @author calebzhao * 2019/6/29 18:29 */public class ClassLockDemo { public static void main(String[] args) { ClassLock classLock1 = new ClassLock(); ClassLock classLock2 = new ClassLock(); Thread thread1 = new Thread(() -> { classLock1.m1(); }); Thread thread2 = new Thread(() -> { classLock2.m2(); }); thread1.start(); thread2.start(); System.out.println(\"主线程结束执行\"); }}class ClassLock{ public static synchronized void m1(){ System.out.println(Thread.currentThread().getName() +\" m1开始执行\"); try { Thread.sleep(10_000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +\" m1结束执行\"); } public static synchronized void m2(){ System.out.println(Thread.currentThread().getName() +\" m2开始执行\"); try { Thread.sleep(10_000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +\" m2结束执行\"); }} 可以看到Thread-1 m2的执行必须要等待Thread-0 m1执行完毕后才能执行， 说明同一个类的多个实例在static方法上面加上synchronized关键字所使用的的锁是class锁 6.7 死锁Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package chapter2;/** * @author calebzhao * 2019/6/29 18:33 */public class DieLockDemo { public static void main(String[] args) { DieLock dieLock = new DieLock(); Thread thread1 = new Thread(() ->{ dieLock.doSomething1(); }); Thread thread2 = new Thread(() ->{ dieLock.doSomething2(); }); thread1.start(); thread2.start(); System.out.println(\"主线程执行完毕\"); }}class DieLock{ private final Object LOCK1 = new Object(); private final Object LOCK2 = new Object(); public void doSomething1(){ synchronized (LOCK1){ try { // 代表一个耗时操作 Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"获取到LOCK1， 等待LOCK2\"); synchronized (LOCK2){ System.out.println(\"doSomething1\"); } } } public void doSomething2(){ synchronized (LOCK2){ try { // 代表一个耗时操作 Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"获取到LOCK2, 等待LOCK1\"); synchronized (LOCK1){ System.out.println(\"doSomething2\"); } } }} 6.8、synchronzied锁重入关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程获得一个对象锁，再次请求该对象锁时是可以获得该对象的锁的。表现在一个synchronized方法 / 块的内部调用本类的其他synchronized方法 / 块时，是永远可以得到锁的。 Code123456789101112131415161718192021222324package chapter2;/** * @author calebzhao * 2019/9/1 15:43 */public class SynchronizedReentrantDemo { public synchronized void methodA(){ System.out.println(\"methodA invoked \"); this.methodB(); } public synchronized void methodB(){ System.out.println(\"methodB invoked \"); } public static void main(String[] args) { SynchronizedReentrantDemo demo = new SynchronizedReentrantDemo(); demo.methodA(); }} 可以看到在synchronized方法methodsA中调用被synchronized修饰的methodB()也是可以的，即使methodA()还没有释放this锁，这证明了synchronzied锁是可以重入的 6.9、synchronized的原理Java中synchronized的锁实现包括：偏向锁、轻量级锁、重量级锁（等待时间长） 1个对象的实例包括3部分：对象头、实例变量、填充数据 对象头：实现synchronized的锁对象的基础 实例变量: 存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。 填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。 synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成，其结构说明如下表： 其中Mark Word在默认情况下存储着对象的HashCode、分代年龄、锁标记位等以下是32位JVM的Mark Word默认存储结构 由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如32位JVM下，除了上述列出的Mark Word默认存储结构外，还有如下可能变化的结构： 其中轻量级锁和偏向锁是Java 6 对 synchronized 锁进行优化后新增加的，稍后我们会简要分析。这里我们主要分析一下重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的） Code123456789101112131415161718ObjectMonitor() { _header = NULL; _count = 0; //记录个数 _waiters = 0, _recursions = 0; _object = NULL; _owner = NULL; _WaitSet = NULL; //处于wait状态的线程，会被加入到_WaitSet _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ; //处于等待锁block状态的线程，会被加入到该列表 _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; } ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示 由此看来，monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因(关于这点稍后还会进行分析)，ok~，有了上述知识基础后，下面我们将进一步分析synchronized在字节码层面的具体语义实现。 6.10、synchronized底层实现原理为了分析底层原理，我们编写1个最简单的类，代码如下： Code123456789101112131415161718package chapter2;/** * @author calebzhao * @date 2019/11/30 18:41 */public class SynchronizedDemo2 { public synchronized static void test1(){ System.out.println(\"test1\"); } public synchronized void test2(){ System.out.println(\"test2\"); } public void test3(){ synchronized (this){ System.out.println(\"test4\"); } }} 6.10.1、synchronized方法底层原理：方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。下面我们看看字节码层面如何实现： 通过执行javap -v SynchroizedDemo2.class会输出如下字节码指令： test1()方法对应的字节码指令： test2()方法对应的字节码指令： 从字节码中可以看出，synchronized修饰的方法并没有monitorenter指令和monitorexit指令，取得代之的确实是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。这便是synchronized锁在同步代码块和同步方法上实现的基本原理。同时我们还必须注意到的是在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了，Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，接下来我们将简单了解一下Java官方在JVM层面对synchronized锁的优化。 6.10.2、synchonized代码块底层实现原理：test3()方法对应的字节码指令： JSR133的解释： synchronized 语句需要一个对象的引用；随后会尝试在该对象的管程上执行 lock 动 作，如果 lock 动作未能成功完成，将一直等待。当 lock 动作执行成功，就会运行synchronized 语句块中的代码。一旦语句块中的代码执行结束，不管是正常还是异 常结束，都会在之前执行 lock 动作的那个管程上自动执行一个 unlock 动作。 synchronized 方法在调用时会自动执行一个 lock 动作。在 lock 动作成功完成之前， 都不会执行方法体。如果是实例方法，锁的是调用该方法的实例（即，方法体执行 期间的 this）相关联的管程。如果是静态方法，锁的是定义该方法的类所对应的 Class 对象。一旦方法体执行结束，不管是正常还是异常结束，都会在之前执行 lock 动作的那个管程上自动执行一个 unlock 动作。 从字节码中可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。 6.11、Java虚拟机对synchronized的优化锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段，这里并不打算深入到每个锁的实现和转换过程更多地是阐述Java虚拟机所提供的每个锁的核心优化思想，毕竟涉及到具体过程比较繁琐，如需了解详细过程可以查阅《深入理解Java虚拟机原理》。 6.11.1、偏向锁偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。 6.11.2、轻量级锁倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。 6.11.3、自旋锁轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。 6.11.4、锁消除消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。 java12345678910111213141516public class StringBufferRemoveSync { public void add(String str1, String str2) { //StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用 //因此sb属于不可能共享的资源,JVM会自动消除内部的锁 StringBuffer sb = new StringBuffer(); sb.append(str1).append(str2); } public static void main(String[] args) { StringBufferRemoveSync rmsync = new StringBufferRemoveSync(); for (int i = 0; i < 10000000; i++) { rmsync.add(\"abc\", \"123\"); } }} 7、wait、notify方法7.1、含义（需仔细研读） wait()、notify()是Object类的方法， 调用这2个方法前，执行线程必须已经获得改对象的对象锁，即只能在同步方法或同步代码块中调用wait() 或者notify()方法，如果调用这2个方法时没有获得对象锁将会抛出IllegalMonitorStateException异常 调用wait()方法后，当前线程立即释放已经获得的锁，并且将当前线程置入“预执行队列(WaitSet)中”， 并且在wait()所在的代码处停止执行，必须直到收到notify()方法的通知或者被中断执行当前线程才能被唤醒继续往wait()方法后面的代码执行 notitify()方法用来通知那些等待获取该对象锁的线程， 如果有多个线程等待，则由线程规划器随机挑选出一个处于wait状态的线程B，对其发出Notify通知，使B退出等待队列，处于就绪状态，被重新唤醒的线程B会尝试获取临界区的对象锁，被唤醒线程B在真正获取到锁后就会继续执行wait()后面的代码。需要说明的是，在执行notify()方法后，并不会使当前线程A马上释放对象锁，处于wait状态的线程B也不能马上获取对象锁，要等到执行notify()方法的线程A将程序执行完，也就是退出synchronized代码块后，当前线程A才会释放对象锁，但是释放之后并不代表线程B就一定会获取到对象锁，只是说此时A、B都有机会竞争获取到对象锁 如果notify()方法执行时，此时并没有任何线程处于wait状态，那么执行该方法相当于无效操作 notify()与notifyAll()的区别是：notify()方法每次调用时都只是从所有处于wait状态的线程中随机选择一个线程进入就绪状态，而notifyAll()则是使所有处于wait状态的线程全部退出等待队列，全部进入就绪状态，此处唤醒不等于所有线程都获得该对象的monitor，此时优先级最高的那个线程优先执行(获得对象锁)，但也有可能是随机执行(获得对象锁)，这要取决于jvm实现 7.2、生产者消费者模式7.2.1、 版本1产生假死(全部进入等待wait状态)java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package chapter2;import java.util.stream.Stream;/** * @author calebzhao * 2019/6/30 7:44 */public class ProducerAndConsumerVersion1 { private final Object LOCK = new Object(); private boolean isProduced; private int num = 0; public static void main(String[] args) { ProducerAndConsumerVersion1 version1 = new ProducerAndConsumerVersion1(); Stream.of(\"P1\", \"P2\", \"P3\", \"P4\").forEach((item) ->{ new Thread(() ->{ while (true) { version1.produce(); } }, item).start(); }); Stream.of(\"C1\").forEach(item ->{ new Thread(() ->{ while (true) { version1.consumer(); } }, item).start(); }); System.out.println(\"主线程执行结束\"); } public void produce(){ synchronized (LOCK){ if (isProduced){ try { System.out.println(\"[\" + Thread.currentThread().getName() +\"] produce wait\"); LOCK.wait(); System.out.println(\"[\" + Thread.currentThread().getName() +\"] produce wait after\"); } catch (InterruptedException e) { e.printStackTrace(); } } else { num++; System.out.println(\"[\" + Thread.currentThread().getName() + \"] P ==>\" + num); isProduced=true; LOCK.notify(); System.out.println(\"[\" + Thread.currentThread().getName() + \"] notify after\"); } } } public void consumer(){ synchronized (LOCK){ if (isProduced){ System.out.println(\"[\" + Thread.currentThread().getName() + \"] C ==>\" + num); isProduced = false; LOCK.notify(); System.out.println(\"[\" + Thread.currentThread().getName() + \"] notify after\"); } else { try { System.out.println(\"[\" + Thread.currentThread().getName() +\"] consumer wait\"); LOCK.wait(); System.out.println(\"[\" + Thread.currentThread().getName() +\"] consumer wait after\"); } catch (InterruptedException e) { e.printStackTrace(); } } } }} 以上代码执行永远不会结束，所有线程最终都变为wait状态（没有发生死锁） 7.2.2、多消费者、多生产者正确版本Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package chapter2;import java.util.stream.Stream;/** * @author calebzhao * 2019/6/30 7:44 */public class ProducerAndConsumerVersion2 { private final Object LOCK = new Object(); private boolean isProduced; private int num = 0; public static void main(String[] args) { ProducerAndConsumerVersion2 version1 = new ProducerAndConsumerVersion2(); Stream.of(\"P1\", \"P2\", \"P3\", \"P4\").forEach((item) ->{ new Thread(() ->{ while (true) { version1.produce(); } }, item).start(); }); Stream.of(\"C1\", \"C2\", \"C3\", \"C4\").forEach(item ->{ new Thread(() ->{ while (true) { version1.consumer(); } }, item).start(); }); System.out.println(\"主线程执行结束\"); } public void produce(){ synchronized (LOCK){ while (isProduced){ try { System.out.println(\"[\" + Thread.currentThread().getName() +\"] produce wait\"); LOCK.wait(); System.out.println(\"[\" + Thread.currentThread().getName() +\"] produce wait after\"); } catch (InterruptedException e) { e.printStackTrace(); } } num++; System.out.println(\"[\" + Thread.currentThread().getName() + \"] P ==>\" + num); isProduced=true; LOCK.notifyAll(); System.out.println(\"[\" + Thread.currentThread().getName() + \"] notify after\"); } } public void consumer(){ synchronized (LOCK){ while (!isProduced){ try { System.out.println(\"[\" + Thread.currentThread().getName() +\"] consumer wait\"); LOCK.wait(); System.out.println(\"[\" + Thread.currentThread().getName() +\"] consumer wait after\"); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"[\" + Thread.currentThread().getName() + \"] C ==>\" + num); isProduced = false; LOCK.notifyAll(); System.out.println(\"[\" + Thread.currentThread().getName() + \"] notify after\"); } }} 7.2.3、多生产者、多消费者， 阻塞, 错误版本，浪费执行机会Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package chapter2;import java.util.LinkedList;import java.util.stream.Stream;/** * @author calebzhao * 2019/6/30 7:44 */public class ProducerAndConsumerVersion3 { private final Object LOCK = new Object(); private boolean isProduced; private int num = 0; public static void main(String[] args) { Container container = new Container(10); Producer producer = new Producer(container); Consumer consumer = new Consumer(container); Stream.of(\"P1\", \"P2\", \"P3\", \"P4\").forEach((item) ->{ new Thread(() ->{ while (true) { producer.produce(); } }, item).start(); }); Stream.of(\"C1\", \"C2\", \"C3\", \"C4\").forEach(item ->{ new Thread(() ->{ while (true) { consumer.consume(); } }, item).start(); }); System.out.println(\"主线程执行结束\"); }}class Producer{ private Container container; private int i = 0; public Producer(Container container){ this.container = container; } public void produce(){ while (true){ synchronized (container){ if (container.isOverflow()){ try { container.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } else{ container.push(++i); System.out.println(\"[\" + Thread.currentThread().getName() +\"] produce \" + i); container.notifyAll(); } } try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } }}class Consumer{ private Container container; public Consumer(Container container){ this.container = container; } public void consume(){ while (true){ synchronized (container){ if (container.isEmpty()){ try { container.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } // 这里其实是有问题的， 假设A、B线程都执行到container.wait();处于wait状态， 此时生产者执行了container.notifyAll(); // A线程获得了对象锁， 从container.wait();处往后执行，但是由于这里用的是if..else结构， // 所以会导致A线程刚被唤醒获得了对象锁，又什么都不做，马上又释放了对象锁，假设A线程的CPU时间片刚好用完又让B获得了对象锁， // 可能出现后续都一直是B获得CPU实现片获得对象锁，而A明明之前获得过一次对象锁却啥事也不干，白白浪费了一次执行机会 else { Object value = container.pop(); System.out.println(\"[\" + Thread.currentThread().getName() +\"] consume \" + value); container.notifyAll(); } } } }}class Container{ private LinkedList storage; private int capticy; public Container(int capticy){ this.storage = new LinkedList(); this.capticy = capticy; } public void push(Object obj){ this.storage.addLast(obj); } public Object pop(){ return this.storage.removeFirst(); } public int size(){ return this.storage.size(); } public boolean isOverflow(){ return size() >= capticy; } public boolean isEmpty(){ return this.storage.isEmpty(); }} 7.2.4、完全正确版本Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153package 生产者消费者模式;import java.util.LinkedList;import java.util.stream.Stream;/** * @author calebzhao * 2019/6/30 7:44 */@SuppressWarnings(\"ALL\")public class ProducerAndConsumerVersion4 { private final Object LOCK = new Object(); private boolean isProduced; private int num = 0; public static void main(String[] args) { Container2 container = new Container2(10); Producer2 producer = new Producer2(container); Consumer2 consumer = new Consumer2(container); Stream.of(\"P1\", \"P2\", \"P3\", \"P4\").forEach((item) -> { new Thread(() ->{ while (true) { producer.produce(); } }, item).start(); }); Stream.of(\"C1\", \"C2\", \"C3\", \"C4\").forEach(item ->{ new Thread(() -> { while (true) { consumer.consume(); } }, item).start(); }); System.out.println(\"主线程执行结束\"); }}@SuppressWarnings(\"ALL\")class Producer2 { private Container2 container; private int i = 0; public Producer2(Container2 container){ this.container = container; } public void produce(){ synchronized (container){ // 这里的while不能换成if // 假设container现在是满的，C线程消费了一个个，然后调用container.notifyAll();通知A、B线程唤醒 // A、B线程从container.wait();这一行代码处唤醒后处于就绪状态， A获得锁， 往container.wait();后面执行， // A执行 container.push(++i); 执行完后container满了，A执行完synchronized代码块释放锁， 紧接着B获取到锁一样从 // container.wait();往后执行，假如这里while换成if, 那么B就会又执行container.push(++i); // 导致容器满了仍然向container push数据，这样就出现错误数据了 while (container.isOverflow()) { try { container.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } container.push(++i); System.out.println(\"[\" + Thread.currentThread().getName() +\"] produce \" + i); container.notifyAll(); } try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } }}@SuppressWarnings(\"ALL\")class Consumer2{ private Container2 container; public Consumer2(Container2 container){ this.container = container; } public void consume(){ synchronized (container){ // 这里的while不能换成if // 假设A、B线程都执行到container.wait();这行代码处，A、B处于wait状态， 此时生产者执行了container.notifyAll(); // 然后A线程获得了对象锁， 从container.wait();处往后执行，A调用container.pop()后container变为空的 // 假设这里while换成if, 那么会出现紧接着B获得了对象锁，一样地从从container.wait();处往后执行，但是container已经是空的了 // 任然调用container.pop()就会报出ArrayIndeOutOfBoundExeption了 while (container.isEmpty()){ try { container.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } Object value = container.pop(); System.out.println(\"[\" + Thread.currentThread().getName() +\"] consume \" + value); container.notifyAll(); } }}class Container2{ private LinkedList storage; private int capticy; public Container2(int capticy){ this.storage = new LinkedList(); this.capticy = capticy; } public void push(Object obj){ this.storage.addLast(obj); } public Object pop(){ return this.storage.removeFirst(); } public int size(){ return this.storage.size(); } public boolean isOverflow(){ return size() >= capticy; } public boolean isEmpty(){ return this.storage.isEmpty(); }} 8 、捕获线程运行期间的异常Code123456789101112131415161718192021222324252627282930package chapter2;/** * @author calebzhao * 2019/7/1 22:03 */public class ExceptionCaught { public static void main(String[] args) { Thread mythread = new Thread(() ->{ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } }, \"mythread\"); // 捕获异常 mythread.setUncaughtExceptionHandler((thread, throwable) ->{ System.out.println(thread.getName()); throwable.printStackTrace(); }); mythread.start(); mythread.interrupt(); }} 9、ThreadGroupCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package chapter2;import java.util.stream.Stream;/** * @author calebzhao * 2019/7/1 20:27 */public class ThreadGroupDemo { public static void main(String[] args) { // main方法也是一个线程， 其名称为main System.out.println(Thread.currentThread().getName()); // main线程的线程组的名称是main System.out.println(Thread.currentThread().getThreadGroup().getName()); // 创建线程组tg1 ThreadGroup tg1 = new ThreadGroup(\"tg1\"); new Thread(tg1, \"t1\"){ @Override public void run() { try { Thread.sleep(1000); //获取当前线程组的名称 System.out.println(this.getThreadGroup().getName()); //获取当前线程组的父线程组 System.out.println(this.getThreadGroup().getParent()); //获取当前线程组的父线程组的名称 System.out.println(this.getThreadGroup().getParent().getName()); //评估当前线程组的父线程组及子级的线程数量 System.out.println(this.getThreadGroup().getParent().activeCount()); System.out.println(\"--------------\"); } catch (InterruptedException e) { e.printStackTrace(); } } }.start(); // 创建线程组tg2 ThreadGroup tg2 = new ThreadGroup(\"tg2\"); tg2.setDaemon(true); Stream.of(\"T1\", \"T2\", \"T3\").forEach(name ->{ new Thread(tg2, name){ @Override public void run() { System.out.println(this.getThreadGroup().getName()); System.out.println(tg1.getParent()); System.out.println(this.getThreadGroup().getParent().getName()); // 评估父线程组下的线程数量 System.out.println(this.getThreadGroup().getParent().activeCount()); Thread[] threads = new Thread[tg1.activeCount()]; this.getThreadGroup().enumerate(threads); Stream.of(threads).forEach(System.out::println); System.out.println(\"***************\"); // 测试某个线程是parentOf(group)参数中group的父线程（直接或间接） System.out.println(\"parentOf: \" + this.getThreadGroup().getParent().parentOf(this.getThreadGroup())); System.out.println(Thread.currentThread().getName() +\" isDaemon:\" + this.isDaemon()); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } }.start(); }); // 打断整个线程组下的所有线程 tg2.interrupt(); }} 10、单例设计模式version1 （不好）Code12345678910111213141516 package chapter3.singleton;/** * 问题是不能懒加载， 在类加载的时候就会初始化instance * * @author calebzhao * 2019/7/4 19:47 */public class SingletonVersion1 { private static final SingletonVersion1 instance = new SingletonVersion1(); public static SingletonVersion1 getInstance(){ return instance; }} version2 (错误)Code12345678910111213141516171819202122232425package chapter3.singleton;/** * @author calebzhao * 2019/7/4 19:47 */public class SingletonVersion2 { private static SingletonVersion2 instance ; private SingletonVersion2(){ } /** * 多线程并发访问时可能同时进入if代码里，造成多次实例化 * @return */ public static SingletonVersion2 getInstance(){ if (instance == null){ instance = new SingletonVersion2(); } return instance; } } version3 (不好)Code1234567891011121314151617181920212223242526package chapter3.singleton;/** * @author calebzhao * 2019/7/4 19:47 */public class SingletonVersion3 { private static SingletonVersion3 instance ; private SingletonVersion3(){ } /** * 会有性能问题， 实例化后每次读取都要同步 * * @return */ public static synchronized SingletonVersion3 getInstance(){ if (instance == null){ instance = new SingletonVersion3(); } return instance; }} version4 (不好)jvm指令重排序可能NullPointerException Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package chapter3.singleton;/** * @author calebzhao * 2019/7/4 19:47 */public class SingletonVersion4 { private static SingletonVersion4 instance ; private static Object LOCK = new Object(); private boolean init; private SomeObject someObject = null; private SingletonVersion4(){ init = true;// try {// Thread.sleep(3000);// } catch (InterruptedException e) {// e.printStackTrace();// } someObject = new SomeObject(); } /** * 貌似没问题，但是极端情况会有NPL空指针异常问题， 比如这个类里有一些变量， 这些变量在构造方法里初始化 * 当有多个线程调用getInstance时， 第一个线程访问时instance为null会进行实例化， 这是会在堆内存分配内存空间 * 分配完内存空间，但是构造方法并没有执行完， 此时第二个线程访问时instance不为null返回Instance实例，直接调用里面的方法 * new SingletonVersion4() * * @return */ public static SingletonVersion4 getInstance(){ if (instance == null){ synchronized (LOCK){ if (instance == null){ instance = new SingletonVersion4(); } } } return instance; } public void print(){ this.someObject.doSomething(); } public static void main(String[] args) { Thread t1 = new Thread(() ->{ SingletonVersion4.getInstance(); }, \"t1\"); Thread t2 = new Thread(() ->{ SingletonVersion4.getInstance().print(); }, \"t2\"); t1.start(); t2.start(); }}class SomeObject{ public void doSomething(){ System.out.println(Thread.currentThread().getName() + \" doSomething...\"); }} version5 (正确、推荐)Code123456789101112131415161718192021222324252627package chapter3.singleton;/** * @author calebzhao * 2019/7/4 19:47 */public class SingletonVersion5 { private SingletonVersion5(){ } private static class Singleton{ private static final SingletonVersion5 INSTANCE = new SingletonVersion5(); } /** * 貌似没问题，但是极端情况会有NPL空指针异常问题， 比如这个类里有一些变量， 这些变量在构造方法里初始化 * 当有多个线程调用getInstance时， 第一个线程访问时instance为null会进行实例化， 这是会在堆内存分配内存空间 * 分配完内存空间，但是构造方法并没有执行完， 此时第二个线程访问时instance不为null返回Instance实例，直接调用里面的方法 * new SingletonVersion4() * * @return */ public static SingletonVersion5 getInstance(){ return Singleton.INSTANCE; }} version 6 （正确）Code1234567891011121314151617181920212223242526package chapter3.singleton;/** * @author calebzhao * 2019/7/4 19:47 */public class SingletonVersion6 { private SingletonVersion6(){ } enum Singleton{ INSTANCE; private SingletonVersion6 singletonVersion6 = new SingletonVersion6(); public SingletonVersion6 getInstance(){ return singletonVersion6; } } public static SingletonVersion6 getInstance(){ return Singleton.INSTANCE.getInstance(); }} 11、volatile关键字11.1 高并发的三个特性 原子性 例如 i = 9; 在16位计算机中 可能是16 16位分2次赋值的，比如低16位赋值成功、高16位赋值失败。 在一个或多个操作中，要么全部成功，要么全部失败，不能有中间状态。 a = 1; 保证原子性 a++; 非原子性，执行步骤：1：读取a; 2: 对a加1； 3：将结果赋值给a a = 1+2 保证原子性， 编译期会确定值 a = a+1 ** 非原子性**，执行步骤：1：读取a; 2: 对a加1； 3：将结果赋值给a 证明 ++value 操作不是原子性的 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package volatileDemo;/** * @author calebzhao * 2019/7/8 22:01 */public class AtomDemo { private static int initValue = 1; private static int maxValue = 500; /** * 证明++initValue操作不是原子性的， * * 假设如下2种情况： * 1、如果 ++initValue操作是原子性的， 那么输出一定不会有重复的 * 2、如果 ++initValue操作不熟原子性的，而是拆分成1、读取initValue; 2其他操作，那么可能多个线程读取到一样的initValue * * 那么可能出现如下情况： * t1 -> 读取 initValue值为10， cpu执行权被切换到t2 * t2 -> 读取 initValue值为10, * t2 -> 11 = 10 +1 * t2 -> initValue = 11 * t2 -> System.out.printf(\"t2 执行后结果 [%d] \\n\", 11); * t1 -> 11 = 10 +1 * t1 -> initValue = 11 * t1 -> System.out.printf(\"t1 执行后结果 [%d] \\n\", 11); * * @param args */ public static void main(String[] args) { new Thread(() ->{ while (initValue < maxValue){ System.out.printf(\"t1 执行后结果 [%d] \\n\", ++initValue); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); new Thread(() ->{ while (initValue < maxValue){ System.out.printf(\"t2 执行后结果 [%d] \\n\", ++initValue); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); }} 可见性 volatile关键字会保证多线程下的内存可见性及指令执行的有序性 https://www.cnblogs.com/yanlong300/p/8986041.html 例子： Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package volatileDemo;/** * @author calebzhao * 2019/7/8 21:25 */public class VolatileDemo { private static int initValue = 1; private static int MAX_VALUE = 50; public static void main(String[] args) { new Thread(() ->{ int localValue = initValue; while (localValue < MAX_VALUE){// System.out.printf(\"t1线程读取到initValue的值为 [%d] localValue：[%d]\\n\", initValue, localValue); if (localValue != initValue){ localValue = initValue; System.out.printf(\"initValue的值已被更新为 [%d]\\n\", initValue); }// else{// System.out.printf(\"t1线程读取到initValue的值为 [%d] localValue：[%d]\\n\", initValue, localValue);// } } System.out.println(\"t1线程结束执行\"); }, \"t1\").start(); new Thread(() ->{ int localValue = initValue; while (initValue < MAX_VALUE){ localValue++; initValue = localValue; System.out.printf(\"更新initValue的值为 [%d]\\n\", initValue); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"t2线程结束执行\"); }, \"t2\").start(); }} 当private static volatile int *initValue *= 1; 这句代码加上volatile 关键字就是正确的结果了 有序性Code12345678910111213value = 3；void exeToCPUA(){ value = 10; # 可能发生重排序 value的赋值发生在isFinsh之后 isFinsh = true;}void exeToCPUB(){ if(isFinsh){ //value一定等于10？！ assert value == 10; }} 试想一下开始执行时，CPU A保存着finished在E(独享)状态，而value并没有保存在它的缓存中。（例如，Invalid）。在这种情况下，value会比finished更迟地抛弃存储缓存。完全有可能CPU B读取finished的值为true，而value的值不等于10。 ** 即isFinsh的赋值在value赋值之前。** 这种在可识别的行为中发生的变化称为重排序（reordings）。注意，这不意味着你的指令的位置被恶意（或者好意）地更改。 它只是意味着其他的CPU会读到跟程序中写入的顺序不一样的结果。 为什么会有指令的重排序？ 答案：因为为了使缓存能够得到更加合理地利用。 Code12int a=1int b=2 省略一万行代码…int c=a+b 最后一句放第三行就能让缓存更合理, 原因：cpu将a=1读入CPU高速缓存，然后将b=2读入高速缓存，由于CPU高速缓存的容量很小，所以当执行后面的一万行代码时CPU高速缓存满了，那么就会把a=1、b=2这2个缓存行覆盖掉，当真正执行int c= a+ b时由于CPU高速缓存里面没有数据那么CPU就要重新从主存读取数据然后计算，这样就出现了不必须的重复读取主存的操作，浪费CPU，通过重指令排序让int c=a+b放到第三行则可以缓存能够立即得到利用，将c=a+b的结果计算后可以立即回写主内存，避免后续a=1、b=2的缓存行被其他指令的缓存行覆盖 11.2、volatile的内存语义 12、比较并交换（CAS)12.1、使用CAS与使用锁相比的好处与锁相比，使用比较并交换（CAS）会使程序看起来更复杂，但由于其非阻塞性，它对死锁问题天生免疫，并且线程间的影响也远远比基于锁的方式小的多。更为重要的是，使用无锁的方式完全没有锁竞争带来的开销，也没有线程间频繁调度调来的开销，因此它比基于锁的方式拥有更优越的性能。 12.2、CAS原理CAS算法的过程是：它包含3个参数CAS(realValue, expectValue, newValue), 其中realValue表示要更新的变量，expectValue表示预期值，newValue表示新值。仅当realValue等与expectValue值时，才将realValue的值变更为newValue，如果realValue与expectValue不相等，说明有其他线程已经更新做了更新，则当前线程什么也不做，最后CAS返回当前realValue的真实值。CAS是抱着乐观的态度去进行的，它总是认为自己可以完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然允许失败的线程放弃操作。 简单的说，CAS需要你额外给出一个预期值，也就是你认为现在这个变量应该是什么样子的。如果变量不是你想象的那样，则说明已经被别人修改过了。你就重新读取，再次尝试修改就好了。 在硬件层面大部分的处理器都已支持原子化的CAS指令。在JDK5后，虚拟机便可以使用这个指令来进行原子化操作。 13.3、CAS实现计数器java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package 自旋锁计数;import java.util.ArrayList;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;public class Counter { /** * 线程安全方式计数， 内部的value子段声明为 private volatile int value;所以保证了内存可见性 */ private AtomicInteger atomic = new AtomicInteger(0); /** * 线程不安全，非原子性操作计数 */ private int i = 0; public void count(){ i++; } public void safeCount(){ while (true){ // 1、多核处理器可能会同时运行到这行代码，单核处理器由于时间片分配算法T1执行到这行代码后CPU执行权被T2获取了， 线程T1、T2均通过get()方法返回0 // 2、假如T1先执行atomic.compareAndSet(currentValue, ++currentValue)这行代码， // 由于currentValue和atomic的值一致，cas操作成功，atomic变成1，退出循环, // 3、然后T2继续执行atomic.compareAndSet(currentValue, ++currentValue); // 这行代码会发现atomic内部维护的value值1已经与currentValue的值0不相等，不会进行设置值操作 // T2继续下次循环, 又执行atomic.get();获取到的currentValue为1， 再次执行compareAndSet时， // atomic为1和currentValue为1相等，成功进行cas操作，然后退出循环 int currentValue = atomic.get(); boolean success = atomic.compareAndSet(currentValue, ++currentValue); if (success){ break; } } } public static void main(String[] args) { Counter counter = new Counter(); List threadList = new ArrayList(500); for (int j = 0; j < 500; j++){ Thread thread = new Thread(() ->{ try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } counter.count(); counter.safeCount(); }); threadList.add(thread); } threadList.stream().forEach(thread -> thread.start()); threadList.forEach(thread -> { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); System.out.println(\"count: \" + counter.i); System.out.println(\"safeCount:\" + counter.atomic); }} 13.3、使用CAS实现无锁同步Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546package atomic;import java.util.concurrent.atomic.AtomicInteger;/** * 使用cas实现无锁同步 * * @author calebzhao * 2019/8/23 19:46 */public class CasLock { private AtomicInteger lock = new AtomicInteger(0); //记录当前获取到锁的线程ID private Long getLockThreadId; public void tryLock(){ while (true){ boolean success = lock.compareAndSet(0, 1); if (success){ getLockThreadId = Thread.currentThread().getId(); break; } try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } } public void unLock(){ long currentThreadId = Thread.currentThread().getId(); if (currentThreadId != getLockThreadId){ throw new IllegalStateException(\"未获取到锁，无需解锁\"); } int value = lock.get(); if (value == 1){ lock.set(0); } }} 测试示例： Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package atomic;import java.util.ArrayList;import java.util.BitSet;import java.util.List;import java.util.Random;/** * @author calebzhao * 2019/8/23 19:50 */public class CasLockDemo { private static int i = 0; public static void main(String[] args) { BitSet bitSet = new BitSet(); CasLock lock = new CasLock(); List threadList = new ArrayList(500); Random random = new Random(); for (int j =0 ; j < 50000; j++){ Thread t = new Thread(() -> { try { Thread.sleep(random.nextInt(20) + 200); } catch (InterruptedException e) { e.printStackTrace(); } lock.tryLock(); i++; if(bitSet.get(i)){ throw new RuntimeException(\"lock有问题\"); } bitSet.set(i); System.out.println(Thread.currentThread().getName() + \" get lock, i=\" + i); lock.unLock(); }, \"thread-\" + j); threadList.add(t); } threadList.forEach(thread -> thread.start()); }} 13、atomic包原子操作类（无锁CAS）13.1、AtomicInteger主要方法： 示例： Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package atomic;import java.util.ArrayList;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;/** * @author calebzhao * 2019/8/25 15:07 */public class AtomicIntegerDemo { /** * 线程安全方式计数， 内部的value子段声明为 private volatile int value;所以保证了内存可见性 */ private AtomicInteger atomic = new AtomicInteger(0); /** * 线程不安全，非原子性操作计数 */ private int i = 0; public void count(){ i++; } public void safeCount(){ atomic.incrementAndGet(); } public static void main(String[] args) { AtomicIntegerDemo counter = new AtomicIntegerDemo(); List threadList = new ArrayList(500); for (int j = 0; j < 500; j++){ Thread thread = new Thread(() ->{ try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } counter.count(); counter.safeCount(); }); threadList.add(thread); } threadList.stream().forEach(thread -> thread.start()); threadList.forEach(thread -> { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); System.out.println(\"count: \" + counter.i); System.out.println(\"safeCount:\" + counter.atomic); }} 13.2、AtomicReferenceAtomicReference，顾名思义，就是以原子方式更新对象引用 可以看到，AtomicReference持有一个对象的引用——value，并通过Unsafe类来操作该引用: 为什么需要AtomicReference？难道多个线程同时对一个引用变量赋值也会出现并发问题？引用变量的赋值本身没有并发问题，也就是说对于引用变量var ，类似下面的赋值操作本身就是原子操作:Foo var = … ;AtomicReference的引入是为了可以用一种类似乐观锁的方式操作共享资源，在某些情景下以提升性能。 我们知道，当多个线程同时访问共享资源时，一般需要以加锁的方式控制并发： Code12345678910volatile Foo sharedValue = value;Lock lock = new ReentrantLock();lock.lock();try{ // 操作共享资源sharedValue}finally{ lock.unlock();} 上述访问方式其实是一种对共享资源加悲观锁的访问方式。而AtomicReference提供了以无锁方式访问共享资源的能力，看看如何通过AtomicReference保证线程安全，来看个具体的例子： Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package atomic;import java.util.ArrayList;import java.util.List;import java.util.concurrent.atomic.AtomicReference;/** * @author calebzhao * 2019/8/24 20:50 */public class AtomicReferenceCounter { public static void main(String[] args) throws InterruptedException { AtomicReference ref = new AtomicReference(new Integer(0)); List list = new ArrayList(); for (int i = 0; i < 1000; i++) { Thread t = new Thread(new Task(ref), \"Thread-\" + i); list.add(t); } for (Thread t : list) { t.start(); t.join(); } // 打印2000 System.out.println(ref.get()); }}class Task implements Runnable{ private AtomicReference reference; public Task(AtomicReference reference){ this.reference = reference; } @Override public void run() { while (true){ Integer oldValue = reference.get(); boolean success = reference.compareAndSet(oldValue, oldValue + 1); if (success){ break; } } }} 该示例并没有使用锁，而是使用自旋+CAS的无锁操作保证共享变量的线程安全。1000个线程，每个线程对金额增加1，最终结果为2000，如果线程不安全，最终结果应该会小于2000。 通过示例，可以总结出AtomicReference的一般使用模式如下 Code12345678AtomicReference ref = new AtomicReference(new Object());Object oldCache = ref.get();// 对缓存oldCache做一些操作Object newCache = someFunctionOfOld(oldCache); // 如果期间没有其它线程改变了缓存值，则更新boolean success = ref.compareAndSet(oldCache , newCache); 上面的代码模板就是AtomicReference的常见使用方式，看下compareAndSet方法： 该方法会将入参的expect变量所指向的对象和AtomicReference中的引用对象进行比较，如果两者指向同一个对象，则将AtomicReference中的引用对象重新置为update，修改成功返回true，失败则返回false。也就是说，AtomicReference其实是比较对象的引用。 13.2、CAS操作可能存在的ABA问题13.2.1、介绍 CAS操作可能存在ABA的问题，就是说：假如一个值原来是A，变成了B，又变成了A，那么CAS检查时会发现它的值没有发生变化，但是实际上却变化了。 一般来讲这并不是什么问题，比如数值运算，线程其实根本不关心变量中途如何变化，只要最终的状态和预期值一样即可。 但是，有些操作会依赖于对象的变化过程，此时的解决思路一般就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A - 2B - 3A。 13.2.3、贵宾充值卡问题（ABA示例）举例：有一家蛋糕店为了挽留客户，决定为贵宾卡里小于20元的客户一次性充值20元，刺激客户充值和消费，但条件是：每位客户只能被赠送一次。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package atomic;import java.util.concurrent.atomic.AtomicReference;/** * cas ABA问题 * @author calebzhao * 2019/8/25 15:30 */public class CasABAPromblem { private static AtomicReference money = new AtomicReference(19); public static void main(String[] args) { ChargeMoneyWorker chargeMoneyWorker = new ChargeMoneyWorker(money); for (int i = 0; i < 3; i++){ new Thread(chargeMoneyWorker).start(); } ConsumeMoneyWorker consumeMoneyWorker = new ConsumeMoneyWorker(money); new Thread(consumeMoneyWorker).start(); }}class ChargeMoneyWorker implements Runnable{ private AtomicReference money; public ChargeMoneyWorker(AtomicReference money){ this.money = money; } @Override public void run() { while (true){ while (true){ Integer m = money.get(); if (m < 20){ boolean success = money.compareAndSet(m, m +20); if (success){ System.out.println(\"余额小于20元，充值成功， 充值后余额：\" + money.get()); break; } } else {// System.out.println(\"余额大于20元，无需充值\"); break; } } } }}class ConsumeMoneyWorker implements Runnable{ private AtomicReference money; public ConsumeMoneyWorker(AtomicReference money){ this.money = money; } @Override public void run() { while (true){ while (true){ Integer m = money.get(); if (m > 10){ boolean success = money.compareAndSet(m, m - 10); if (success){ System.out.println(\"成功消费10元， 余额：\" + money.get()); break; } } else { System.out.println(\"余额不足10元\"); } } try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } } } 从上面的输出可以到用户的账户被先后反复充值，其原因是用户的账户余额被反复修改，导致修改后又满足的原充值条件，使得充值线程无法正确判断该用户是否已经充值过。 虽然这种情况出现的概率不大，但是依然也是由可能出现的，因此当业务中确实出现这种问题，我们需要注意是否是我们的业务本身就不合理。JDK为我们考虑到了这种情况，使用AtomicStampedReference可以很好的解决这个问题。 13.3、AtomicStampedReferenceAtomicStampedReference就是上面所说的加了版本号的AtomicReference。 13.3.1、AtomicStampedReference原理先来看下如何构造一个AtomicStampedReference对象，AtomicStampedReference只有一个构造器： 可以看到，除了传入一个初始的引用变量initialRef外，还有一个initialStamp变量，initialStamp其实就是版本号（或者说时间戳），用来唯一标识引用变量。 在构造器内部，实例化了一个Pair对象，Pair对象记录了对象引用和时间戳信息，采用int作为时间戳，实际使用的时候，要保证时间戳唯一（一般做成自增的），如果时间戳如果重复，还会出现ABA的问题。 AtomicStampedReference的所有方法，其实就是Unsafe类针对这个Pair对象的操作。和AtomicReference相比，AtomicStampedReference中的每个引用变量都带上了pair.stamp这个版本号，这样就可以解决CAS中的ABA问题了。 13.3.2、AtomicStampedReference使用示例Code12345// 创建AtomicStampedReference对象，持有Foo对象的引用，初始为null，版本为0AtomicStampedReference asr = new AtomicStampedReference(null,0); int[] stamp=new int[1];Foo oldRef = asr.get(stamp); // 调用get方法获取引用对象和对应的版本号 int oldStamp=stamp[0]; // stamp[0]保存版本号 asr.compareAndSet(oldRef, null, oldStamp, oldStamp + 1) //尝试以CAS方式更新引用对象，并将版本号+1 上述模板就是AtomicStampedReference的一般使用方式，注意下compareAndSet方法： 我们知道，AtomicStampedReference内部保存了一个pair对象，该方法的逻辑如下： 如果AtomicStampedReference内部pair的引用变量、时间戳 与 入参expectedReference、expectedStamp都一样，说明期间没有其它线程修改过AtomicStampedReference，可以进行修改。此时，会创建一个新的Pair对象（casPair方法，因为Pair是Immutable类）。 但这里有段优化逻辑，就是如果 newReference == current.reference && newStamp == current.stamp，说明用户修改的新值和AtomicStampedReference中目前持有的值完全一致，那么其实不需要修改，直接返回true即可。 13.3.3、AtomicStampedReference解决贵宾卡多次充值问题Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package atomic;import java.util.concurrent.atomic.AtomicStampedReference;/** * cas ABA问题解决方案 * @author calebzhao * 2019/8/25 15:30 */public class ResolveCasABAProblem { private static AtomicStampedReference money = new AtomicStampedReference(19, 0); public static void main(String[] args) { ResolveChargeMoneyWorker chargeMoneyWorker = new ResolveChargeMoneyWorker(money); for (int i = 0; i < 3; i++){ new Thread(chargeMoneyWorker).start(); } ResolveConsumeMoneyWorker consumeMoneyWorker = new ResolveConsumeMoneyWorker(money); new Thread(consumeMoneyWorker).start(); }}class ResolveChargeMoneyWorker implements Runnable{ private AtomicStampedReference money; public ResolveChargeMoneyWorker(AtomicStampedReference money){ this.money = money; } @Override public void run() { while (true){ try { Thread.sleep(400); } catch (InterruptedException e) { e.printStackTrace(); } while (true){ Integer m = money.getReference(); if (m < 20){ boolean success = money.compareAndSet(m, m +20, 0 , 1); if (success){ System.out.println(\"余额小于20元，充值成功， 充值后余额：\" + money.getReference()); break; } } else {// System.out.println(\"余额大于20元，无需充值\"); break; } } } }}class ResolveConsumeMoneyWorker implements Runnable{ private AtomicStampedReference money; public ResolveConsumeMoneyWorker(AtomicStampedReference money){ this.money = money; } @Override public void run() { while (true){ while (true){ Integer m = money.getReference(); int stamp = money.getStamp(); if (m > 10){ // 这里为什么不是给版本号加1呢？ // 假如这里变成 boolean success = money.compareAndSet(m, m - 10, stamp, stamp + 1); // 考虑一种情况，用户账户本身有19元钱， 初始充值状态为0表示为充值, 用户先消费了10元，stamp变为1 // 这时用户还没有充值，账户金额也确实少于20元，这会导致充值线程扫描是发现stamp已变为1，就不会充值了 // 根本原因是用户是否消费与是否充值过无关，充值的状态不能由于其他因素改变 // 这个例子是《实战高并发程序设计》一书中的例子，书中例子没有考虑到这点， // 书中假想的情况是先充值后消费，但如果是先消费再充值就有问题了 boolean success = money.compareAndSet(m, m - 10, stamp, stamp); if (success){ System.out.println(\"成功消费10元， 余额：\" + money.getReference()); break; } } else { System.out.println(\"余额不足10元\"); } } try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } }} 情况1：先充值后消费 情况2：先消费，后充值 13.4、AtomicMarkableReferenceAtomicMarkableReference是AtomicStampedReference的特殊化形式AtomicMarkableReference用于无需知道数据目前具体是哪个版本，只需要知道数据是否被更改过。 前面的客户账户充值例子ABA问题使用AtomicMarkableReference解决的代码如下： Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package atomic;/** * @author calebzhao * 2019/8/25 17:45 */import java.util.concurrent.atomic.AtomicMarkableReference;/** * cas ABA问题 * @author calebzhao * 2019/8/25 15:30 */public class AtomicMarkableReferenceDemo { private static AtomicMarkableReference money = new AtomicMarkableReference(19, false); public static void main(String[] args) { MarkableChargeMoneyWorker chargeMoneyWorker = new MarkableChargeMoneyWorker(money); for (int i = 0; i < 3; i++){ new Thread(chargeMoneyWorker).start(); } MarkableConsumeMoneyWorker consumeMoneyWorker = new MarkableConsumeMoneyWorker(money); new Thread(consumeMoneyWorker).start(); }}class MarkableChargeMoneyWorker implements Runnable{ private AtomicMarkableReference money; public MarkableChargeMoneyWorker(AtomicMarkableReference money){ this.money = money; } @Override public void run() { while (true){ try { Thread.sleep(400); } catch (InterruptedException e) { e.printStackTrace(); } while (true){ Integer m = money.getReference(); if (m < 20){ boolean success = money.compareAndSet(m, m +20, false , true); if (success){ System.out.println(\"余额小于20元，充值成功， 充值后余额：\" + money.getReference()); break; } } else {// System.out.println(\"余额大于20元，无需充值\"); break; } } } }}class MarkableConsumeMoneyWorker implements Runnable{ private AtomicMarkableReference money; public MarkableConsumeMoneyWorker(AtomicMarkableReference money){ this.money = money; } @Override public void run() { while (true){ while (true){ Integer m = money.getReference(); boolean isMarked = money.isMarked(); if (m > 10){ // 消费不更改充值标识 boolean success = money.compareAndSet(m, m - 10, isMarked, isMarked); if (success){ System.out.println(\"成功消费10元， 余额：\" + money.getReference()); break; } } else { System.out.println(\"余额不足10元\"); } } try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } }} 13.4、AtomicIntegerArrayAtomicIntegerArray本质上是对int[]类型的封装，使用Unsafe类通过CAS的方式控制int[]在多线程下的安全性，它提供了以下几个核心API： 13.4.1、如果没有AtomicIntegerArray的错误示例Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package atomic;/** * Increment任务：这个类使用vector[i]++方法增加数组中所有元素的值 * Decrement任务：这个类使用vector[i]--方法减少数组中所有元素的值 * * 在main方法中创建了1000个元素的int[]数组， * 执行了1000个Increment任务和1000个Decrement任务，在任务的结尾如果没有不一致的错误， * 数组中所有元素的值不全为0，执行程序后会看到程序输出了一些不全为0的数值 * @author calebzhao * 2019/8/25 12:22 */public class BadAtomiceIntegerArrayDemo { public static void main(String[] args) throws InterruptedException { int[] vector = new int[1000]; for (int i = 0; i < vector.length; i++){ vector[i] = 0; } BadIncrement increment = new BadIncrement(vector); BadDecrement decrement = new BadDecrement(vector); Thread[] badThreadIncrements = new Thread[1000]; Thread[] badThreadDecrements = new Thread[1000]; for (int i =0 ; i < badThreadIncrements.length; i++){ badThreadIncrements[i] = new Thread(increment); badThreadDecrements[i] = new Thread(decrement); } for (int i =0 ; i < badThreadIncrements.length; i++){ badThreadIncrements[i].start(); badThreadDecrements[i].start(); } for (int i =0 ; i < badThreadIncrements.length; i++){ badThreadIncrements[i].join(); badThreadDecrements[i].join(); } for (int i =0 ; i < vector.length; i++){ if (vector[i] != 0){ System.out.println(\"Vector[\"+i+\"] : \" + vector[i]); } } System.out.println(\"main end\"); }}class BadIncrement implements Runnable{ private int[] vector; public BadIncrement(int[] vector){ this.vector = vector; } @Override public void run() { for (int i = 0; i","categories":[{"name":"java基础","slug":"java基础","permalink":"https://calebzhao.github.io/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"https://calebzhao.github.io/tags/java/"},{"name":"并发","slug":"并发","permalink":"https://calebzhao.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"juc","slug":"juc","permalink":"https://calebzhao.github.io/tags/juc/"}]},{"title":"spring-cloud-openfeign源码分析","slug":"spring-cloud-openfeign源码分析","date":"2019-12-29T04:32:44.000Z","updated":"2020-01-10T04:43:18.139Z","comments":true,"path":"2019/12/29/spring-cloud-openfeign源码分析/","link":"","permalink":"https://calebzhao.github.io/2019/12/29/spring-cloud-openfeign%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"1、简介feign是一个声明式的HTTP客户端，spring-cloud-openfeign将feign集成到spring boot中，在接口上通过注解声明Rest协议，将http调用转换为接口方法的调用，使得客户端调用http服务更加简单。 2、原理分析看到客户端测试类中，我们只用了一行代码，就能完成对远程Rest服务的调用，相当的简单。为什么这么神奇，这几段代码是如何做到的呢？ 2.1、@EnableFeignClients 注解声明客户端接口入口是启动类上的注解@EnableFeignClients，源代码： java12345678910111213141516@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Import(FeignClientsRegistrar.class)public @interface EnableFeignClients { //basePackages的别名 String[] value() default {}; //声明基础包，spring boot启动后，会扫描该包下被@FeignClient注解的接口 String[] basePackages() default {}; //声明基础包的类，通过该类声明基础包 Class[] basePackageClasses() default {}; //默认配置类 Class[] defaultConfiguration() default {}; //直接声明的客户端接口类 Class[] clients() default {};} @EnableFeignClients的参数声明客户端接口的位置和默认的配置类。 2.2、@FeignClient注解，将接口声明为Feign客户端java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FeignClient { // 要调用的服务的id，对应与eureka上注册的应用名 // 带有可选协议前缀的服务的名称。name属性的同义词。 // 必须为所有客户端指定一个name，无论是否提供url。 // 可以指定为属性的key，例如:${propertyKey}。 @AliasFor(\"name\") String value() default \"\"; // 如果存在contextId，contextId将代替name属性用作bean的name，但不会用作服务id。 // 这个配置非常有用，如果不设置这个属性，那么@FeignClient注解的同1个name属性值不能出现在多个接口上 // why? 因为不设置contextId属性的话，那么bean的名称就是name属性了， // 如果多个接口调用同1个服务（多个接口上的@FeignClient注解的的name属性值相同），那么就会出现相同名称的bean了， // 而spring默认是不允许bean覆盖的，当然你可以通过设置spring.bean.allowOverridde=true来允许bean覆盖， // 但这是一个隐患非常大的危险做法，强烈建议不要这么做。 String contextId() default \"\"; // 名称，对应与eureka上注册的应用名 @AliasFor(\"value\") String name() default \"\"; // 如果有值，该值作为spring bean的qualifier， 否则使用contextId + 'FeignClient'作为qualifier // 另外contextId + 'FeignClient'中的contextId说明：当contextId存在使用contextId，不存在时依次使用serviceId、name、value String qualifier() default \"\"; // http服务的url，绝对地址或相对地址，http协议是可选的 String url() default \"\"; // 是否解码404状态码的响应，如果不解码404响应则会抛出FeignExceptions异常 boolean decode404() default false; // feign client的@Configuration配置类，可以包含重写feign配置的@Bean定义，比如Decoder、Encoder、Logger、Contract // 参阅FeignClientsConfiguration类查看默认的feign配置 // 这里设置的配置类是Spring Configuration，将会在FeignContext中创建内部声明的Bean，用于不同的客户端进行隔离 Class[] configuration() default {}; //声明hystrix调用失败后的方法 Class fallback() default void.class; // 为指定的feign client定义fallback工厂，这个工厂必须返回一个实现了标有@FeignClient注解的接口的降级策略实例 // 该工厂必须是一个有效的spring bean Class fallbackFactory() default void.class; // 所有方法级映射使用的路径前缀，是否想与@RibbonClient注解一起使用都可以 String path() default \"\"; // 是否将feign代理对象标记为首要bean，默认值为true。 boolean primary() default true; } 2.3、FeignClientsRegistrar 注册客户端@EnableFeignClients注解上被注解了@Import(FeignClientsRegistrar.class)，@Import注解的作用是将指定的类作为Bean注入到Spring Context中，我们再来看被引入的FeignClientsRegistrar java1234567891011121314151617class FeignClientsRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware, EnvironmentAware { private ResourceLoader resourceLoader; private Environment environment; ...省略部分代码 @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { registerDefaultConfiguration(metadata, registry); registerFeignClients(metadata, registry); } ...省略部分代码 } FeignClientsRegistrar类实现了3个接口: 接口ResourceLoaderAware用于注入ResourceLoader 接口EnvironmentAware用于注入Environment 接口ImportBeanDefinitionRegistrar用于动态向Spring Context中注册bean ImportBeanDefinitionRegistrar接口方法registerBeanDefinitions有两个参数 AnnotationMetadata 包含被@Import注解类的信息 BeanDefinitionRegistry bean定义注册中心 2.4、registerDefaultConfiguration方法，注册@EnableFeignClients注解的全局默认configurationjava12345678910111213141516171819202122private void registerDefaultConfiguration(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { // 获取@EnableFeignClients注解参数 Map defaultAttrs = metadata.getAnnotationAttributes(EnableFeignClients.class.getName(), true); // 如果参数中包含defaultConfiguration默认配置 if (defaultAttrs != null && defaultAttrs.containsKey(\"defaultConfiguration\")) { String name; // 返回该类是否有上级类（即metadata注解的类是内部类/嵌套类、方法中的局部类、匿名类中的一种） // 如果此方法返回false，则表明metadata注解的类为顶级类。 // 关于hasEnclosingClass方法的具体含义见：https://my.oschina.net/zhaopeng2012/blog/3146991 if (metadata.hasEnclosingClass()) { // 不是顶级类，注解所标识类的上一级类的全限定类名 name = \"default.\" + metadata.getEnclosingClassName(); } else { // 注解所标识的类的全限定类名 name = \"default.\" + metadata.getClassName(); } // 注册客户端的配置Bean， // 注意这里第3个参数值是@EnableFeignCliens注解的defaultConfiguration属性 registerClientConfiguration(registry, name, defaultAttrs.get(\"defaultConfiguration\")); }} 取出@EnableFeignClients注解的参数defaultConfiguration，动态注册到spring Context中。 2.5、registerClientConfiguration 注册configuration该方法用于注册feign配置，配置来源有2种： @EnableFeignClients注解的defaultConfiguration属性注册时（全局默认配置），name为default.xxx @FeignClient注解的configuration属性注册时（服务私有配置），name为contextId、name、value属性的值 有2个地方会调用该方法： FeignClientsRegistrar.registerDefaultConfiguration() FeignClientsRegistrar.registerFeignClients() registerClientConfiguration 方法源码如下： java12345678910111213private void registerClientConfiguration(BeanDefinitionRegistry registry, Object name, Object configuration) { // 创建一个BeanDefinitionBuilder，注册bean的类为FeignClientSpecification BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(FeignClientSpecification.class); // 增加构造函数参数 builder.addConstructorArgValue(name); // 关键代码：@EnableFeignCliens注解的defaultConfiguration属性 builder.addConstructorArgValue(configuration); // 调用BeanDefinitionRegistry.registerBeanDefinition方法动态注册Bean // 这里的name有2种情况： // 1. @EnableFeignClients注解的defaultConfiguration属性注册时（全局默认配置），name为default.xxx // 2. @FeignClient注解的configuration属性注册时（服务私有配置），name为contextId、name、value属性的值 registry.registerBeanDefinition(name + \".\" + FeignClientSpecification.class.getSimpleName(), builder.getBeanDefinition());} 这里使用spring 动态注册bean的方式，注册了一个FeignClientSpecification的bean。 2.6、FeignClientSpecification 客户端定义一个简单的pojo，继承了NamedContextFactory.Specification，两个属性String name 和 Class[] configuration，用于FeignContext命名空间独立配置，后面会用到。 java12345678class FeignClientSpecification implements NamedContextFactory.Specification { private String name; // 这个属性的值就是@EnableFeignClients的defaultConfiguration的值 // 或者是@FeignClient注解的configuration属性的值 private Class[] configuration;} 2.7、registerFeignClients方法，注册feign客户端java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public void registerFeignClients(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { // 生成一个scanner，扫描指定定包下的类 ClassPathScanningCandidateComponentProvider scanner = getScanner(); scanner.setResourceLoader(this.resourceLoader); Set basePackages; // 获取@EnableFeignClients注解的所有属性 Map attrs = metadata.getAnnotationAttributes(EnableFeignClients.class.getName()); // 包含@FeignClient注解的过滤器 AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter(FeignClient.class); // 获取@EnableFeignClients注解的clients属性的值 final Class[] clients = attrs == null ? null : (Class[]) attrs.get(\"clients\"); if (clients == null || clients.length == 0) { //@EnableFeignClients没有声明clients，获取basePackages，设置过滤器（扫描包含@FeignClient注解的class） scanner.addIncludeFilter(annotationTypeFilter); // 根据value、basePackages、basePackageClasses获取要扫描的包 basePackages = getBasePackages(metadata); } else { // @EnableFeignClients注解声明了clients final Set clientClasses = new HashSet(); basePackages = new HashSet(); for (Class clazz : clients) { // basePackages为声明的clients所在的包 basePackages.add(ClassUtils.getPackageName(clazz)); clientClasses.add(clazz.getCanonicalName()); } // 增加过滤器，只包含声明的clients AbstractClassTestingTypeFilter filter = new AbstractClassTestingTypeFilter() { @Override protected boolean match(ClassMetadata metadata) { String cleaned = metadata.getClassName().replaceAll(\"\\\\$\", \".\"); return clientClasses.contains(cleaned); } }; scanner.addIncludeFilter( new AllTypeFilter(Arrays.asList(filter, annotationTypeFilter))); } // 遍历basePackages for (String basePackage : basePackages) { // 扫描包，根据过滤器找到候选的Bean Set candidateComponents = scanner.findCandidateComponents(basePackage); // 遍历候选的bean for (BeanDefinition candidateComponent : candidateComponents) { // 判断候选bean是否是一个标有注解的bean if (candidateComponent instanceof AnnotatedBeanDefinition) { AnnotatedBeanDefinition beanDefinition = (AnnotatedBeanDefinition) candidateComponent; AnnotationMetadata annotationMetadata = beanDefinition.getMetadata(); // 校验注解是否标识在接口上 Assert.isTrue(annotationMetadata.isInterface(), \"@FeignClient can only be specified on an interface\"); // 获取@FeignClient注解的所有属性 Map attributes = annotationMetadata.getAnnotationAttributes( FeignClient.class.getCanonicalName()); // name获取顺序按优先级从高到低依次为contextId、value、name、serviceId。 String name = getClientName(attributes); //注册@FeignClient的configuration属性的客户端配置 registerClientConfiguration(registry, name,attributes.get(\"configuration\")); //注册客户端 registerFeignClient(registry, annotationMetadata, attributes); } } }} 这个方法主要逻辑是扫描注解声明的客户端(标有@FeignClient的接口)，调用registerFeignClient方法注册到registry中。这里是一个典型的spring动态注册bean的例子，可以参考这段代码在spring中轻松的实现类路径下class扫描，动态注册bean到spring中。想了解spring类的扫描机制，可以断点到ClassPathScanningCandidateComponentProvider.findCandidateComponents方法中，一步步调试。 2.8、registerFeignClient方法，注册单个客户feign端beanjava123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111private void registerFeignClient(BeanDefinitionRegistry registry, AnnotationMetadata annotationMetadata, Map attributes) { String className = annotationMetadata.getClassName(); // 构建一个FeignClientFactoryBean的bean工厂定义 BeanDefinitionBuilder definition = BeanDefinitionBuilder.genericBeanDefinition(FeignClientFactoryBean.class); validate(attributes); //根据@FeignClient注解的参数，设置属性 definition.addPropertyValue(\"url\", getUrl(attributes)); definition.addPropertyValue(\"path\", getPath(attributes)); String name = getName(attributes); definition.addPropertyValue(\"name\", name); String contextId = getContextId(attributes); definition.addPropertyValue(\"contextId\", contextId); definition.addPropertyValue(\"type\", className); definition.addPropertyValue(\"decode404\", attributes.get(\"decode404\")); definition.addPropertyValue(\"fallback\", attributes.get(\"fallback\")); definition.addPropertyValue(\"fallbackFactory\", attributes.get(\"fallbackFactory\")); definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE); // bean的默认别名 String alias = contextId + \"FeignClient\"; AbstractBeanDefinition beanDefinition = definition.getBeanDefinition(); boolean primary = (Boolean) attributes.get(\"primary\"); // has a default, won't be // null // 相当于@Primary注解的作用 beanDefinition.setPrimary(primary); //获取@FeignClient注解中指定的qualifier属性 String qualifier = getQualifier(attributes); if (StringUtils.hasText(qualifier)) { // 如果用户自己指定了qualifier属性，则使用注解中的qualifier属性作为bean的别名 // 否则使用上述默认的 contextId + \"FeignClient\"; alias = qualifier; } // 注册，这里为了简写，新建一个BeanDefinitionHolder，调用BeanDefinitionReaderUtils静态方法注册 BeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className, new String[] { alias }); BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);}/*** 获取服务名， 获取顺序为serviceId、name、value*/String getName(Map attributes) { String name = (String) attributes.get(\"serviceId\"); if (!StringUtils.hasText(name)) { name = (String) attributes.get(\"name\"); } if (!StringUtils.hasText(name)) { name = (String) attributes.get(\"value\"); } name = resolve(name); return getName(name);}/*** 获取contextId， 获取顺序为contextId、serviceId、name、value** 如果存在contextId，contextId将代替name属性用作bean的name，但不会用作服务id。* 这个配置非常有用，如果不设置这个属性，那么@FeignClient注解的同1个name属性值不能出现在多个接口上* why? 因为不设置contextId属性的话，那么bean的名称就是name属性了，* 如果多个接口调用同1个服务（多个接口上的@FeignClient注解的的name属性值相同），那么就会出现相同名称的bean了，* 而spring默认是不允许bean覆盖的，当然你可以通过设置spring.bean.allowOverridde=true来允许bean覆盖，* 但这是一个隐患非常大的危险做法，强烈建议不要这么做。** 看到这里的getContextId方法就应该知道contextId与name的区别了吧*/private String getContextId(Map attributes) { String contextId = (String) attributes.get(\"contextId\"); if (!StringUtils.hasText(contextId)) { // 未设置contextId属性时，使用serviceId、name、value return getName(attributes); } contextId = resolve(contextId); // 验证contextId是否是有效的URI return getName(contextId);}// @FeignClinet注解的属性(contextId、serviceId、name、value)支持${keyProperty}环境变量private String resolve(String value) { if (StringUtils.hasText(value)) { return this.environment.resolvePlaceholders(value); } return value;}// 验证http[s]://name是否是1个有效的URIstatic String getName(String name) { if (!StringUtils.hasText(name)) { return \"\"; } String host = null; try { String url; if (!name.startsWith(\"http://\") && !name.startsWith(\"https://\")) { url = \"http://\" + name; } else { url = name; } host = new URI(url).getHost(); } catch (URISyntaxException e) { } Assert.state(host != null, \"Service id not legal hostname (\" + name + \")\"); return name;} registerFeignClient方法主要是将FeignClientFactoryBean工厂Bean注册到registry中，spring初始化后，会调用FeignClientFactoryBean的getObject方法创建bean注册到spring context中。 2.9、FeignClientFactoryBean 创建feign客户端的工厂java123456789101112131415161718192021class FeignClientFactoryBean implements FactoryBean, InitializingBean, ApplicationContextAware { private Class type; private String name; private String url; private String contextId; private String path; private boolean decode404; private ApplicationContext applicationContext; private Class fallback = void.class; private Class fallbackFactory = void.class; ...省略部分代码} FeignClientFactoryBean实现了FactoryBean接口，是一个工厂bean ![](https://cdn.jsdelivr.net/gh/calebzhao/cdn/img/20191229142123.png 2.9.1、FeignClientFactoryBean.getObject方法java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overridepublic Object getObject() throws Exception { return getTarget();} T getTarget() { // FeignContext在FeignAutoConfiguration中自动注册，FeignContext用于客户端配置类独立注册，后面具体分析 // 这行代码会导致FeignAutoConfiguration中的FeignContext创建 FeignContext context = this.applicationContext.getBean(FeignContext.class); // 创建Feign.Builder对象 Feign.Builder builder = feign(context); // 如果@FeignClient注解没有设置url参数 if (!StringUtils.hasText(this.url)) { // url为@FeignClient注解的name参数 if (!this.name.startsWith(\"http\")) { // 例如 http://md-admin-web this.url = \"http://\" + this.name; } else { // @FeignClient注解的name属性以http开头的 this.url = this.name; } //加上path this.url += cleanPath(); // 返回loadBlance客户端，也就是ribbon+eureka的客户端 return (T) loadBalance(builder, context, new HardCodedTarget(this.type, this.name, this.url)); } //@FeignClient设置了url参数，不做负载均衡 if (StringUtils.hasText(this.url) && !this.url.startsWith(\"http\")) { this.url = \"http://\" + this.url; } //加上path String url = this.url + cleanPath(); //从FeignContext中获取client Client client = getOptional(context, Client.class); if (client != null) { if (client instanceof LoadBalancerFeignClient) { // 有url参数，不做负载均衡，但是客户端是ribbon，或者实际的客户端 client = ((LoadBalancerFeignClient) client).getDelegate(); } builder.client(client); } // 从FeignContext中获取Targeter Targeter targeter = get(context, Targeter.class); // 生成客户端代理 return (T) targeter.target(this, builder, context, new HardCodedTarget(this.type, this.name, url));} 这段代码有个比较重要的逻辑，如果在@FeignClient注解中设置了url参数，就不走Ribbon，直接url调用，否则通过Ribbon调用，实现客户端负载均衡。 可以看到，生成Feign客户端所需要的各种配置对象，都是通过FeignContex中获取的。 2.9.2、FeignContext 隔离配置在@FeignClient注解参数configuration，指定的类是Spring的Configuration Bean，里面方法上加@Bean注解实现Bean的注入，可以指定feign客户端的各种配置，包括Encoder/Decoder/Contract/Feign.Builder等。不同的客户端指定不同配置类，就需要对配置类进行隔离，FeignContext就是用于隔离配置的。 java12345public class FeignContext extends NamedContextFactory { public FeignContext() { super(FeignClientsConfiguration.class, \"feign\", \"feign.client.name\"); }} FeignContext继承NamedContextFactory，空参数构造函数指定FeignClientsConfiguration类为默认配置。NamedContextFactory实现接口ApplicationContextAware，注入ApplicationContextAware作为parent： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/*** 这里的泛型C是FeignClientSpecification*/public abstract class NamedContextFactory implements DisposableBean, ApplicationContextAware { private final String propertySourceName; private final String propertyName; //命名空间对应的Spring Context private Map contexts = new ConcurrentHashMap(); //不同命名空间的定义 private Map configurations = new ConcurrentHashMap(); private ApplicationContext parent; //默认配置类 private Class defaultConfigType; // 设置配置，在FeignAutoConfiguration中将Spring Context中的所有FeignClientSpecification设置进来 // 1. 如果@EnableFeignClients有设置参数defaultConfiguration也会加进来，前面已经分析 // 在registerDefaultConfiguration方法中注册的FeignClientSpecification Bean // 2. @FeignClient注解的configuration属性配置也会加进来 // 在registerFeignClients()方法中注册的FeignClientSpecification Bean public void setConfigurations(List configurations) { for (C client : configurations) { this.configurations.put(client.getName(), client); } } // 获取指定命名空间的ApplicationContext，先从缓存中获取，没有就创建 protected AnnotationConfigApplicationContext getContext(String name) { if (!this.contexts.containsKey(name)) { synchronized (this.contexts) { if (!this.contexts.containsKey(name)) { this.contexts.put(name, createContext(name)); } } } return this.contexts.get(name); } /** * 合并默认配置(default.xxx)和私有配置(name对应的配置) */ protected AnnotationConfigApplicationContext createContext(String name) { // 新建AnnotationConfigApplicationContext AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(); // 根据name在configurations找到所有的配置类，注册到context中 if (this.configurations.containsKey(name)) { for (Class configuration : this.configurations.get(name) .getConfiguration()) { context.register(configuration); } } // 将default.开头的默认配置也注册到Context中 for (Map.Entry entry : this.configurations.entrySet()) { if (entry.getKey().startsWith(\"default.\")) { for (Class configuration : entry.getValue().getConfiguration()) { context.register(configuration); } } } // 注册默认配置bean， 对于feign而言就是FeignContext的构造方法中传入的FeignClientsConfiguration context.register(PropertyPlaceholderAutoConfiguration.class, this.defaultConfigType); // 注册解析feign.client.name配置的MapPropertySource bean context.getEnvironment().getPropertySources().addFirst(new MapPropertySource( this.propertySourceName, Collections.singletonMap(this.propertyName, name))); // 设置parent if (this.parent != null) { // Uses Environment from parent as well as beans context.setParent(this.parent); // jdk11 issue // https://github.com/spring-cloud/spring-cloud-netflix/issues/3101 context.setClassLoader(this.parent.getClassLoader()); } context.setDisplayName(generateDisplayName(name)); // 刷新，完成bean生成 context.refresh(); return context; } // 从命名空间中获取指定类型的Bean public T getInstance(String name, Class type) { AnnotationConfigApplicationContext context = getContext(name); if (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context, type).length > 0) { return context.getBean(type); } return null; } // 从命名空间中获取指定类型的Bean public Map getInstances(String name, Class type) { AnnotationConfigApplicationContext context = getContext(name); if (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context, type).length > 0) { return BeanFactoryUtils.beansOfTypeIncludingAncestors(context, type); } return null; }} 关键的方法是createContext，为每个命名空间独立创建的ApplicationContext，设置parent为外部传入的Context，这样就可以共用外部的Context中的Bean，又有各种独立的配置Bean，熟悉springMVC的同学应该知道，springMVC中创建的WebApplicatonContext里面也有个parent，原理跟这个类似。 从FeignContext中获取Bean，需要传入命名空间，根据命名空间找到缓存中的ApplicationContext，先从自己注册的Bean中获取bean，没有获取到再从到parent中获取。 2.9.3、创建Feign.Builder了解了FeignContext的原理，我们再来看feign最重要的构建类创建过程 在FeignClientFactoryBean的getTarget方法中调用了feign()方法返回了Feign.Builder对象： java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121class FeignClientFactoryBean implements FactoryBean, InitializingBean, ApplicationContextAware { T getTarget() { Feign.Builder builder = feign(context); } protected Feign.Builder feign(FeignContext context) { // 从FeignContext中获取注册的FeignLoggerFactory日志工厂bean FeignLoggerFactory loggerFactory = get(context, FeignLoggerFactory.class); // 创建feign的Logger接口的日志实现bean Logger logger = loggerFactory.create(this.type); // 从FeignContext中获取注册的Feign.Builder bean，设置Encoder/Decoder/Contract Feign.Builder builder = get(context, Feign.Builder.class) // 这里的都是必须的配置， // 需要注意的是这里的get(context, xx.class)都是先从自身命名空间上下文中找bean（私有配置）， // 如果找不到会从父上下文中找bean使用全局配置, 这就是为什么@FeignClient的configuration属性可以没有的原因。 // 配置日志实现，默认Slf4jLogger .logger(logger) // 配置form、bdoy参数编码器, 默认SpringEncoder .encoder(get(context, Encoder.class)) // 配置响应解码器,默认OptionalDecoder(持有SpringDecoder) .decoder(get(context, Decoder.class)) // 配置契约实现SpringMvcContract .contract(get(context, Contract.class)); // 配置feign的其他可选参数 configureFeign(context, builder); return builder; } // 配置feign其他参数 protected void configureFeign(FeignContext context, Feign.Builder builder) { FeignClientProperties properties = this.applicationContext.getBean(FeignClientProperties.class); if (properties != null) { // 判断client的独立可选配置是否可以覆盖全局的可选配置 if (properties.isDefaultToProperties()) { // 配置可选参数，全局的可选配置可以被client独立的配置覆盖 // 配置可选配置（日志级别、拦截器、重试、查询参数编码器、错误解码器、是否解码404响应） configureUsingConfiguration(context, builder); // 使用feign.client.config.default的默认配置 configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder); // 使用feign.client.config.{contextId}的feign client独立的配置， // 这样达到了默认使用全局配置，每个client又可以覆盖全局默认配置，实现配置个性化的目的 configureUsingProperties(properties.getConfig().get(this.contextId), builder); } else { // 使用feign.client.config.default的默认配置 configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder); // 使用feign.client.config.{contextId}的feign client独立的配置， // 这样达到了默认使用全局配置，每个client又可以覆盖全局默认配置，实现配置个性化的目的 configureUsingProperties(properties.getConfig().get(this.contextId), builder); // 配置可选参数，全局的可选配置覆盖client独立的配置 // 配置可选配置（日志级别、拦截器、重试、查询参数编码器、错误解码器、是否解码404响应） configureUsingConfiguration(context, builder); } } else { // 配置可选配置（日志级别、拦截器、重试、查询参数编码器、错误解码器、是否解码404响应） configureUsingConfiguration(context, builder); } } protected void configureUsingConfiguration(FeignContext context, Feign.Builder builder) { // 获取可选配置：日志级别 Logger.Level level = getOptional(context, Logger.Level.class); if (level != null) { // 设置日志级别 builder.logLevel(level); } // 获取可选配置：重试条件 Retryer retryer = getOptional(context, Retryer.class); if (retryer != null) { // 设置重试条件 builder.retryer(retryer); } // 获取可选配置：错误解码器（非2xx、不解码404时的使用它将响应数据翻译为相应的异常抛出） ErrorDecoder errorDecoder = getOptional(context, ErrorDecoder.class); if (errorDecoder != null) { // 设置错误解码器 builder.errorDecoder(errorDecoder); } // 获取可选配置：http请求相关参数(connectTimeout、readTimeout等， // 它会传递给具体的发送http请求的client， 例如ApacheHttpClient、OkHttpClient等) Request.Options options = getOptional(context, Request.Options.class); if (options != null) { // 设置http请求相关参数 builder.options(options); } // 获取可选配置：发送请求前的拦截器 Map requestInterceptors = context.getInstances(this.contextId, RequestInterceptor.class); if (requestInterceptors != null) { // 设置请求拦截器 builder.requestInterceptors(requestInterceptors.values()); } // 获取可选配置：查询参数编码器 // 用于将方法参数的java bean、Map对象序列化为http请求url的?后的查询参数，如a=b&c=d QueryMapEncoder queryMapEncoder = getOptional(context, QueryMapEncoder.class); if (queryMapEncoder != null) { // 设置查询参数编码器 builder.queryMapEncoder(queryMapEncoder); } //是否解码404响应 if (this.decode404) { // 设置当响应状态码为404时是否使用decoder解码response， // 若该参数为false，则会使用errorDecoder翻译为相应的异常抛出 builder.decode404(); } }} feign()方法设置了Feign.Builder所必须的参数Encoder/Decoder/Contract，其他参数都是可选的。这三个必须的参数从哪里来的呢？答案是在FeignContext的构造器中，传入了默认的配置FeignClientsConfiguration，这个配置类里面初始化了这三个参数。 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112@Configuration(proxyBeanMethods = false)public class FeignClientsConfiguration { @Autowired private ObjectFactory messageConverters; @Autowired(required = false) private List parameterProcessors = new ArrayList(); @Autowired(required = false) private List feignFormatterRegistrars = new ArrayList(); @Autowired(required = false) private Logger logger; @Autowired(required = false) private SpringDataWebProperties springDataWebProperties; // Decoder bean，默认通过HttpMessageConverters进行处理 @Bean @ConditionalOnMissingBean public Decoder feignDecoder() { return new OptionalDecoder( new ResponseEntityDecoder(new SpringDecoder(this.messageConverters))); } // Encoder bean，默认通过HttpMessageConverters进行处理 @Bean @ConditionalOnMissingBean @ConditionalOnMissingClass(\"org.springframework.data.domain.Pageable\") public Encoder feignEncoder() { return new SpringEncoder(this.messageConverters); } // Encoder bean @Bean @ConditionalOnClass(name = \"org.springframework.data.domain.Pageable\") @ConditionalOnMissingBean public Encoder feignEncoderPageable() { PageableSpringEncoder encoder = new PageableSpringEncoder( new SpringEncoder(this.messageConverters)); if (springDataWebProperties != null) { encoder.setPageParameter( springDataWebProperties.getPageable().getPageParameter()); encoder.setSizeParameter( springDataWebProperties.getPageable().getSizeParameter()); encoder.setSortParameter( springDataWebProperties.getSort().getSortParameter()); } return encoder; } // Contract bean，通过SpringMvcContract进行处理接口 @Bean @ConditionalOnMissingBean public Contract feignContract(ConversionService feignConversionService) { return new SpringMvcContract(this.parameterProcessors, feignConversionService); } @Bean public FormattingConversionService feignConversionService() { FormattingConversionService conversionService = new DefaultFormattingConversionService(); for (FeignFormatterRegistrar feignFormatterRegistrar : this.feignFormatterRegistrars) { feignFormatterRegistrar.registerFormatters(conversionService); } return conversionService; } //默认不重试 @Bean @ConditionalOnMissingBean public Retryer feignRetryer() { return Retryer.NEVER_RETRY; } // 默认的builder @Bean @Scope(\"prototype\") @ConditionalOnMissingBean public Feign.Builder feignBuilder(Retryer retryer) { return Feign.builder().retryer(retryer); } // 日志工厂 @Bean @ConditionalOnMissingBean(FeignLoggerFactory.class) public FeignLoggerFactory feignLoggerFactory() { return new DefaultFeignLoggerFactory(this.logger); } // jackson处理spring data的Page对象 @Bean @ConditionalOnClass(name = \"org.springframework.data.domain.Page\") public Module pageJacksonModule() { return new PageJacksonModule(); } // 存在hystrix时，hystrix自动注入 @Configuration(proxyBeanMethods = false) @ConditionalOnClass({ HystrixCommand.class, HystrixFeign.class }) protected static class HystrixFeignConfiguration { // HystrixFeign的builder，全局关掉Hystrix配置feign.hystrix.enabled=false @Bean @Scope(\"prototype\") @ConditionalOnMissingBean @ConditionalOnProperty(name = \"feign.hystrix.enabled\") public Feign.Builder feignHystrixBuilder() { return HystrixFeign.builder(); } }} 可以看到，feign需要的decoder/enoder通过适配器共用springMVC中的HttpMessageConverters引入。 feign有自己的注解体系，这里通过SpringMvcContract适配了springMVC的注解体系。 2.9.4、SpringMvcContract 适配feign注解体系SpringMvcContract继承了feign的类Contract.BaseContract，作用是解析接口方法上的注解和方法参数，生成MethodMetadata用于接口方法调用过程中组装http请求。 java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class SpringMvcContract extends Contract.BaseContract implements ResourceLoaderAware { /** * */ @Override public MethodMetadata parseAndValidateMetadata(Class targetType, Method method) { this.processedMethods.put(Feign.configKey(targetType, method), method); // 调用父类Contract.BaseContract的处理逻辑 // 而父类处理过程中会调用processAnnotationOnClass、processAnnotationOnMethod、processAnnotationsOnParameter // 这3个方法来解析类、方法、参数上的注解，SpringMvcContract通过重写了这3个方法解析spring mvc自己的 // @RequestMapping、@RequestParam、@RequestBody、@GetMapping...等等注解 // 来实现利用spring这套解决方案实现微服务间互相调用的闭环 MethodMetadata md = super.parseAndValidateMetadata(targetType, method); RequestMapping classAnnotation = findMergedAnnotation(targetType, RequestMapping.class); if (classAnnotation != null) { // produces - use from class annotation only if method has not specified this if (!md.template().headers().containsKey(ACCEPT)) { parseProduces(md, method, classAnnotation); } // consumes -- use from class annotation only if method has not specified this if (!md.template().headers().containsKey(CONTENT_TYPE)) { parseConsumes(md, method, classAnnotation); } // headers -- class annotation is inherited to methods, always write these if // present parseHeaders(md, method, classAnnotation); } return md; } /** * 处理class上的注解 */ @Override protected void processAnnotationOnClass(MethodMetadata data, Class clz) { ...省略代码 } /** * 处理方法上的注解：@RequestMapping、 */ @Override protected void processAnnotationOnMethod(MethodMetadata data, Annotation methodAnnotation, Method method) { ...省略代码 } /** * 处理参数上的注解 */ protected boolean processAnnotationsOnParameter(MethodMetadata data, Annotation[] annotations, int paramIndex) { ...省略代码 }} 几个覆盖方法分别是处理类上的注解，处理方法，处理方法上的注解，处理方法参数注解，最终生成完整的MethodMetadata。feign自己提供的Contract和扩展javax.ws.rx的Contract原理都是类似的。 2.9.5、FeignAutoConfigurationFeign.Builder生成后，就要用Target生成feign客户端的动态代理，这里FeignClientFactoryBean中使用Targeter，Targeter有两个实现类，分别是HystrixTargeter和DefaultTargeter，那么默认的Targeter又是怎么来的呢？ 在spring-cloud-openfeign-core项目的META-INF\\spring.factories文件中有FeignAutoConfiguration的自动化配置，关于spring.factories自动化配置的原理见springboot2.2自动注入文件spring.factories如何加载详解 spring.factories Code1234567org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.cloud.openfeign.ribbon.FeignRibbonClientAutoConfiguration,\\org.springframework.cloud.openfeign.hateoas.FeignHalAutoConfiguration,\\org.springframework.cloud.openfeign.FeignAutoConfiguration,\\org.springframework.cloud.openfeign.encoding.FeignAcceptGzipEncodingAutoConfiguration,\\org.springframework.cloud.openfeign.encoding.FeignContentGzipEncodingAutoConfiguration,\\org.springframework.cloud.openfeign.loadbalancer.FeignLoadBalancerAutoConfiguration FeignAutoConfiguration java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115@Configuration(proxyBeanMethods = false)@ConditionalOnClass(Feign.class)@EnableConfigurationProperties({ FeignClientProperties.class, FeignHttpClientProperties.class })@Import(DefaultGzipDecoderConfiguration.class)public class FeignAutoConfiguration { /** * FeignClientSpecification包含了feign配置类，配置来源有2种： * 1. @EnableFeignClients注解的defaultConfiguration属性注册时（全局默认配置），name为default.xxx * 2. @FeignClient注解的configuration属性注册时（服务私有配置），name为contextId、name、value属性的值 * * 有2个地方会调用该方法产生FeignClientSpecification： * 1. FeignClientsRegistrar.registerDefaultConfiguration() * 2. FeignClientsRegistrar.registerFeignClients() */ @Autowired(required = false) private List configurations = new ArrayList(); /** * spring cloud commons项目中的HasFeatures，表示使用了Feign特性，用于spring boot actuator监控 */ @Bean public HasFeatures feignFeature() { return HasFeatures.namedFeature(\"Feign\", Feign.class); } /** * 关键代码：feign客户端配置隔离的实现 * 创建FeignClientSpecification， 每个feign客户端能够有各自私有的configuration就靠它了， * 他是命名空间隔离的applicationContext， 每个feign客户端都有自己的applicationContext */ @Bean public FeignContext feignContext() { FeignContext context = new FeignContext(); // 一定要注意这里把所有的配置都设置进去了 // 包括@EnableFeignClients的全局defaultConfiguration和@FeignClient的私有configuration配置 // FeignClientFactoryBean类中getTarget创建Feign.Bulider的get(context, beanType)都是从它里面取的 // feign客户端自身的applicationContext取不到就到父applicationContext中去取， // 达到先取私有配置bean(例如encoder、client、logger、decoder、loggerLevel)， // 私有配置取不到再取全局配置bean的功能 context.setConfigurations(this.configurations); return context; } /** * 类路径中存在HystrixFeign这个类，使用hystrix实现的Targeter */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass(name = \"feign.hystrix.HystrixFeign\") protected static class HystrixFeignTargeterConfiguration { /** * 实现了熔断降级功能的Targeter */ @Bean @ConditionalOnMissingBean public Targeter feignTargeter() { return new HystrixTargeter(); } } /** * 类路径中没有HystrixFeign这个类，使用默认实现DefaultTargeter */ @Configuration(proxyBeanMethods = false) @ConditionalOnMissingClass(\"feign.hystrix.HystrixFeign\") protected static class DefaultFeignTargeterConfiguration { @Bean @ConditionalOnMissingBean public Targeter feignTargeter() { return new DefaultTargeter(); } } /** * 引入了feign-httpclient.jar，使用apache HttpClient发送请求 */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass(ApacheHttpClient.class) @ConditionalOnMissingClass(\"com.netflix.loadbalancer.ILoadBalancer\") @ConditionalOnMissingBean(CloseableHttpClient.class) @ConditionalOnProperty(value = \"feign.httpclient.enabled\", matchIfMissing = true) protected static class HttpClientFeignConfiguration { @Bean @ConditionalOnMissingBean(Client.class) public Client feignClient(HttpClient httpClient) { return new ApacheHttpClient(httpClient); } } /** * 引入了feign-okhttp.jar， 使用okhttp发送请求 */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass(OkHttpClient.class) @ConditionalOnMissingClass(\"com.netflix.loadbalancer.ILoadBalancer\") @ConditionalOnMissingBean(okhttp3.OkHttpClient.class) @ConditionalOnProperty(\"feign.okhttp.enabled\") protected static class OkHttpFeignConfiguration { @Bean public okhttp3.OkHttpClient client(OkHttpClientFactory httpClientFactory, ConnectionPool connectionPool, FeignHttpClientProperties httpClientProperties) { Boolean followRedirects = httpClientProperties.isFollowRedirects(); Integer connectTimeout = httpClientProperties.getConnectionTimeout(); Boolean disableSslValidation = httpClientProperties.isDisableSslValidation(); this.okHttpClient = httpClientFactory.createBuilder(disableSslValidation) .connectTimeout(connectTimeout, TimeUnit.MILLISECONDS) .followRedirects(followRedirects).connectionPool(connectionPool) .build(); return this.okHttpClient; } }} @FeignClient配置隔离体系总结 需要注意的是FeignAutoConfiguration中的bean都是默认的全局配置， 而每个@FeignClient都可以有其私有的configuration属性配置，在FeignClientFactoryBean.feign()方法中创建Feign.builder().enocder(xx).decoder(xxx).targeter()时调用的get(context, xx.class)方法都是先从自身命名空间上下文中找bean（私有配置），如果找不到会从父上下文中找bean使用全局配置, 这就是为什么@FeignClient的configuration属性可以没有的原因。 2.9.6、Targeter 生成接口动态代理 DefaultTargeter DefaultTargeter很简单，直接调用HardCodedTarget生成动态代理，HystrixTargeter源码如下： java12345678910class DefaultTargeter implements Targeter { @Override public T target(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context, Target.HardCodedTarget target) { // 直接由feign自身的实现产生jdk 动态代理工厂产生代理对象 return feign.target(target); }} HystrixTargeter java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class HystrixTargeter implements Targeter { @Override public T target(FeignClientFactoryBean factory, Feign.Builder feign, FeignContext context, Target.HardCodedTarget target) { // 如果不是HystrixFeign.Builder，直接调用target生成代理 if (!(feign instanceof feign.hystrix.HystrixFeign.Builder)) { return feign.target(target); } feign.hystrix.HystrixFeign.Builder builder = (feign.hystrix.HystrixFeign.Builder) feign; // 优先使用contextId属性, 如果contextId为空则使用name属性 String name = StringUtils.isEmpty(factory.getContextId()) ? factory.getName() : factory.getContextId(); // context是配置隔离的applicationContext // 优先取client私有配置中的SetterFactory，若未配置私有的，则取全局默认的 SetterFactory setterFactory = getOptional(name, context, SetterFactory.class); // 私有的或全局的配置了SetterFactory if (setterFactory != null) { builder.setterFactory(setterFactory); } //找到fallback或者fallbackFactory，设置到hystrix中 Class fallback = factory.getFallback(); if (fallback != void.class) { return targetWithFallback(name, context, target, builder, fallback); } Class fallbackFactory = factory.getFallbackFactory(); if (fallbackFactory != void.class) { return targetWithFallbackFactory(name, context, target, builder, fallbackFactory); } // 无降级策略，直接调用target生成代理 return feign.target(target); } private T targetWithFallbackFactory(String feignClientName, FeignContext context, Target.HardCodedTarget target, HystrixFeign.Builder builder, Class fallbackFactoryClass) { FallbackFactory fallbackFactory = (FallbackFactory) getFromContext( \"fallbackFactory\", feignClientName, context, fallbackFactoryClass, FallbackFactory.class); return builder.target(target, fallbackFactory); } private T targetWithFallback(String feignClientName, FeignContext context, Target.HardCodedTarget target, HystrixFeign.Builder builder, Class fallback) { T fallbackInstance = getFromContext(\"fallback\", feignClientName, context, fallback, target.type()); return builder.target(target, fallbackInstance); }} HystrixFeign.Builder java12345678910111213141516171819202122232425262728293031public final class HystrixFeign { public static final class Builder extends feign.Feign.Builder { private Contract contract = new Default(); private SetterFactory setterFactory = new feign.hystrix.SetterFactory.Default(); public T target(Target target, T fallback) { return build(fallback != null ? new FallbackFactory.Default(fallback) : null).newInstance(target); } public T target(Target target, FallbackFactory fallbackFactory) { return build(fallbackFactory).newInstance(target); } Feign build(final FallbackFactory nullableFallbackFactory) { // 替换掉Feign.Bulider中默认的 // private InvocationHandlerFactory invocationHandlerFactory = new InvocationHandlerFactory.Default(); // 由此可知当hystrix启用时feign客户端的动态代理实现是在HystrixInvocationHandler中 // 也就是说我们在contrller层调用feign客户端(例如UserFeignClient)时会进入到HystrixInvocationHandler中 // 拦截方法调用 super.invocationHandlerFactory(new InvocationHandlerFactory() { @Override public InvocationHandler create(Target target, Map dispatch) { return new HystrixInvocationHandler(target, dispatch, setterFactory, nullableFallbackFactory); } }); super.contract(new HystrixDelegatingContract(contract)); return super.build(); } }} HystrixInvocationHandler java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113final class HystrixInvocationHandler implements InvocationHandler { private final Target target; private final Map dispatch; private final FallbackFactory fallbackFactory; // Nullable private final Map fallbackMethodMap; private final Map setterMethodMap; @Override public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable { ...省略部分代码 HystrixCommand hystrixCommand = new HystrixCommand(setterMethodMap.get(method)) { @Override protected Object run() throws Exception { try { return HystrixInvocationHandler.this.dispatch.get(method).invoke(args); } catch (Exception e) { throw e; } catch (Throwable t) { throw (Error) t; } } @Override protected Object getFallback() { if (fallbackFactory == null) { return super.getFallback(); } try { Object fallback = fallbackFactory.create(getExecutionException()); Object result = fallbackMethodMap.get(method).invoke(fallback, args); if (isReturnsHystrixCommand(method)) { return ((HystrixCommand) result).execute(); } else if (isReturnsObservable(method)) { // Create a cold Observable return ((Observable) result).toBlocking().first(); } else if (isReturnsSingle(method)) { // Create a cold Observable as a Single return ((Single) result).toObservable().toBlocking().first(); } else if (isReturnsCompletable(method)) { ((Completable) result).await(); return null; } else if (isReturnsCompletableFuture(method)) { return ((Future) result).get(); } else { return result; } } catch (IllegalAccessException e) { // shouldn't happen as method is public due to being an interface throw new AssertionError(e); } catch (InvocationTargetException | ExecutionException e) { // Exceptions on fallback are tossed by Hystrix throw new AssertionError(e.getCause()); } catch (InterruptedException e) { // Exceptions on fallback are tossed by Hystrix Thread.currentThread().interrupt(); throw new AssertionError(e.getCause()); } } }; // 是jdk8的接口中的default方法，直接执行 if (Util.isDefault(method)) { return hystrixCommand.execute(); } // 返回值是HystrixCommand类型，不真正执行，直接返回上面创建的hystrixCommand else if (isReturnsHystrixCommand(method)) { return hystrixCommand; } //返回值类型是Observable else if (isReturnsObservable(method)) { // Create a cold Observable return hystrixCommand.toObservable(); } // 返回值类型是Single else if (isReturnsSingle(method)) { // Create a cold Observable as a Single return hystrixCommand.toObservable().toSingle(); } // 返回值类型是Completable else if (isReturnsCompletable(method)) { return hystrixCommand.toObservable().toCompletable(); } // 返回值类型是CompletableFuture else if (isReturnsCompletableFuture(method)) { return new ObservableCompletableFuture(hystrixCommand); } // 其他情况直接执行 return hystrixCommand.execute(); } private boolean isReturnsCompletable(Method method) { return Completable.class.isAssignableFrom(method.getReturnType()); } private boolean isReturnsHystrixCommand(Method method) { return HystrixCommand.class.isAssignableFrom(method.getReturnType()); } private boolean isReturnsObservable(Method method) { return Observable.class.isAssignableFrom(method.getReturnType()); } private boolean isReturnsCompletableFuture(Method method) { return CompletableFuture.class.isAssignableFrom(method.getReturnType()); } private boolean isReturnsSingle(Method method) { return Single.class.isAssignableFrom(method.getReturnType()); }} 3、loadBalance方法，客户端负载均衡3.1、loadBalance方法的调用如果@FeignClient注解中没有配置url参数，将会通过loadBalance方法生成Ribbon的动态代理： java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class FeignClientFactoryBean implements FactoryBean, InitializingBean, ApplicationContextAware { private String name; private String url; private String contextId; ...省略部分代码 @Override public Object getObject() throws Exception { return getTarget(); } T getTarget() { ...省略部分代码 if (!StringUtils.hasText(this.url)) { if (!this.name.startsWith(\"http\")) { this.url = \"http://\" + this.name; } else { this.url = this.name; } this.url += cleanPath(); return (T) loadBalance(builder, context, new HardCodedTarget(this.type, this.name, this.url)); } ...省略部分代码 } protected T loadBalance(Feign.Builder builder, FeignContext context, HardCodedTarget target) { // 这里获取到的Client是LoadBalancerFeignClient Client client = getOptional(context, Client.class); if (client != null) { builder.client(client); Targeter targeter = get(context, Targeter.class); return targeter.target(this, builder, context, target); } throw new IllegalStateException( \"No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?\"); } ...省略部分代码 } 3.2、FeignRibbonClientAutoConfiguration之前我们我们已经分析过在spring-cloud-openfeign-core项目的META-INF\\spring.factories文件中有FeignAutoConfiguration的自动化配置，这里我们可以看到spring.factories文件里面还有个FeignRibbonClientAutoConfiguration自动化配置类，从名称就可以知道它与负载均衡相关。 spring.factories Code1234567org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.cloud.openfeign.ribbon.FeignRibbonClientAutoConfiguration,\\org.springframework.cloud.openfeign.hateoas.FeignHalAutoConfiguration,\\org.springframework.cloud.openfeign.FeignAutoConfiguration,\\org.springframework.cloud.openfeign.encoding.FeignAcceptGzipEncodingAutoConfiguration,\\org.springframework.cloud.openfeign.encoding.FeignContentGzipEncodingAutoConfiguration,\\org.springframework.cloud.openfeign.loadbalancer.FeignLoadBalancerAutoConfiguration FeignRibbonClientAutoConfiguration java1234567891011121314@ConditionalOnClass({ ILoadBalancer.class, Feign.class })@ConditionalOnProperty(value = \"spring.cloud.loadbalancer.ribbon.enabled\", matchIfMissing = true)@Configuration(proxyBeanMethods = false)@AutoConfigureBefore(FeignAutoConfiguration.class)@EnableConfigurationProperties({ FeignHttpClientProperties.class })// Order is important here, last should be the default, first should be optional// see// https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653@Import({ HttpClientFeignLoadBalancedConfiguration.class, OkHttpFeignLoadBalancedConfiguration.class, DefaultFeignLoadBalancedConfiguration.class })public class FeignRibbonClientAutoConfiguration {} 可以看到它引入了HttpClientFeignLoadBalancedConfiguration、OkHttpFeignLoadBalancedConfiguration、DefaultFeignLoadBalancedConfiguration这3个类，我们接下来先看不引入apache http client、okhttp这些http库时的执行流程 LoadBalancerFeignClient的创建 java123456789101112@Configuration(proxyBeanMethods = false)class DefaultFeignLoadBalancedConfiguration { @Bean @ConditionalOnMissingBean public Client feignClient(CachingSpringLoadBalancerFactory cachingFactory, SpringClientFactory clientFactory) { return new LoadBalancerFeignClient(new Client.Default(null, null), cachingFactory, clientFactory); }} LoadBalancerFeignClient java123456789101112131415161718192021222324252627282930313233343536373839404142434445public class LoadBalancerFeignClient implements Client { static final Request.Options DEFAULT_OPTIONS = new Request.Options(); private final Client delegate; private CachingSpringLoadBalancerFactory lbClientFactory; private SpringClientFactory clientFactory; /** * @param request 是feign自身的Request对象，持有发送http请求的Client实现 * @param options http请求的相关配置(connectTimeout、readTimeout) */ @Override public Response execute(Request request, Request.Options options) throws IOException { try { //获取URI URI asUri = URI.create(request.url()); //获取客户端的名称 String clientName = asUri.getHost(); URI uriWithoutHost = cleanUrl(request.url(), clientName); //创建RibbonRequest FeignLoadBalancer.RibbonRequest ribbonRequest = new FeignLoadBalancer.RibbonRequest( this.delegate, request, uriWithoutHost); //配置 IClientConfig requestConfig = getClientConfig(options, clientName); //获取FeignLoadBalancer，发请求，转换Response return lbClient(clientName) .executeWithLoadBalancer(ribbonRequest, requestConfig).toResponse(); } catch (ClientException e) { IOException io = findIOException(e); if (io != null) { throw io; } throw new RuntimeException(e); } } private FeignLoadBalancer lbClient(String clientName) { return this.lbClientFactory.create(clientName); }} CachingSpringLoadBalancerFactory java123456789101112131415161718192021222324252627public class CachingSpringLoadBalancerFactory { protected final SpringClientFactory factory; protected LoadBalancedRetryFactory loadBalancedRetryFactory = null; private volatile Map cache = new ConcurrentReferenceHashMap(); public FeignLoadBalancer create(String clientName) { // 先从缓存获取，缓存中没有再创建 FeignLoadBalancer client = this.cache.get(clientName); if (client != null) { return client; } IClientConfig config = this.factory.getClientConfig(clientName); // 取出负载均衡实现 ILoadBalancer lb = this.factory.getLoadBalancer(clientName); ServerIntrospector serverIntrospector = this.factory.getInstance(clientName, ServerIntrospector.class); // 创建FeignLoadBalancer或带有重试功能的RetryableFeignLoadBalancer client = this.loadBalancedRetryFactory != null ? new RetryableFeignLoadBalancer(lb, config, serverIntrospector, this.loadBalancedRetryFactory) : new FeignLoadBalancer(lb, config, serverIntrospector); // 放到内存缓存中 this.cache.put(clientName, client); return client; }} FeignLoadBalancer java123456789101112131415161718192021222324252627282930313233343536373839public class FeignLoadBalancer extends AbstractLoadBalancerAwareClient { private final RibbonProperties ribbon; protected int connectTimeout; protected int readTimeout; protected IClientConfig clientConfig; protected ServerIntrospector serverIntrospector; /** * 注意此时的RibbonRequest参数的url属性已经从抽象的服务名经过ribbon负载均衡算法变成具体的域名或ip地址了 * 负载均衡的逻辑在其父类AbstractLoadBalancerAwareClient.executeWithLoadBalancer()方法中 */ @Override public RibbonResponse execute(RibbonRequest request, IClientConfig configOverride) throws IOException { // http请求相关配置（connectTimeout、readTimeout） Request.Options options; if (configOverride != null) { RibbonProperties override = RibbonProperties.from(configOverride); options = new Request.Options(override.connectTimeout(this.connectTimeout), override.readTimeout(this.readTimeout)); } else { options = new Request.Options(this.connectTimeout, this.readTimeout); } // 关键代码： request.client()返回的是feign的Client接口的实现(OkHttpClient、ApacheHttpClient) // 它是在FeignClientFactoryBean.loadBalance()方法中将Client的实现设置到Feign.Builder中的 // 这里调用http请求框架真正发送请求获取响应 Response response = request.client().execute(request.toRequest(), options); // 将feign的Reponse对象包装为ribbon的response return new RibbonResponse(request.getUri(), response); }} AbstractLoadBalancerAwareClient java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public abstract class AbstractLoadBalancerAwareClient extends LoadBalancerContext implements IClient, IClientConfigAware { public T executeWithLoadBalancer(final S request, final IClientConfig requestConfig) throws ClientException { LoadBalancerCommand command = buildLoadBalancerCommand(request, requestConfig); try { // LoadBalancerCommand.submit()方法里面使用了rx-java，看起来很复杂。。。 return command.submit( new ServerOperation() { @Override public Observable call(Server server) { // 这里负载均衡已经完成, server就是通过负载均衡算法选择的服务实例 // reconstructURIWithServer就是把抽象地址转换为server的具体域名或ip // 得到最终http请求url URI finalUri = reconstructURIWithServer(server, request.getUri()); // 将executeWithLoadBalancer方法参数的request中的uri替换成最终具体域名或ip的uri S requestForServer = (S) request.replaceUri(finalUri); try { // 调用了IClient接口中声明的 T execute(S request, IClientConfig requestConfig) 方法 // 该方法由该类的子类FeignLoadBalancer实现了，来真正发出http请求 return Observable.just(AbstractLoadBalancerAwareClient.this.execute(requestForServer, requestConfig)); } catch (Exception e) { return Observable.error(e); } } }) .toBlocking() .single(); } catch (Exception e) { Throwable t = e.getCause(); if (t instanceof ClientException) { throw (ClientException) t; } else { throw new ClientException(e); } } } protected LoadBalancerCommand buildLoadBalancerCommand(final S request, final IClientConfig config) { RequestSpecificRetryHandler handler = getRequestSpecificRetryHandler(request, config); LoadBalancerCommand.Builder builder = LoadBalancerCommand.builder() .withLoadBalancerContext(this) .withRetryHandler(handler) .withLoadBalancerURI(request.getUri()); customizeLoadBalancerCommandBuilder(request, config, builder); return builder.build(); }} 3.3、FeignLoadBalancerAutoConfiguration具有负载均衡功能的feign自动配置, 注意@AutoConfigureAfter(FeignRibbonClientAutoConfiguration.class)这个自动化配置条件，表明这个类的自动化配置在FeignRibbonClientAutoConfiguration之后才执行，回顾上面的FeignRibbonClientAutoConfiguration的执行流程可以知道，当启用ribbon时，FeignRibbonClientAutoConfiguration引入的3个类HttpClientFeignLoadBalancedConfiguration、OkHttpFeignLoadBalancedConfiguration、DefaultFeignLoadBalancedConfiguration本身会创建Feign的Client接口的实现LoadBalancerFeignClient，所以由FeignLoadBalancerAutoConfiguration自动化配置的FeignBlockingLoadBalancerClient不会被创建，因为Client接口的实现已经由FeignRibbonClientAutoConfiguration的自动化配置创建好了LoadBalancerFeignClient`。 下面的源码分析建立在spring.cloud.loadbalancer.ribbon.enabled=false的情况下进行分析的 FeignLoadBalancerAutoConfiguration源码如下： java123456789101112131415@ConditionalOnClass(Feign.class)@ConditionalOnBean(BlockingLoadBalancerClient.class)@AutoConfigureBefore(FeignAutoConfiguration.class)@AutoConfigureAfter(FeignRibbonClientAutoConfiguration.class)@EnableConfigurationProperties(FeignHttpClientProperties.class)@Configuration(proxyBeanMethods = false)// Order is important here, last should be the default, first should be optional// see// https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653@Import({ HttpClientFeignLoadBalancerConfiguration.class, OkHttpFeignLoadBalancerConfiguration.class, DefaultFeignLoadBalancerConfiguration.class })class FeignLoadBalancerAutoConfiguration {} 可以看到同时引入了带有负载均衡功能的apache httpclient、okhttp及默认实现的feign client实现 DefaultFeignLoadBalancerConfiguration Client.Default底层使用jdk自带的HttpURLConnection发送请求 java1234567891011@Configuration(proxyBeanMethods = false)class DefaultFeignLoadBalancerConfiguration { @Bean @ConditionalOnMissingBean public Client feignClient(BlockingLoadBalancerClient loadBalancerClient) { return new FeignBlockingLoadBalancerClient(new Client.Default(null, null), loadBalancerClient); }} OkHttpFeignLoadBalancerConfigurationjava12345678910111213141516@Configuration(proxyBeanMethods = false)@ConditionalOnClass(OkHttpClient.class)@ConditionalOnProperty(\"feign.okhttp.enabled\")@ConditionalOnBean(BlockingLoadBalancerClient.class)@Import(OkHttpFeignConfiguration.class)class OkHttpFeignLoadBalancerConfiguration { @Bean @ConditionalOnMissingBean public Client feignClient(okhttp3.OkHttpClient okHttpClient, BlockingLoadBalancerClient loadBalancerClient) { OkHttpClient delegate = new OkHttpClient(okHttpClient); return new FeignBlockingLoadBalancerClient(delegate, loadBalancerClient); }} 可以看到无论是DefaultFeignLoadBalancerConfiguration还是OkHttpFeignLoadBalancerConfiguration都是使用FeignBlockingLoadBalancerClient，传入了具体http请求的实现，可以知道具体的负载均衡功能是由FeignBlockingLoadBalancerClient实现的 FeignBlockingLoadBalancerClientjava1234567891011121314151617181920212223242526272829303132333435class FeignBlockingLoadBalancerClient implements Client { private final Client delegate; private final BlockingLoadBalancerClient loadBalancerClient; @Override public Response execute(Request request, Request.Options options) throws IOException { final URI originalUri = URI.create(request.url()); String serviceId = originalUri.getHost(); Assert.state(serviceId != null, \"Request URI does not contain a valid hostname: \" + originalUri); // 使用负载均衡实现选择服务实例 ServiceInstance instance = loadBalancerClient.choose(serviceId); if (instance == null) { // 无可用实例 String message = \"Load balancer does not contain an instance for the service \" + serviceId; if (LOG.isWarnEnabled()) { LOG.warn(message); } return Response.builder().request(request) .status(HttpStatus.SERVICE_UNAVAILABLE.value()) .body(message, StandardCharsets.UTF_8).build(); } // 将抽象的服务名替换成具体的域名、ip地址 String reconstructedUrl = loadBalancerClient.reconstructURI(instance, originalUri) .toString(); // 重新构造请求 Request newRequest = Request.create(request.httpMethod(), reconstructedUrl, request.headers(), request.requestBody()); // 委托给Client的具体实现（(OkHttpClient、ApacheHttpClient)）真正发出http请求 return delegate.execute(newRequest, options); }} 相比而言spring-cloud-loadbalancer与feign适配的代码比ribbon就简洁了很多很多。。。 4、总结feign本身是一款优秀的开源组件，spring cloud feign又非常巧妙的将feign集成到spring boot中。本文通过对spring cloud feign源代码的解读，详细的分析了feign集成到spring boot中的原理，使我们更加全面的了解到feign的使用。 spring cloud feign也是一个很好的学习spring boot的例子，从中我们可以学习到： spring boot注解声明注入bean spring类扫描机制 spring接口动态注册bean spring命名空间隔离ApplicationContext 文章大部分来源于：http://techblog.ppdai.com/2018/05/28/20180528/本人在其基础上加入自己的理解","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://calebzhao.github.io/tags/spring-cloud/"},{"name":"feign","slug":"feign","permalink":"https://calebzhao.github.io/tags/feign/"}]}]}