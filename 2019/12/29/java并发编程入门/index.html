<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="referrer" content="never"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>java并发编程入门 | calebzhao的博客</title><meta name="description" content="java并发编程入门"><meta name="keywords" content="java,并发,juc"><meta name="author" content="calebzhao"><meta name="copyright" content="calebzhao"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/calebzhao/cdn/img/20191229155709.png"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="java并发编程入门"><meta name="twitter:description" content="java并发编程入门"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="java并发编程入门"><meta property="og:url" content="https://calebzhao.github.io/2019/12/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"><meta property="og:site_name" content="calebzhao的博客"><meta property="og:description" content="java并发编程入门"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://calebzhao.github.io/2019/12/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"><link rel="prev" title="Feign源码学习" href="https://calebzhao.github.io/2019/12/29/Feign%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"><link rel="next" title="spring-cloud-openfeign源码分析" href="https://calebzhao.github.io/2019/12/29/spring-cloud-openfeign%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"EU39VTKAPM","apiKey":"9108b7c9e302dddcc64205e00d26f470","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://calebzhao.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">calebzhao的博客</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#1、入门介绍"><span class="toc_mobile_items-text">1、入门介绍</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-1、实现线程的2种方式"><span class="toc_mobile_items-text">1.1、实现线程的2种方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-2、线程的状态（生命周期）"><span class="toc_mobile_items-text">1.2、线程的状态（生命周期）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-1、线程的5种状态"><span class="toc_mobile_items-text">1.2.1、线程的5种状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-2、线程运行状态图"><span class="toc_mobile_items-text">1.2.2、线程运行状态图</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-3-sleep、yield、join、wait的比较"><span class="toc_mobile_items-text">1.3. **sleep、yield、join、wait的比较**</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-4、Thread-sleep-long-time"><span class="toc_mobile_items-text">1.4、Thread.sleep(long time)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#2、多线程实现银行叫号排队"><span class="toc_mobile_items-text">2、多线程实现银行叫号排队</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-1-版本1"><span class="toc_mobile_items-text">2.1 版本1</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-2-版本2"><span class="toc_mobile_items-text">2.2 版本2</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#3、守护线程"><span class="toc_mobile_items-text">3、守护线程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#4、Thread-join"><span class="toc_mobile_items-text">4、Thread.join()</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-1-无限等待"><span class="toc_mobile_items-text">4.1 无限等待</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-2-等待指定时间"><span class="toc_mobile_items-text">4.2 等待指定时间</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#5、中断线程的几种方式"><span class="toc_mobile_items-text">5、中断线程的几种方式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-1、介绍"><span class="toc_mobile_items-text">5.1、介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-2、通过whilte-running-变量控制"><span class="toc_mobile_items-text">5.2、通过whilte(running) { }变量控制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-3、通过Thread-interrupt-控制"><span class="toc_mobile_items-text">5.3、通过Thread.interrupt()控制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-4、暴力终止"><span class="toc_mobile_items-text">5.4、暴力终止</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-5、interrupt-、interrupted-、isInterrupted-区别与原理"><span class="toc_mobile_items-text">5.5、interrupt()、interrupted()、isInterrupted()区别与原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-5-1、结论"><span class="toc_mobile_items-text">5.5.1、结论</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#5-5-2、原理"><span class="toc_mobile_items-text">5.5.2、原理</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#6、synchronized"><span class="toc_mobile_items-text">6、synchronized</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-1、示例代码"><span class="toc_mobile_items-text">6.1、示例代码</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-2、通过jconsole查看"><span class="toc_mobile_items-text">6.2、通过jconsole查看</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-3、通过jps、jstack查看"><span class="toc_mobile_items-text">6.3、通过jps、jstack查看</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-4、通过javap-c-xxxx-class-命令查看汇编指令"><span class="toc_mobile_items-text">6.4、通过javap -c [xxxx.class]命令查看汇编指令</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-5-this锁"><span class="toc_mobile_items-text">6.5 this锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-6-class锁"><span class="toc_mobile_items-text">6.6 class锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-7-死锁"><span class="toc_mobile_items-text">6.7 死锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-8、synchronzied锁重入"><span class="toc_mobile_items-text">6.8、synchronzied锁重入</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-9、synchronized的原理"><span class="toc_mobile_items-text">6.9、synchronized的原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-10、synchronized底层实现原理"><span class="toc_mobile_items-text">6.10、synchronized底层实现原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-10-1、synchronized方法底层原理："><span class="toc_mobile_items-text">6.10.1、synchronized方法底层原理：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-10-2、synchonized代码块底层实现原理："><span class="toc_mobile_items-text">6.10.2、synchonized代码块底层实现原理：</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-11、Java虚拟机对synchronized的优化"><span class="toc_mobile_items-text">6.11、Java虚拟机对synchronized的优化</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-11-1、偏向锁"><span class="toc_mobile_items-text">6.11.1、偏向锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-11-2、轻量级锁"><span class="toc_mobile_items-text">6.11.2、轻量级锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-11-3、自旋锁"><span class="toc_mobile_items-text">6.11.3、自旋锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#6-11-4、锁消除"><span class="toc_mobile_items-text">6.11.4、锁消除</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#7、wait、notify方法"><span class="toc_mobile_items-text">7、wait、notify方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-1、含义（需仔细研读）"><span class="toc_mobile_items-text">7.1、含义（需仔细研读）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-2、生产者消费者模式"><span class="toc_mobile_items-text">7.2、生产者消费者模式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-1、-版本1产生假死-全部进入等待wait状态"><span class="toc_mobile_items-text">7.2.1、 版本1产生假死(全部进入等待wait状态)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-2、多消费者、多生产者正确版本"><span class="toc_mobile_items-text">7.2.2、多消费者、多生产者正确版本</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-3、多生产者、多消费者，-阻塞-错误版本，浪费执行机会"><span class="toc_mobile_items-text">7.2.3、多生产者、多消费者， 阻塞, 错误版本，浪费执行机会</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#7-2-4、完全正确版本"><span class="toc_mobile_items-text">7.2.4、完全正确版本</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#8-、捕获线程运行期间的异常"><span class="toc_mobile_items-text">8 、捕获线程运行期间的异常</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#9、ThreadGroup"><span class="toc_mobile_items-text">9、ThreadGroup</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#10、单例设计模式"><span class="toc_mobile_items-text">10、单例设计模式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#version1-（不好）"><span class="toc_mobile_items-text">version1 （不好）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#version2-错误"><span class="toc_mobile_items-text">version2 (错误)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#version3-不好"><span class="toc_mobile_items-text">version3 (不好)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#version4-不好"><span class="toc_mobile_items-text">version4 (不好)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#version5-正确、推荐"><span class="toc_mobile_items-text">version5 (正确、推荐)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#version-6-（正确）"><span class="toc_mobile_items-text">version 6 （正确）</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#11、volatile关键字"><span class="toc_mobile_items-text">11、volatile关键字</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#11-1-高并发的三个特性"><span class="toc_mobile_items-text">11.1 高并发的三个特性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#省略一万行代码…"><span class="toc_mobile_items-text">省略一万行代码…</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#12、比较并交换（CAS"><span class="toc_mobile_items-text">12、比较并交换（CAS)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#12-1、使用CAS与使用锁相比的好处"><span class="toc_mobile_items-text">12.1、使用CAS与使用锁相比的好处</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#12-2、CAS原理"><span class="toc_mobile_items-text">12.2、CAS原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#13-3、CAS实现计数器"><span class="toc_mobile_items-text">13.3、CAS实现计数器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#13-3、使用CAS实现无锁同步"><span class="toc_mobile_items-text">13.3、使用CAS实现无锁同步</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#13、atomic包原子操作类（无锁CAS）"><span class="toc_mobile_items-text">13、atomic包原子操作类（无锁CAS）</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#13-1、AtomicInteger"><span class="toc_mobile_items-text">13.1、AtomicInteger</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#13-2、AtomicReference"><span class="toc_mobile_items-text">13.2、AtomicReference</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#13-2、CAS操作可能存在的ABA问题"><span class="toc_mobile_items-text">13.2、CAS操作可能存在的ABA问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#13-2-1、介绍"><span class="toc_mobile_items-text">13.2.1、介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#13-2-3、贵宾充值卡问题（ABA示例）"><span class="toc_mobile_items-text">13.2.3、贵宾充值卡问题（ABA示例）</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#13-3、AtomicStampedReference"><span class="toc_mobile_items-text">13.3、AtomicStampedReference</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#13-3-1、AtomicStampedReference原理"><span class="toc_mobile_items-text">13.3.1、AtomicStampedReference原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#13-3-2、AtomicStampedReference使用示例"><span class="toc_mobile_items-text">13.3.2、AtomicStampedReference使用示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#13-3-3、AtomicStampedReference解决贵宾卡多次充值问题"><span class="toc_mobile_items-text">13.3.3、AtomicStampedReference解决贵宾卡多次充值问题</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#13-4、AtomicMarkableReference"><span class="toc_mobile_items-text">13.4、AtomicMarkableReference</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#13-4、AtomicIntegerArray"><span class="toc_mobile_items-text">13.4、AtomicIntegerArray</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#13-4-1、如果没有AtomicIntegerArray的错误示例"><span class="toc_mobile_items-text">13.4.1、如果没有AtomicIntegerArray的错误示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#13-4-2、atomicatintegerarray的正确使用"><span class="toc_mobile_items-text">13.4.2、atomicatintegerarray的正确使用</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#13-5、atomicreferencearray"><span class="toc_mobile_items-text">13.5、atomicreferencearray</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#13-6、atomicintegerfieldupdater"><span class="toc_mobile_items-text">13.6、atomicintegerfieldupdater</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#14、Unsafe"><span class="toc_mobile_items-text">14、Unsafe</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#14-1、获取unsafe"><span class="toc_mobile_items-text">14.1、获取unsafe</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#16、JUC"><span class="toc_mobile_items-text">16、JUC</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#16-1、CountDownLatch"><span class="toc_mobile_items-text">16.1、CountDownLatch</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-1-1、介绍"><span class="toc_mobile_items-text">16.1.1、介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-1-2、入门示例"><span class="toc_mobile_items-text">16.1.2、入门示例</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#16-2、CyclicBarrer"><span class="toc_mobile_items-text">16.2、CyclicBarrer</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-2-1、简介"><span class="toc_mobile_items-text">16.2.1、简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-2-4、示例3"><span class="toc_mobile_items-text">16.2.4、示例3</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-2-5、士兵报道示例"><span class="toc_mobile_items-text">16.2.5、士兵报道示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-2-5、CyclicBarrier的应用场景"><span class="toc_mobile_items-text">16.2.5、CyclicBarrier的应用场景</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-2-6、CyclicBarrier和CountDownLatch的区别"><span class="toc_mobile_items-text">16.2.6、CyclicBarrier和CountDownLatch的区别</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#16-3、Exchanger"><span class="toc_mobile_items-text">16.3、Exchanger</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-3-1、介绍"><span class="toc_mobile_items-text">16.3.1、介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-3-3、exchage-超时控制"><span class="toc_mobile_items-text">16.3.3、exchage()超时控制</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#16-4、Semaphore"><span class="toc_mobile_items-text">16.4、Semaphore</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-4-1、介绍"><span class="toc_mobile_items-text">16.4.1、介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-4-2、Semaphore实现同步锁"><span class="toc_mobile_items-text">16.4.2、Semaphore实现同步锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-4-3、构造方法permits参数作用"><span class="toc_mobile_items-text">16.4.3、构造方法permits参数作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-4-4、acquire-permits-的作用"><span class="toc_mobile_items-text">16.4.4、acquire(permits)的作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-4-5、动态增加许可数量（release-）及drainPermits"><span class="toc_mobile_items-text">16.4.5、动态增加许可数量（release()）及drainPermits()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-4-6、acquireUninterruptibly-的作用"><span class="toc_mobile_items-text">16.4.6、acquireUninterruptibly()的作用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-4-7、getQueueLength-和hasQueueThreads"><span class="toc_mobile_items-text">16.4.7、getQueueLength()和hasQueueThreads()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-4-8、获取许可的公平与非公平测试"><span class="toc_mobile_items-text">16.4.8、获取许可的公平与非公平测试</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-4-9、tryAcquire"><span class="toc_mobile_items-text">16.4.9、tryAcquire()</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#16-5、ReentrantLock"><span class="toc_mobile_items-text">16.5、ReentrantLock</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-5-1、介绍"><span class="toc_mobile_items-text">16.5.1、介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-5-2、线程间同步"><span class="toc_mobile_items-text">16.5.2、线程间同步</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-5-2、公平与非公平获取锁、isFair-、isLock"><span class="toc_mobile_items-text">16.5.2、公平与非公平获取锁、isFair()、isLock()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-5-3、Condition"><span class="toc_mobile_items-text">16.5.3、Condition</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-5-4、getHolderCount"><span class="toc_mobile_items-text">16.5.4、getHolderCount()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-5-5、getQueuedLength-、hasQueueuedThreads"><span class="toc_mobile_items-text">16.5.5、getQueuedLength()、hasQueueuedThreads()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-5-6、getWaitQueueLength-Condition-c-、hasWaiters-Condition-c"><span class="toc_mobile_items-text">16.5.6、getWaitQueueLength(Condition c)、hasWaiters(Condition c)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-5-7、lock-、lockInterruptibly"><span class="toc_mobile_items-text">16.5.7、lock()、lockInterruptibly()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-5-8、tryLock"><span class="toc_mobile_items-text">16.5.8、tryLock()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-5-8、Contition-awaitUninterrupyibly"><span class="toc_mobile_items-text">16.5.8、Contition.awaitUninterrupyibly()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-5-9、condition-awaitUntil-Date-deadlineDate"><span class="toc_mobile_items-text">16.5.9、condition.awaitUntil(Date deadlineDate)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-6-1、可重入功能"><span class="toc_mobile_items-text">16.6.1、可重入功能</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#16-6、ReentrantReadWriteLock"><span class="toc_mobile_items-text">16.6、ReentrantReadWriteLock</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-6-1、读读共享"><span class="toc_mobile_items-text">16.6.1、读读共享</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-6-2、写写互斥"><span class="toc_mobile_items-text">16.6.2、写写互斥</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-6-3、读写互斥-先读后写"><span class="toc_mobile_items-text">#16.6.3、读写互斥(先读后写)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-6-4、写读互斥（先写后读）"><span class="toc_mobile_items-text">16.6.4、写读互斥（先写后读）</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#16-7、StampedLock"><span class="toc_mobile_items-text">16.7、StampedLock</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-7-1、介绍"><span class="toc_mobile_items-text">16.7.1、介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-7-2、-StampedLock的特点"><span class="toc_mobile_items-text">16.7.2、 StampedLock的特点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-7-3、oracle官方示例"><span class="toc_mobile_items-text">16.7.3、oracle官方示例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#16-7-4、实现原理"><span class="toc_mobile_items-text">16.7.4、实现原理</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1、入门介绍"><span class="toc-text">1、入门介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1、实现线程的2种方式"><span class="toc-text">1.1、实现线程的2种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2、线程的状态（生命周期）"><span class="toc-text">1.2、线程的状态（生命周期）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1、线程的5种状态"><span class="toc-text">1.2.1、线程的5种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2、线程运行状态图"><span class="toc-text">1.2.2、线程运行状态图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-sleep、yield、join、wait的比较"><span class="toc-text">1.3. **sleep、yield、join、wait的比较**</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4、Thread-sleep-long-time"><span class="toc-text">1.4、Thread.sleep(long time)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2、多线程实现银行叫号排队"><span class="toc-text">2、多线程实现银行叫号排队</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-版本1"><span class="toc-text">2.1 版本1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-版本2"><span class="toc-text">2.2 版本2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3、守护线程"><span class="toc-text">3、守护线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4、Thread-join"><span class="toc-text">4、Thread.join()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-无限等待"><span class="toc-text">4.1 无限等待</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-等待指定时间"><span class="toc-text">4.2 等待指定时间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5、中断线程的几种方式"><span class="toc-text">5、中断线程的几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1、介绍"><span class="toc-text">5.1、介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2、通过whilte-running-变量控制"><span class="toc-text">5.2、通过whilte(running) { }变量控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3、通过Thread-interrupt-控制"><span class="toc-text">5.3、通过Thread.interrupt()控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4、暴力终止"><span class="toc-text">5.4、暴力终止</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5、interrupt-、interrupted-、isInterrupted-区别与原理"><span class="toc-text">5.5、interrupt()、interrupted()、isInterrupted()区别与原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1、结论"><span class="toc-text">5.5.1、结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2、原理"><span class="toc-text">5.5.2、原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6、synchronized"><span class="toc-text">6、synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1、示例代码"><span class="toc-text">6.1、示例代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2、通过jconsole查看"><span class="toc-text">6.2、通过jconsole查看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3、通过jps、jstack查看"><span class="toc-text">6.3、通过jps、jstack查看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4、通过javap-c-xxxx-class-命令查看汇编指令"><span class="toc-text">6.4、通过javap -c [xxxx.class]命令查看汇编指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-this锁"><span class="toc-text">6.5 this锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-class锁"><span class="toc-text">6.6 class锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-死锁"><span class="toc-text">6.7 死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8、synchronzied锁重入"><span class="toc-text">6.8、synchronzied锁重入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9、synchronized的原理"><span class="toc-text">6.9、synchronized的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10、synchronized底层实现原理"><span class="toc-text">6.10、synchronized底层实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-1、synchronized方法底层原理："><span class="toc-text">6.10.1、synchronized方法底层原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-2、synchonized代码块底层实现原理："><span class="toc-text">6.10.2、synchonized代码块底层实现原理：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-11、Java虚拟机对synchronized的优化"><span class="toc-text">6.11、Java虚拟机对synchronized的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-1、偏向锁"><span class="toc-text">6.11.1、偏向锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-2、轻量级锁"><span class="toc-text">6.11.2、轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-3、自旋锁"><span class="toc-text">6.11.3、自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-4、锁消除"><span class="toc-text">6.11.4、锁消除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7、wait、notify方法"><span class="toc-text">7、wait、notify方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1、含义（需仔细研读）"><span class="toc-text">7.1、含义（需仔细研读）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2、生产者消费者模式"><span class="toc-text">7.2、生产者消费者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1、-版本1产生假死-全部进入等待wait状态"><span class="toc-text">7.2.1、 版本1产生假死(全部进入等待wait状态)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2、多消费者、多生产者正确版本"><span class="toc-text">7.2.2、多消费者、多生产者正确版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3、多生产者、多消费者，-阻塞-错误版本，浪费执行机会"><span class="toc-text">7.2.3、多生产者、多消费者， 阻塞, 错误版本，浪费执行机会</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4、完全正确版本"><span class="toc-text">7.2.4、完全正确版本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-、捕获线程运行期间的异常"><span class="toc-text">8 、捕获线程运行期间的异常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9、ThreadGroup"><span class="toc-text">9、ThreadGroup</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10、单例设计模式"><span class="toc-text">10、单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#version1-（不好）"><span class="toc-text">version1 （不好）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#version2-错误"><span class="toc-text">version2 (错误)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#version3-不好"><span class="toc-text">version3 (不好)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#version4-不好"><span class="toc-text">version4 (不好)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#version5-正确、推荐"><span class="toc-text">version5 (正确、推荐)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#version-6-（正确）"><span class="toc-text">version 6 （正确）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11、volatile关键字"><span class="toc-text">11、volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-高并发的三个特性"><span class="toc-text">11.1 高并发的三个特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#省略一万行代码…"><span class="toc-text">省略一万行代码…</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12、比较并交换（CAS"><span class="toc-text">12、比较并交换（CAS)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1、使用CAS与使用锁相比的好处"><span class="toc-text">12.1、使用CAS与使用锁相比的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2、CAS原理"><span class="toc-text">12.2、CAS原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3、CAS实现计数器"><span class="toc-text">13.3、CAS实现计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3、使用CAS实现无锁同步"><span class="toc-text">13.3、使用CAS实现无锁同步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13、atomic包原子操作类（无锁CAS）"><span class="toc-text">13、atomic包原子操作类（无锁CAS）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1、AtomicInteger"><span class="toc-text">13.1、AtomicInteger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2、AtomicReference"><span class="toc-text">13.2、AtomicReference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2、CAS操作可能存在的ABA问题"><span class="toc-text">13.2、CAS操作可能存在的ABA问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-1、介绍"><span class="toc-text">13.2.1、介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-3、贵宾充值卡问题（ABA示例）"><span class="toc-text">13.2.3、贵宾充值卡问题（ABA示例）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3、AtomicStampedReference"><span class="toc-text">13.3、AtomicStampedReference</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-1、AtomicStampedReference原理"><span class="toc-text">13.3.1、AtomicStampedReference原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-2、AtomicStampedReference使用示例"><span class="toc-text">13.3.2、AtomicStampedReference使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-3、AtomicStampedReference解决贵宾卡多次充值问题"><span class="toc-text">13.3.3、AtomicStampedReference解决贵宾卡多次充值问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4、AtomicMarkableReference"><span class="toc-text">13.4、AtomicMarkableReference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4、AtomicIntegerArray"><span class="toc-text">13.4、AtomicIntegerArray</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-1、如果没有AtomicIntegerArray的错误示例"><span class="toc-text">13.4.1、如果没有AtomicIntegerArray的错误示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-2、atomicatintegerarray的正确使用"><span class="toc-text">13.4.2、atomicatintegerarray的正确使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5、atomicreferencearray"><span class="toc-text">13.5、atomicreferencearray</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6、atomicintegerfieldupdater"><span class="toc-text">13.6、atomicintegerfieldupdater</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14、Unsafe"><span class="toc-text">14、Unsafe</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1、获取unsafe"><span class="toc-text">14.1、获取unsafe</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16、JUC"><span class="toc-text">16、JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1、CountDownLatch"><span class="toc-text">16.1、CountDownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-1、介绍"><span class="toc-text">16.1.1、介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-2、入门示例"><span class="toc-text">16.1.2、入门示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2、CyclicBarrer"><span class="toc-text">16.2、CyclicBarrer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-1、简介"><span class="toc-text">16.2.1、简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-4、示例3"><span class="toc-text">16.2.4、示例3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-5、士兵报道示例"><span class="toc-text">16.2.5、士兵报道示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-5、CyclicBarrier的应用场景"><span class="toc-text">16.2.5、CyclicBarrier的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-6、CyclicBarrier和CountDownLatch的区别"><span class="toc-text">16.2.6、CyclicBarrier和CountDownLatch的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-3、Exchanger"><span class="toc-text">16.3、Exchanger</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-1、介绍"><span class="toc-text">16.3.1、介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-3、exchage-超时控制"><span class="toc-text">16.3.3、exchage()超时控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-4、Semaphore"><span class="toc-text">16.4、Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-1、介绍"><span class="toc-text">16.4.1、介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-2、Semaphore实现同步锁"><span class="toc-text">16.4.2、Semaphore实现同步锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-3、构造方法permits参数作用"><span class="toc-text">16.4.3、构造方法permits参数作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-4、acquire-permits-的作用"><span class="toc-text">16.4.4、acquire(permits)的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-5、动态增加许可数量（release-）及drainPermits"><span class="toc-text">16.4.5、动态增加许可数量（release()）及drainPermits()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-6、acquireUninterruptibly-的作用"><span class="toc-text">16.4.6、acquireUninterruptibly()的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-7、getQueueLength-和hasQueueThreads"><span class="toc-text">16.4.7、getQueueLength()和hasQueueThreads()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-8、获取许可的公平与非公平测试"><span class="toc-text">16.4.8、获取许可的公平与非公平测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-9、tryAcquire"><span class="toc-text">16.4.9、tryAcquire()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-5、ReentrantLock"><span class="toc-text">16.5、ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-1、介绍"><span class="toc-text">16.5.1、介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-2、线程间同步"><span class="toc-text">16.5.2、线程间同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-2、公平与非公平获取锁、isFair-、isLock"><span class="toc-text">16.5.2、公平与非公平获取锁、isFair()、isLock()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-3、Condition"><span class="toc-text">16.5.3、Condition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-4、getHolderCount"><span class="toc-text">16.5.4、getHolderCount()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-5、getQueuedLength-、hasQueueuedThreads"><span class="toc-text">16.5.5、getQueuedLength()、hasQueueuedThreads()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-6、getWaitQueueLength-Condition-c-、hasWaiters-Condition-c"><span class="toc-text">16.5.6、getWaitQueueLength(Condition c)、hasWaiters(Condition c)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-7、lock-、lockInterruptibly"><span class="toc-text">16.5.7、lock()、lockInterruptibly()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-8、tryLock"><span class="toc-text">16.5.8、tryLock()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-8、Contition-awaitUninterrupyibly"><span class="toc-text">16.5.8、Contition.awaitUninterrupyibly()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-9、condition-awaitUntil-Date-deadlineDate"><span class="toc-text">16.5.9、condition.awaitUntil(Date deadlineDate)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-1、可重入功能"><span class="toc-text">16.6.1、可重入功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-6、ReentrantReadWriteLock"><span class="toc-text">16.6、ReentrantReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-1、读读共享"><span class="toc-text">16.6.1、读读共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-2、写写互斥"><span class="toc-text">16.6.2、写写互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-3、读写互斥-先读后写"><span class="toc-text">#16.6.3、读写互斥(先读后写)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-4、写读互斥（先写后读）"><span class="toc-text">16.6.4、写读互斥（先写后读）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-7、StampedLock"><span class="toc-text">16.7、StampedLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-1、介绍"><span class="toc-text">16.7.1、介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-2、-StampedLock的特点"><span class="toc-text">16.7.2、 StampedLock的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-3、oracle官方示例"><span class="toc-text">16.7.3、oracle官方示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-4、实现原理"><span class="toc-text">16.7.4、实现原理</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">java并发编程入门</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2019-12-29<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-01-10</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">18.4k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 72 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2019/12/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2019/12/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="1、入门介绍"><a href="#1、入门介绍" class="headerlink" title="1、入门介绍"></a>1、入门介绍</h1><h2 id="1-1、实现线程的2种方式"><a href="#1-1、实现线程的2种方式" class="headerlink" title="1.1、实现线程的2种方式"></a>1.1、实现线程的2种方式</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 14:05</span><br><span class="line"> */</span><br><span class="line">public class MyThreadDemo1 {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        new Thread1().start();</span><br><span class="line">        </span><br><span class="line">        new Thread(new Thread2()).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Thread1 extends Thread{</span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Thread2 implements Runnable{</span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="1-2、线程的状态（生命周期）"><a href="#1-2、线程的状态（生命周期）" class="headerlink" title="1.2、线程的状态（生命周期）"></a>1.2、线程的状态（生命周期）</h2><h3 id="1-2-1、线程的5种状态"><a href="#1-2-1、线程的5种状态" class="headerlink" title="1.2.1、线程的5种状态"></a>1.2.1、线程的5种状态</h3><p>1. <strong>新建(NEW)</strong>：新创建了一个线程对象。</p>
<p>2. <strong>可运行(RUNNABLE)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p>
<p>3. <strong>运行(RUNNING)</strong>：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p>
<p>4. <strong>阻塞(BLOCKED)</strong>：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</span><br><span class="line">(二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</span><br><span class="line">(三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</span><br></pre></td></tr></tbody></table></figure></div>
<p>5. <strong>死亡(DEAD)</strong>：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>
<h3 id="1-2-2、线程运行状态图"><a href="#1-2-2、线程运行状态图" class="headerlink" title="1.2.2、线程运行状态图"></a>1.2.2、线程运行状态图</h3><p><a href="https://oscimg.oschina.net/oscnet/up-eb5d2db11964516af51c019671105b82e47.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-eb5d2db11964516af51c019671105b82e47.png" class="lazyload"></a></p>
<p><strong>1). 初始状态</strong></p>
<ol>
<li>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态</li>
</ol>
<p><strong>2). 可运行状态</strong></p>
<ol>
<li>可运行状态只是说你资格运行，调度程序没有挑选到你，你就永远是可运行状态。</li>
<li>调用线程的start()方法，此线程进入可运行状态。</li>
<li>当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入可运行状态。</li>
<li>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入可运行状态。</li>
<li>锁池里的线程拿到对象锁后，进入可运行状态。</li>
</ol>
<p><strong>3). 运行状态</strong></p>
<ol>
<li>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</li>
</ol>
<p><strong>4). 死亡状态</strong></p>
<ol>
<li>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。</li>
<li>在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</li>
</ol>
<p><strong>5). 阻塞状态</strong></p>
<ol>
<li>当前线程T调用Thread.sleep()方法，当前线程进入阻塞状态。</li>
<li>运行在当前线程里的其它线程t2调用join()方法，当前线程进入阻塞状态。</li>
<li>等待用户输入的时候，当前线程进入阻塞状态。</li>
</ol>
<p><strong>6). 等待队列(是Object里的方法，但影响了线程)</strong></p>
<ol>
<li>调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内。</li>
<li>与等待队列相关的步骤和图</li>
</ol>
<ul>
<li>线程1获取对象A的锁，正在使用对象A。</li>
<li>线程1调用对象A的wait()方法。</li>
<li>线程1释放对象A的锁，并马上进入等待队列。</li>
<li>锁池里面的对象争抢对象A的锁。</li>
<li>线程5获得对象A的锁，进入synchronized块，使用对象A。</li>
<li>线程5调用对象A的notifyAll()方法，唤醒所有线程，所有线程进入锁池。||||| 线程5调用对象A的notify()方法，唤醒一个线程，不知道会唤醒谁，被唤醒的那个线程进入锁池。</li>
<li>notifyAll()方法所在synchronized结束，线程5释放对象A的锁。</li>
<li>锁池里面的线程争抢对象锁，但线程1什么时候能抢到就不知道了。||||| 原本锁池+第6步被唤醒的线程一起争抢对象锁。</li>
</ul>
<p><a href="https://oscimg.oschina.net/oscnet/up-69a8d075ff73baa13a29f1d937c2e346c06.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-69a8d075ff73baa13a29f1d937c2e346c06.png" class="lazyload"></a></p>
<p><strong>7). 锁池状态</strong></p>
<ol>
<li>当前线程想调用对象A的同步方法时，发现对象A的锁被别的线程占有，此时当前线程进入锁池状态。简言之，锁池里面放的都是想争夺对象锁的线程。</li>
<li>当一个线程1被另外一个线程2唤醒时，1线程进入锁池状态，去争夺对象锁。</li>
<li>锁池是在同步的环境下才有的概念，一个对象对应一个锁池。<h2 id="1-3-sleep、yield、join、wait的比较"><a href="#1-3-sleep、yield、join、wait的比较" class="headerlink" title="1.3. **sleep、yield、join、wait的比较**"></a><strong>1.3. **sleep、yield、join、wait</strong>的比较**</h2></li>
<li>Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程<strong>进入阻塞</strong>，但<strong>不释放对象锁</strong>，millis后线程<strong>自动苏醒进入可运行状态</strong>。作用：给其它线程执行机会的最佳方式。</li>
<li>Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的cpu时间片，由运行状态变会可运行状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。</li>
<li>t.join()/t.join(long millis)，当前线程里调用其它线程1的join方法，当前线程阻塞，但不释放对象锁，直到线程1执行完毕或者millis时间到，当前线程进入可运行状态。</li>
<li>obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout)timeout时间到自动唤醒。</li>
<li>obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。<h2 id="1-4、Thread-sleep-long-time"><a href="#1-4、Thread-sleep-long-time" class="headerlink" title="1.4、Thread.sleep(long time)"></a>1.4、Thread.sleep(long time)</h2>Thread.sleep(long time)方法的作用是让当前正在执行的线程休眠(让出CPU时间片)指定的毫秒数。</li>
</ol>
<p>需要注意的是：</p>
<ul>
<li><p>调用sleep()方法时，如果当前线程持有锁<strong>不会导致当前线程释放锁</strong>。</p>
</li>
<li><p>sleep不释放锁 线程是进入阻塞状态还是就绪状态？</p>
<p>答案是<strong>进入阻塞状态</strong>，确切的说<strong>Thread在Java的TIMED_WAITING状态</strong>（但这个状态其实并没那么重要，可以认为是java的内部细节，用户不用太操心）。往下一层，在不同OS上底层的sleep的实现细节不太一样。但是大体上就是挂起当前的线程，然后<strong>设置一个信号或者时钟中断到时候唤醒</strong>。sleep后的的Thread在被唤醒前是不会消耗任何CPU的（确切的说，大部分OS都会这么实现，除非某个OS的实现偷懒了）。这点上，wait对当前线程的效果差不多是一样的，也会暂停调度，等着notify或者一个超时的时间。期间CPU也不会被消耗。</p>
</li>
</ul>
<h1 id="2、多线程实现银行叫号排队"><a href="#2、多线程实现银行叫号排队" class="headerlink" title="2、多线程实现银行叫号排队"></a>2、多线程实现银行叫号排队</h1><h2 id="2-1-版本1"><a href="#2-1-版本1" class="headerlink" title="2.1 版本1"></a>2.1 版本1</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package chapter2.version1;</span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 8:58</span><br><span class="line"> */</span><br><span class="line">public class Bank {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        TicketWindow ticketWindow = new TicketWindow("1号窗口");</span><br><span class="line">        TicketWindow ticketWindow2 = new TicketWindow("2号窗口");</span><br><span class="line">        TicketWindow ticketWindow3 = new TicketWindow("3号窗口");</span><br><span class="line">        ticketWindow.start();</span><br><span class="line">        ticketWindow2.start();</span><br><span class="line">        ticketWindow3.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>


<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package chapter2.version1;</span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 8:58</span><br><span class="line"> */</span><br><span class="line">public class TicketWindow extends Thread {</span><br><span class="line">    private static int MAX = 50;</span><br><span class="line"></span><br><span class="line">    private static int current = 1;</span><br><span class="line">    private String name;</span><br><span class="line">    public TicketWindow(String name){</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line"></span><br><span class="line">        while (current < MAX){</span><br><span class="line">            System.out.println("窗口：" + name +" 当前叫号:" + current);</span><br><span class="line">            current++;</span><br><span class="line"></span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>此版本中注意TicketWindow 类的成员变量current 为static, 表示无论实例化这个类多少次，都共享同一份变量，因为这个变量是在类加载的时候就已经创建好的。为了让多个线程消耗同一个current 所以才定义为static的，不然每个线程的current都是各自的，与其他线程不相关。</p>
<p>以上代码把业务与线程紧密掺杂在一起，为了让多个线程访问同一份current把他定义为static明显是不合适的。</p>
<h2 id="2-2-版本2"><a href="#2-2-版本2" class="headerlink" title="2.2 版本2"></a>2.2 版本2</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package chapter2.version2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 8:58</span><br><span class="line"> */</span><br><span class="line">public class Bank {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        // 有线程安全问题， 多个线程同时访问到current变量</span><br><span class="line">        TicketWindow ticketWindow = new TicketWindow();</span><br><span class="line"></span><br><span class="line">        Thread windowThread1 = new Thread(ticketWindow, "1号窗口");</span><br><span class="line">        Thread windowThread2 = new Thread(ticketWindow, "2号窗口");</span><br><span class="line">        Thread windowThread3 = new Thread(ticketWindow, "3号窗口");</span><br><span class="line"></span><br><span class="line">        windowThread1.start();</span><br><span class="line">        windowThread2.start();</span><br><span class="line">        windowThread3.start();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>}</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package chapter2.version2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 9:02</span><br><span class="line"> */</span><br><span class="line">public class TicketWindow implements Runnable {</span><br><span class="line"></span><br><span class="line">    private int MAX = 50;</span><br><span class="line"></span><br><span class="line">    private int current = 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line"></span><br><span class="line">        while (current < MAX){</span><br><span class="line">            System.out.println("窗口：" + Thread.currentThread().getName() +" 当前叫号:" + current);</span><br><span class="line">            current++;</span><br><span class="line"></span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div>
<p>}</p>
<p>这里TicketWindow 并不是继承Thread, 这样启动线程多次线程可以共享同一份TicketWindow 实例， 把业务逻辑与线程启动拆分清晰明了。<br>注：以上2个版本均存在线程安全性问题，这是由于current变量在run()方法可能被多个线程同时访问， 可能多个线程同时执行到</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println("窗口：" + Thread.currentThread().getName() +" 当前叫号:" + current);</span><br></pre></td></tr></tbody></table></figure></div>
<p>这行代码，导致不同的线程打印出了一样的叫号值，比如运行以上程序会输出如下结果：<br><a href="https://oscimg.oschina.net/oscnet/up-8fcf7e22ed3d11bc74d176d1e8564bb2760.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-8fcf7e22ed3d11bc74d176d1e8564bb2760.png" class="lazyload"></a></p>
<h1 id="3、守护线程"><a href="#3、守护线程" class="headerlink" title="3、守护线程"></a>3、守护线程</h1><p>要点：<strong>守护线程会随着父线程的退出而退出</strong>， 守护线程适宜一些<strong>辅助性</strong>的工作，而<strong>不能</strong>把核心工作的线程设置为守护线程。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 14:07</span><br><span class="line"> */</span><br><span class="line">public class DeemonThreadDemo {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Thread thread = new Thread(){</span><br><span class="line">            @Override</span><br><span class="line">            public void run() {</span><br><span class="line">                while (true){</span><br><span class="line">                    System.out.println("hello");</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        // 设置为守护线程</span><br><span class="line">        thread.setDaemon(true);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println("主线程退出");</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-fc85a47ea7391a6b16833ee05dd676bdbb6.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-fc85a47ea7391a6b16833ee05dd676bdbb6.png" class="lazyload"></a></p>
<p>从代码中可以看到thread 中的代码有while(true){  }语句， 在我们的映像中while(true)是死循环应该永远不退出，永远打印hello, 但是从输出结果可以看到运行一段时间后就没有再打印了，说明父线程结束执行了，子线程也随机退出了。</p>
<h1 id="4、Thread-join"><a href="#4、Thread-join" class="headerlink" title="4、Thread.join()"></a>4、Thread.join()</h1><p>Thread.join() 作用：调用join()方法的线程会等到他自己执行结束才会继续往后执行</p>
<p>Thread.join(time) 作用：调用join(time)方法的线程会等到他自己执行指定时间后就会继续往后执行，</p>
<h2 id="4-1-无限等待"><a href="#4-1-无限等待" class="headerlink" title="4.1 无限等待"></a>4.1 无限等待</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 14:32</span><br><span class="line"> */</span><br><span class="line">public class ThreadJoinDemo {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException {</span><br><span class="line">        Thread thread1 = new Thread(() -> {</span><br><span class="line">            for (int i =0; i < 500; i++){</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + ":" + i);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        Thread thread2 = new Thread(() -> {</span><br><span class="line">            for (int i =0; i < 500; i++){</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + ":" + i);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println("所有线程已结束执行");</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-6c25e6adc13c34ee3c2bcf73460b942021b.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-6c25e6adc13c34ee3c2bcf73460b942021b.png" class="lazyload"></a>)<a href="https://oscimg.oschina.net/oscnet/up-9659c2379ef2e59b476b021b69dc6cf36ff.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-9659c2379ef2e59b476b021b69dc6cf36ff.png" class="lazyload"></a></p>
<p>thread1 和thread2交互执行， 而main线程的打印结果<strong>一定是在2个线程全部执行完后</strong>才打印结果。</p>
<h2 id="4-2-等待指定时间"><a href="#4-2-等待指定时间" class="headerlink" title="4.2 等待指定时间"></a>4.2 等待指定时间</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 14:32</span><br><span class="line"> */</span><br><span class="line">public class ThreadJoinDemo2 {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException {</span><br><span class="line">        Thread thread1 = new Thread(() -> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +"开始执行");</span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +"结束执行");</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        </span><br><span class="line">        // 虽然join了， 但是只会等待指定的时间，而不会无限等待</span><br><span class="line">        thread1.join(1000);</span><br><span class="line"></span><br><span class="line">        System.out.println("主线程等到1000毫秒就执行到了，而无需等到thread1执行完毕");</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-f5f42565688249377afbecc3c3e345ebaeb.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-f5f42565688249377afbecc3c3e345ebaeb.png" class="lazyload"></a></p>
<h1 id="5、中断线程的几种方式"><a href="#5、中断线程的几种方式" class="headerlink" title="5、中断线程的几种方式"></a>5、中断线程的几种方式</h1><h2 id="5-1、介绍"><a href="#5-1、介绍" class="headerlink" title="5.1、介绍"></a>5.1、介绍</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 14:53</span><br><span class="line"> */</span><br><span class="line">public class ThreadInterrupt {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Thread thread = new Thread(() ->{</span><br><span class="line">            while (true){</span><br><span class="line">                try {</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    System.out.println("线程被打断");</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">                    // 中断后让其退出while循环， 这样来控制线程的退出</span><br><span class="line">                    break;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line">        // 打断thread线程的sleep, 让thread1不再继续sleep</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line"></span><br><span class="line">        System.out.println("主线程退出");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2(){</span><br><span class="line">        Object MONITOR = new Object();</span><br><span class="line"></span><br><span class="line">        Thread thread = new Thread(() ->{</span><br><span class="line">            while (true){</span><br><span class="line">                synchronized (MONITOR){</span><br><span class="line">                    try {</span><br><span class="line">                        MONITOR.wait(100);</span><br><span class="line">                    } catch (InterruptedException e) {</span><br><span class="line">                        System.out.println("线程被打断" + Thread.interrupted());</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(thread.isInterrupted());</span><br><span class="line"></span><br><span class="line">        System.out.println("主线程退出");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test3(){</span><br><span class="line">        Thread thread1 = new Thread(() -> {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +"开始执行");</span><br><span class="line">            while (true){</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        Thread main = Thread.currentThread();</span><br><span class="line">        Thread thread2 = new Thread(() -> {</span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            // 目前是main线程在等待thread1线程，所以需要打断main线程，才能让main线程不再继续等待而是继续往后执行</span><br><span class="line">            main.interrupt();</span><br><span class="line">            System.out.println("interrupt");</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            // main线程会等待thread1线程执行完毕才能继续往后执行</span><br><span class="line">            thread1.join();</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println("主线程执行到了");</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="5-2、通过whilte-running-变量控制"><a href="#5-2、通过whilte-running-变量控制" class="headerlink" title="5.2、通过whilte(running) { }变量控制"></a>5.2、通过whilte(running) { }变量控制</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 15:34</span><br><span class="line"> */</span><br><span class="line">public class ThreadCloseDemo {</span><br><span class="line"></span><br><span class="line">    class Worker implements Runnable{</span><br><span class="line">        private volatile boolean running = true;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() {</span><br><span class="line">            // 这里有问题， 假如doSomething()非常耗时， 下一次执行while (running)没有机会得到执行，没法立即中断</span><br><span class="line">            while (running){</span><br><span class="line">                // 假如执行doSomething()方法</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            System.out.println("退出死循环");</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public void shutdown(){</span><br><span class="line">            this.running = false;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void close1(){</span><br><span class="line">        Worker worker = new Worker();</span><br><span class="line">        Thread thread = new Thread(worker);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        worker.shutdown();</span><br><span class="line"></span><br><span class="line">        System.out.println("主线程执行完毕");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>



<p>test1()的执行结果：</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-4cf535f5c40645ca6c10871df66b369df36.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-4cf535f5c40645ca6c10871df66b369df36.png" class="lazyload"></a></p>
<h2 id="5-3、通过Thread-interrupt-控制"><a href="#5-3、通过Thread-interrupt-控制" class="headerlink" title="5.3、通过Thread.interrupt()控制"></a>5.3、通过Thread.interrupt()控制</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 15:34</span><br><span class="line"> */</span><br><span class="line">public class ThreadCloseDemo2 {</span><br><span class="line"></span><br><span class="line">    class Worker2 implements Runnable{</span><br><span class="line">        private volatile boolean running = true;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() {</span><br><span class="line">            while (true){</span><br><span class="line">                if (Thread.currentThread().isInterrupted()){</span><br><span class="line">                    break;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                // 这里有问题， 假如doSomething()非常耗时， 上面的代码根本没有机会得到执行，没法立即中断</span><br><span class="line">                // doSomething()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            System.out.println("退出死循环");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void close2(){</span><br><span class="line">        Worker2 worker = new Worker2();</span><br><span class="line">        Thread thread = new Thread(worker);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        thread.interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println("主线程执行完毕");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-cd01ac61f21bcd2cfd77f33fe4be6257a37.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-cd01ac61f21bcd2cfd77f33fe4be6257a37.png" class="lazyload"></a></p>
<h2 id="5-4、暴力终止"><a href="#5-4、暴力终止" class="headerlink" title="5.4、暴力终止"></a>5.4、暴力终止</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 16:06</span><br><span class="line"> */</span><br><span class="line">public class ThreadCloseDemo2 {</span><br><span class="line"></span><br><span class="line">    class ThreadService{</span><br><span class="line"></span><br><span class="line">        private Thread executeThread;</span><br><span class="line"></span><br><span class="line">        private boolean running = true;</span><br><span class="line"></span><br><span class="line">        public void execute(Runnable task){</span><br><span class="line"></span><br><span class="line">            executeThread = new Thread(() -> {</span><br><span class="line">                Thread workerThread = new Thread(task);</span><br><span class="line">                workerThread.setDaemon(true);</span><br><span class="line">                workerThread.start();</span><br><span class="line"></span><br><span class="line">                //</span><br><span class="line">                try {</span><br><span class="line">                    // 让executeThread等待workerThread结束执行才往后执行</span><br><span class="line">                    // 假如workerThread比较耗时，由于守护线程是依附于父线程的，假如这里不join，</span><br><span class="line">                    // 那么可能会产生workerThread还没有真正执行完，executeThread线程就执行完了，导致workerThread也跟着退出了</span><br><span class="line">                    workerThread.join();</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    // e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                //executeThread线程被打断等待 或者 workerThread正常执行结束</span><br><span class="line">                this.running = false;</span><br><span class="line"></span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            executeThread.start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public void shutdown(long timeout){</span><br><span class="line">            long beginTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            // workerThread还在执行</span><br><span class="line">            while (running){</span><br><span class="line">                // 判断是否等待超时</span><br><span class="line">                if (System.currentTimeMillis() - beginTime >= timeout){</span><br><span class="line">                    // 等待超时了， 中断executeThread的等待会使this.running = false;执行到，</span><br><span class="line">                    // executeThread执行完毕导致workerThread守护线程跟着退出</span><br><span class="line">                    executeThread.interrupt();</span><br><span class="line"></span><br><span class="line">                    //退出while循环</span><br><span class="line">                    break;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                try {</span><br><span class="line">                    Thread.sleep(1);</span><br><span class="line">                }</span><br><span class="line">                catch (InterruptedException e) {</span><br><span class="line">                    // 说明main线程被打断了</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">                    break;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        public boolean isRunning(){</span><br><span class="line">            return this.running;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 必须等待3秒后才结束执行</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void test1() {</span><br><span class="line">        ThreadService threadService = new ThreadService();</span><br><span class="line">        threadService.execute(() -> {</span><br><span class="line">            // 这是一个非常非常耗时的操作</span><br><span class="line">           while (true){</span><br><span class="line"></span><br><span class="line">           }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        //让线程2秒后立即中断执行</span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line">        threadService.shutdown(3000);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println("耗时： " + (end - begin));</span><br><span class="line"></span><br><span class="line">        System.out.println("主线程执行结果");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 跟随threadService的执行而结束，无需等待3秒（1秒后就可以执行主线程后续的代码）</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() {</span><br><span class="line">        ThreadService threadService = new ThreadService();</span><br><span class="line">        threadService.execute(() -> {</span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        //让线程2秒后立即中断执行</span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line">        threadService.shutdown(3000);</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println("耗时： " + (end - begin));</span><br><span class="line"></span><br><span class="line">        System.out.println("主线程执行结果");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>




<h2 id="5-5、interrupt-、interrupted-、isInterrupted-区别与原理"><a href="#5-5、interrupt-、interrupted-、isInterrupted-区别与原理" class="headerlink" title="5.5、interrupt()、interrupted()、isInterrupted()区别与原理"></a>5.5、interrupt()、interrupted()、isInterrupted()区别与原理</h2><h3 id="5-5-1、结论"><a href="#5-5-1、结论" class="headerlink" title="5.5.1、结论"></a>5.5.1、结论</h3><ul>
<li>interrupt()方法：用于中断线程的，调用该方法的线程的状态将被置为”中断”状态。<strong>注意：线程中断仅仅是设置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态并做处理</strong>。支持线程中断的方法（也就是线程中断后会抛出InterruptedException的方法，比如Thread.sleep，以及Object.wait等方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常,并将线程的中断状态为设置为false。</li>
<li>interrupted()：返回线程是否处于已中断状态并清除中断状态</li>
<li>isInterrupted()：返回线程是否处于已中断状态</li>
</ul>
<h3 id="5-5-2、原理"><a href="#5-5-2、原理" class="headerlink" title="5.5.2、原理"></a>5.5.2、原理</h3><p>以下内容来源于 <a href="https://my.oschina.net/itblog/blog/787024" target="_blank" rel="noopener">https://my.oschina.net/itblog/blog/787024</a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Interrupt {</span><br><span class="line">	public static void main(String[] args) throws Exception {</span><br><span class="line">		Thread t = new Thread(new Worker());</span><br><span class="line">		t.start();</span><br><span class="line">		</span><br><span class="line">		Thread.sleep(200);</span><br><span class="line">		t.interrupt();</span><br><span class="line">		</span><br><span class="line">		System.out.println("Main thread stopped.");</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	public static class Worker implements Runnable {</span><br><span class="line">		public void run() {</span><br><span class="line">			System.out.println("Worker started.");</span><br><span class="line">			</span><br><span class="line">			try {</span><br><span class="line">				Thread.sleep(500);</span><br><span class="line">			} catch (InterruptedException e) {</span><br><span class="line">				System.out.println("Worker IsInterrupted: " + </span><br><span class="line">						Thread.currentThread().isInterrupted());</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			System.out.println("Worker stopped.");</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>内容很简单：主线程main启动了一个子线程Worker，然后让worker睡500ms，而main睡200ms，之后main调用worker线程的interrupt方法去中断worker，worker被中断后打印中断的状态。<br>下面是执行结果：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Worker started.</span><br><span class="line">Main thread stopped.</span><br><span class="line">Worker IsInterrupted: false</span><br><span class="line">Worker stopped.</span><br></pre></td></tr></tbody></table></figure></div>
<p><strong>Worker明明已经被中断，而isInterrupted()方法竟然返回了false，为什么呢？</strong></p>
<p>在stackoverflow上搜索了一圈之后，发现有网友提到：可以查看抛出InterruptedException方法的JavaDoc（或源代码），于是我查看了Thread.sleep方法的文档，doc中是这样描述这个InterruptedException异常的：</p>
<blockquote>
<p>InterruptedException - if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is thrown.</p>
</blockquote>
<p>注意到后面这句“<strong>当抛出这个异常的时候，中断状态已被清除</strong>”。所以isInterrupted()方法应该返回false。可是有的时候，我们需要isInterrupted这个方法返回true，怎么办呢？这里就要先说说interrupt, interrupted和isInterrupted的区别了：</p>
<p>interrupt方法是用于中断线程的，调用该方法的线程的状态将被置为”中断”状态。注意：<strong>线程中断仅仅是设置线程的中断状态位，不会停止线程</strong>。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出InterruptedException的方法，比如这里的sleep，以及Object.wait等方法）就是<strong>在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常</strong>。这个观点可以通过<a href="http://www.ibm.com/developerworks/library/j-jtp05236/" target="_blank" rel="noopener">这篇文章</a>证实：</p>
<p>再来看看interrupted方法的实现：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static boolean interrupted() {</span><br><span class="line">    return currentThread().isInterrupted(true);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>和isInterrupted的实现：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean isInterrupted() {</span><br><span class="line">    return isInterrupted(false);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>这两个方法一个是static的，一个不是，但实际上都是在调用同一个方法，只是interrupted方法传入的参数为true，而iInterrupted传入的参数为false。那么这个参数到底是什么意思呢？来看下这个isInterrupted(boolean)方法的实现：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Tests if some Thread has been interrupted.  The interrupted state</span><br><span class="line"> * is reset or not based on the value of ClearInterrupted that is</span><br><span class="line"> * passed.</span><br><span class="line"> */</span><br><span class="line">private native boolean isInterrupted(boolean ClearInterrupted);</span><br></pre></td></tr></tbody></table></figure></div>
<p>这是一个native方法，看不到源码没有关系，参数名字ClearInterrupted已经清楚的表达了该参数的作用—-是否清除中断状态。方法的注释也清晰的表达了“中断状态将会根据传入的ClearInterrupted参数值确定是否重置”。所以，<strong>静态方法interrupted将会清除中断状态</strong>（传入的参数ClearInterrupted为true），而<strong>实例方法isInterrupted则不会</strong>（传入的参数ClearInterrupted为false）。<br>回到刚刚的问题：很明显，如果要isInterrupted这个方法返回true，通过<strong>在调用isInterrupted方法之前再次调用interrupt()方法</strong>来恢复这个中断的状态即可：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Interrupt  {</span><br><span class="line">	public static void main(String[] args) throws Exception {</span><br><span class="line">		Thread t = new Thread(new Worker());</span><br><span class="line">		t.start();</span><br><span class="line">		</span><br><span class="line">		Thread.sleep(200);</span><br><span class="line">		t.interrupt();</span><br><span class="line">		</span><br><span class="line">		System.out.println("Main thread stopped.");</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	public static class Worker implements Runnable {</span><br><span class="line">		public void run() {</span><br><span class="line">			System.out.println("Worker started.");</span><br><span class="line">			</span><br><span class="line">			try {</span><br><span class="line">				Thread.sleep(500);</span><br><span class="line">			} catch (InterruptedException e) {</span><br><span class="line">				Thread curr = Thread.currentThread();</span><br><span class="line">				//再次调用interrupt方法中断自己，将中断状态设置为“中断”</span><br><span class="line">				curr.interrupt();</span><br><span class="line">				System.out.println("Worker IsInterrupted: " + curr.isInterrupted());</span><br><span class="line">				System.out.println("Worker IsInterrupted: " + curr.isInterrupted());</span><br><span class="line">				System.out.println("Static Call: " + Thread.interrupted());//clear status</span><br><span class="line">				System.out.println("---------After Interrupt Status Cleared----------");</span><br><span class="line">				System.out.println("Static Call: " + Thread.interrupted());</span><br><span class="line">				System.out.println("Worker IsInterrupted: " + curr.isInterrupted());</span><br><span class="line">				System.out.println("Worker IsInterrupted: " + curr.isInterrupted());</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			System.out.println("Worker stopped.");</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>执行结果：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Worker started.</span><br><span class="line">Main thread stopped.</span><br><span class="line">Worker IsInterrupted: true</span><br><span class="line">Worker IsInterrupted: true</span><br><span class="line">Static Call: true</span><br><span class="line">---------After Interrupt Status Cleared----------</span><br><span class="line">Static Call: false</span><br><span class="line">Worker IsInterrupted: false</span><br><span class="line">Worker IsInterrupted: false</span><br><span class="line">Worker stopped.</span><br></pre></td></tr></tbody></table></figure></div>
<p>从执行结果也可以看到，前两次调用isInterrupted方法都返回true，说明isInterrupted方法不会改变线程的中断状态，而接下来调用静态的interrupted()方法，第一次返回了true，表示线程被中断，第二次则返回了false，因为第一次调用的时候已经清除了中断状态。最后两次调用isInterrupted()方法就肯定返回false了。</p>
<p>那么，<strong>在什么场景下，我们需要在catch块里面中断线程（重置中断状态）呢？</strong></p>
<p>答案是：<strong>如果不能抛出InterruptedException</strong>（就像这里的Thread.sleep语句放在了Runnable的run方法中，这个方法不允许抛出任何受检查的异常），但又<strong>想告诉上层调用者这里发生了中断</strong>的时候，就只能在catch里面重置中断状态了。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TaskRunner implements Runnable {</span><br><span class="line">    private BlockingQueue<task> queue;</task></span><br><span class="line"> </span><br><span class="line">    public TaskRunner(BlockingQueue<task> queue) { </task></span><br><span class="line">        this.queue = queue; </span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    public void run() { </span><br><span class="line">        try {</span><br><span class="line">             while (true) {</span><br><span class="line">                 Task task = queue.take(10, TimeUnit.SECONDS);</span><br><span class="line">                 task.execute();</span><br><span class="line">             }</span><br><span class="line">         } catch (InterruptedException e) { </span><br><span class="line">             // Restore the interrupted status</span><br><span class="line">             Thread.currentThread().interrupt();</span><br><span class="line">         }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p>那么问题来了：<strong>为什么要在抛出InterruptedException的时候清除掉中断状态呢？</strong></p>
<p>这个问题没有找到官方的解释，估计只有Java设计者们才能回答了。但<a href="http://stackoverflow.com/questions/2523721/why-do-interruptedexceptions-clear-a-threads-interrupted-status" target="_blank" rel="noopener">这里</a>的解释似乎比较合理：<strong>一个中断应该只被处理一次</strong>（你catch了这个InterruptedException，说明你能处理这个异常，你不希望上层调用者看到这个中断）。</p>
<p>参考地址：</p>
<p><a href="https://my.oschina.net/itblog/blog/787024" target="_blank" rel="noopener">https://my.oschina.net/itblog/blog/787024</a></p>
<p><a href="http://stackoverflow.com/questions/7142665/why-does-thread-isinterrupted-always-return-false" target="_blank" rel="noopener">http://stackoverflow.com/questions/7142665/why-does-thread-isinterrupted-always-return-false</a></p>
<p><a href="http://stackoverflow.com/questions/2523721/why-do-interruptedexceptions-clear-a-threads-interrupted-status" target="_blank" rel="noopener">http://stackoverflow.com/questions/2523721/why-do-interruptedexceptions-clear-a-threads-interrupted-status</a></p>
<p><a href="http://www.ibm.com/developerworks/library/j-jtp05236/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/library/j-jtp05236/</a></p>
<p><a href="http://blog.csdn.net/z69183787/article/details/25076033" target="_blank" rel="noopener">http://blog.csdn.net/z69183787/article/details/25076033</a></p>
<h1 id="6、synchronized"><a href="#6、synchronized" class="headerlink" title="6、synchronized"></a>6、synchronized</h1><h2 id="6-1、示例代码"><a href="#6-1、示例代码" class="headerlink" title="6.1、示例代码"></a>6.1、示例代码</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 17:11</span><br><span class="line"> */</span><br><span class="line">public class SynchronizedDemo {</span><br><span class="line"></span><br><span class="line">    private static final Object LOCK = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Runnable runnable = () -> {</span><br><span class="line">            synchronized (LOCK){</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +"正在执行");</span><br><span class="line">                try {</span><br><span class="line">                    Thread.sleep(60_000);</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() +"执行结束");</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        Thread thread1 = new Thread(runnable);</span><br><span class="line">        Thread thread2 = new Thread(runnable);</span><br><span class="line">        Thread thread3 = new Thread(runnable);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        System.out.println("主线程执行结束");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>


<h2 id="6-2、通过jconsole查看"><a href="#6-2、通过jconsole查看" class="headerlink" title="6.2、通过jconsole查看"></a>6.2、通过jconsole查看</h2><p>通过在cmd输入<strong>jconsole</strong>命令显示如下界面：</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-18779b62effbfca55ebe3ebb94a738bed72.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-18779b62effbfca55ebe3ebb94a738bed72.png" class="lazyload"></a></p>
<p>选中本地进程中刚刚运行的java程序， 进入主界面</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-d0e71af143f7185b5e4a400f33848378075.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-d0e71af143f7185b5e4a400f33848378075.png" class="lazyload"></a></p>
<p>可以看到 Thread-0 、Thread-1、Thread-2运行的三个线程，点击对应线程右边可以看到“拥有者 Thread-0”</p>
<h2 id="6-3、通过jps、jstack查看"><a href="#6-3、通过jps、jstack查看" class="headerlink" title="6.3、通过jps、jstack查看"></a>6.3、通过jps、jstack查看</h2><p><a href="https://oscimg.oschina.net/oscnet/up-24a22e5653805abe5649f5e7f33cc191478.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-24a22e5653805abe5649f5e7f33cc191478.png" class="lazyload"></a></p>
<p>启动程序后：</p>
<p>第1步：输入jps命令， 查看当前正在运行的java进程</p>
<p>第2步: 输入jstack [pid]  可以看到有三个线程 Thread-1、Thread-2均处于BLOCKED(on object nonitor)状态、而Thread-0处于TIMED_WATING(sleepint)状态（因为Thread.sleep()的作用）</p>
<h2 id="6-4、通过javap-c-xxxx-class-命令查看汇编指令"><a href="#6-4、通过javap-c-xxxx-class-命令查看汇编指令" class="headerlink" title="6.4、通过javap -c [xxxx.class]命令查看汇编指令"></a>6.4、通过javap -c [xxxx.class]命令查看汇编指令</h2><p><a href="https://oscimg.oschina.net/oscnet/up-1bcee94d08fc8fb733825e53c804b8ffb57.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-1bcee94d08fc8fb733825e53c804b8ffb57.png" class="lazyload"></a></p>
<h2 id="6-5-this锁"><a href="#6-5-this锁" class="headerlink" title="6.5 this锁"></a>6.5 this锁</h2><p>含义：指在方法上面加上synchronized 关键字</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 17:56</span><br><span class="line"> */</span><br><span class="line">public class ThisLockDemo {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        ThisLock thisLock = new ThisLock();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(() -> {</span><br><span class="line">           thisLock.m1();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        Thread thread2 = new Thread(() -> {</span><br><span class="line">            thisLock.m2();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println("主线程结束执行");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class ThisLock{</span><br><span class="line"></span><br><span class="line">    public synchronized void m1(){</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +" m1开始执行");</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            Thread.sleep(10_000);</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() +" m1结束执行");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public synchronized void m2(){</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +" m2开始执行");</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            Thread.sleep(10_000);</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() +" m2结束执行");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>


<p>运行结果：</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-b34888626a3ec62de366651f808033aa2a3.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-b34888626a3ec62de366651f808033aa2a3.png" class="lazyload"></a></p>
<p>可以看到Thread-1 m2的执行必须要等待Thread-0 m1执行完毕后才能执行， 说明同一个类在方法上面加上synchronized关键字所使用的的锁是this锁</p>
<h2 id="6-6-class锁"><a href="#6-6-class锁" class="headerlink" title="6.6 class锁"></a>6.6 class锁</h2><p>介绍：在static方法上加synchronized关键所使用的的锁是class锁</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 18:29</span><br><span class="line"> */</span><br><span class="line">public class ClassLockDemo {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        ClassLock classLock1 = new ClassLock();</span><br><span class="line">        ClassLock classLock2 = new ClassLock();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(() -> {</span><br><span class="line">            classLock1.m1();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        Thread thread2 = new Thread(() -> {</span><br><span class="line">            classLock2.m2();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println("主线程结束执行");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ClassLock{</span><br><span class="line"></span><br><span class="line">    public static synchronized void m1(){</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +" m1开始执行");</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            Thread.sleep(10_000);</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() +" m1结束执行");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static synchronized void m2(){</span><br><span class="line">        System.out.println(Thread.currentThread().getName() +" m2开始执行");</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            Thread.sleep(10_000);</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() +" m2结束执行");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-ec0c3b735ecc412e329b50e288744a1c017.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-ec0c3b735ecc412e329b50e288744a1c017.png" class="lazyload"></a></p>
<p>可以看到Thread-1 m2的执行必须要等待Thread-0 m1执行完毕后才能执行， 说明同一个类的多个实例在static方法上面加上synchronized关键字所使用的的锁是class锁</p>
<h2 id="6-7-死锁"><a href="#6-7-死锁" class="headerlink" title="6.7 死锁"></a>6.7 死锁</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/29 18:33</span><br><span class="line"> */</span><br><span class="line">public class DieLockDemo {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        DieLock dieLock = new DieLock();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = new Thread(() ->{</span><br><span class="line">            dieLock.doSomething1();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        Thread thread2 = new Thread(() ->{</span><br><span class="line">            dieLock.doSomething2();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println("主线程执行完毕");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class DieLock{</span><br><span class="line"></span><br><span class="line">    private final Object LOCK1 = new Object();</span><br><span class="line">    private final Object LOCK2 = new Object();</span><br><span class="line"></span><br><span class="line">    public void doSomething1(){</span><br><span class="line">        synchronized (LOCK1){</span><br><span class="line">            try {</span><br><span class="line">                // 代表一个耗时操作</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + "获取到LOCK1， 等待LOCK2");</span><br><span class="line">            synchronized (LOCK2){</span><br><span class="line">                System.out.println("doSomething1");</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void doSomething2(){</span><br><span class="line">        synchronized (LOCK2){</span><br><span class="line">            try {</span><br><span class="line">                // 代表一个耗时操作</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + "获取到LOCK2, 等待LOCK1");</span><br><span class="line"></span><br><span class="line">            synchronized (LOCK1){</span><br><span class="line">                System.out.println("doSomething2");</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-d626b06c234cd44ea6235cd0646a5807953.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-d626b06c234cd44ea6235cd0646a5807953.png" class="lazyload"></a></p>
<h2 id="6-8、synchronzied锁重入"><a href="#6-8、synchronzied锁重入" class="headerlink" title="6.8、synchronzied锁重入"></a>6.8、synchronzied锁重入</h2><p>关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程获得一个对象锁，再次请求该对象锁时是可以获得该对象的锁的。表现在一个synchronized方法 / 块的内部调用本类的其他synchronized方法 / 块时，是永远可以得到锁的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/9/1 15:43</span><br><span class="line"> */</span><br><span class="line">public class SynchronizedReentrantDemo {</span><br><span class="line"></span><br><span class="line">    public synchronized void methodA(){</span><br><span class="line">        System.out.println("methodA invoked ");</span><br><span class="line"></span><br><span class="line">        this.methodB();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public synchronized void methodB(){</span><br><span class="line">        System.out.println("methodB invoked ");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        SynchronizedReentrantDemo demo = new SynchronizedReentrantDemo();</span><br><span class="line"></span><br><span class="line">        demo.methodA();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-e67bb7a8f62ad5aee7f7f5a13a115e7bebb.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-e67bb7a8f62ad5aee7f7f5a13a115e7bebb.png" class="lazyload"></a></p>
<p>可以看到在synchronized方法methodsA中调用被synchronized修饰的methodB()也是可以的，即使methodA()还没有释放this锁，这证明了synchronzied锁是可以重入的</p>
<h2 id="6-9、synchronized的原理"><a href="#6-9、synchronized的原理" class="headerlink" title="6.9、synchronized的原理"></a>6.9、synchronized的原理</h2><p>Java中synchronized的锁实现包括：偏向锁、轻量级锁、重量级锁（等待时间长）</p>
<p>1个对象的实例包括3部分：对象头、实例变量、填充数据</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-0e9fc60ad797ac4622198fb58e8edf03958.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-0e9fc60ad797ac4622198fb58e8edf03958.png" class="lazyload"></a></p>
<ul>
<li>对象头：实现synchronized的锁对象的基础</li>
<li>实例变量: 存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</li>
<li>填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。</li>
</ul>
<p>synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成，其结构说明如下表：</p>
<p>其中Mark Word在默认情况下存储着对象的HashCode、分代年龄、锁标记位等以下是32位JVM的Mark Word默认存储结构</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-9b2a8700065fefb92d4cd536579f385a77d.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-9b2a8700065fefb92d4cd536579f385a77d.png" class="lazyload"></a></p>
<p>由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如32位JVM下，除了上述列出的Mark Word默认存储结构外，还有如下可能变化的结构：</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-dc79047288acf631946f6f6141c544d4726.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-dc79047288acf631946f6f6141c544d4726.png" class="lazyload"></a></p>
<p>其中轻量级锁和偏向锁是Java 6 对 synchronized 锁进行优化后新增加的，稍后我们会简要分析。这里我们主要分析一下重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() {</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = 0; //记录个数</span><br><span class="line">    _waiters      = 0,</span><br><span class="line">    _recursions   = 0;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet</span><br><span class="line">    _WaitSetLock  = 0 ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表</span><br><span class="line">    _SpinFreq     = 0 ;</span><br><span class="line">    _SpinClock    = 0 ;</span><br><span class="line">    OwnerIsThread = 0 ;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></div>
<p>ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示<br><a href="https://uploader.shimo.im/f/keLX2CdvjYkxTCJp.png!thumbnail" target="_blank" rel="noopener" data-fancybox="group" data-caption="图片" class="fancybox"><img alt="图片" title="图片" data-src="https://uploader.shimo.im/f/keLX2CdvjYkxTCJp.png!thumbnail" class="lazyload"></a></p>
<p>由此看来，monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因(关于这点稍后还会进行分析)，ok~，有了上述知识基础后，下面我们将进一步分析synchronized在字节码层面的具体语义实现。</p>
<h2 id="6-10、synchronized底层实现原理"><a href="#6-10、synchronized底层实现原理" class="headerlink" title="6.10、synchronized底层实现原理"></a>6.10、synchronized底层实现原理</h2><p>为了分析底层原理，我们编写1个最简单的类，代码如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao</span><br><span class="line"> * @date 2019/11/30 18:41</span><br><span class="line"> */</span><br><span class="line">public class SynchronizedDemo2 {</span><br><span class="line">    public synchronized static void test1(){</span><br><span class="line">        System.out.println("test1");</span><br><span class="line">    }</span><br><span class="line">    public synchronized void test2(){</span><br><span class="line">        System.out.println("test2");</span><br><span class="line">    }</span><br><span class="line">    public void test3(){</span><br><span class="line">        synchronized (this){</span><br><span class="line">            System.out.println("test4");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h3 id="6-10-1、synchronized方法底层原理："><a href="#6-10-1、synchronized方法底层原理：" class="headerlink" title="6.10.1、synchronized方法底层原理："></a>6.10.1、synchronized方法底层原理：</h3><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。下面我们看看字节码层面如何实现：</p>
<p>通过执行javap -v SynchroizedDemo2.class会输出如下字节码指令：</p>
<p>test1()方法对应的字节码指令：</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-1519102cf94401fa287e2890d1b24487052.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-1519102cf94401fa287e2890d1b24487052.png" class="lazyload"></a></p>
<p>test2()方法对应的字节码指令：</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-839f858397a43f5dda0433571b02f1f487e.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-839f858397a43f5dda0433571b02f1f487e.png" class="lazyload"></a></p>
<p>从字节码中可以看出，synchronized修饰的方法并没有monitorenter指令和monitorexit指令，取得代之的确实是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。这便是synchronized锁在同步代码块和同步方法上实现的基本原理。同时我们还必须注意到的是在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了，Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，接下来我们将简单了解一下Java官方在JVM层面对synchronized锁的优化。</p>
<h3 id="6-10-2、synchonized代码块底层实现原理："><a href="#6-10-2、synchonized代码块底层实现原理：" class="headerlink" title="6.10.2、synchonized代码块底层实现原理："></a>6.10.2、synchonized代码块底层实现原理：</h3><p>test3()方法对应的字节码指令：</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-0598217e1334e81de8a67ca10186041caf7.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-0598217e1334e81de8a67ca10186041caf7.png" class="lazyload"></a></p>
<p><strong>JSR133的解释：</strong></p>
<blockquote>
<p>synchronized 语句需要一个对象的引用；随后会尝试在该对象的管程上执行 lock 动 作，如果 lock 动作未能成功完成，将一直等待。当 lock 动作执行成功，就会运行synchronized 语句块中的代码。一旦语句块中的代码执行结束，不管是正常还是异 常结束，都会在之前执行 lock 动作的那个管程上自动执行一个 unlock 动作。</p>
<blockquote>
<p>synchronized 方法在调用时会自动执行一个 lock 动作。在 lock 动作成功完成之前， 都不会执行方法体。如果是实例方法，锁的是调用该方法的实例（即，方法体执行 期间的 this）相关联的管程。如果是静态方法，锁的是定义该方法的类所对应的 Class 对象。一旦方法体执行结束，不管是正常还是异常结束，都会在之前执行 lock 动作的那个管程上自动执行一个 unlock 动作。</p>
</blockquote>
</blockquote>
<p>从字节码中可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</p>
<h2 id="6-11、Java虚拟机对synchronized的优化"><a href="#6-11、Java虚拟机对synchronized的优化" class="headerlink" title="6.11、Java虚拟机对synchronized的优化"></a>6.11、Java虚拟机对synchronized的优化</h2><p>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段，这里并不打算深入到每个锁的实现和转换过程更多地是阐述Java虚拟机所提供的每个锁的核心优化思想，毕竟涉及到具体过程比较繁琐，如需了解详细过程可以查阅《深入理解Java虚拟机原理》。</p>
<h3 id="6-11-1、偏向锁"><a href="#6-11-1、偏向锁" class="headerlink" title="6.11.1、偏向锁"></a>6.11.1、偏向锁</h3><p>偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</p>
<h3 id="6-11-2、轻量级锁"><a href="#6-11-2、轻量级锁" class="headerlink" title="6.11.2、轻量级锁"></a>6.11.2、轻量级锁</h3><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p>
<h3 id="6-11-3、自旋锁"><a href="#6-11-3、自旋锁" class="headerlink" title="6.11.3、自旋锁"></a>6.11.3、自旋锁</h3><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p>
<h3 id="6-11-4、锁消除"><a href="#6-11-4、锁消除" class="headerlink" title="6.11.4、锁消除"></a>6.11.4、锁消除</h3><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferRemoveSync</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1, String str2)</span> </span>{</span><br><span class="line">		<span class="comment">//StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用</span></span><br><span class="line">		<span class="comment">//因此sb属于不可能共享的资源,JVM会自动消除内部的锁</span></span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		sb.append(str1).append(str2);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		StringBufferRemoveSync rmsync = <span class="keyword">new</span> StringBufferRemoveSync();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">10000000</span>; i++) {</span><br><span class="line">			rmsync.add(<span class="string">"abc"</span>, <span class="string">"123"</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<h1 id="7、wait、notify方法"><a href="#7、wait、notify方法" class="headerlink" title="7、wait、notify方法"></a>7、wait、notify方法</h1><h2 id="7-1、含义（需仔细研读）"><a href="#7-1、含义（需仔细研读）" class="headerlink" title="7.1、含义（需仔细研读）"></a>7.1、含义（需仔细研读）</h2><ol>
<li>wait()、notify()是Object类的方法， 调用这2个方法前，执行线程必须已经获得改对象的对象锁，即<strong>只能在同步方法或同步代码块中调用wait() 或者notify()方法</strong>，如果调用这2个方法时没有获得对象锁将会抛出IllegalMonitorStateException异常</li>
<li>调用wait()方法后，当前线程立即释放已经获得的锁，并且<strong>将当前线程置入“预执行队列(WaitSet)中”， 并且在wait()所在的代码处停止执行</strong>，<strong>必须直到收到notify()方法的通知</strong>或者被中断执行当前线程才能被唤醒继续往wait()方法后面的代码执行</li>
<li><strong>notitify()方法用来通知那些等待获取该对象锁的线程， 如果有多个线程等待，则由线程规划器随机挑选出一个处于wait状态的线程B，对其发出Notify通知，使B退出等待队列，处于就绪状态，被重新唤醒的线程B会尝试获取临界区的对象锁，被唤醒线程B在真正获取到锁后就会继续执行wait()后面的代码。需要说明的是，在执行notify()方法后，并不会使当前线程A马上释放对象锁，处于wait状态的线程B也不能马上获取对象锁，要等到执行notify()方法的线程A将程序执行完，也就是退出synchronized代码块后，当前线程A才会释放对象锁，但是释放之后并不代表线程B就一定会获取到对象锁，只是说此时A、B都有机会竞争获取到对象锁</strong></li>
<li>如果notify()方法执行时，此时并没有任何线程处于wait状态，那么执行该方法相当于无效操作</li>
<li>notify()与notifyAll()的区别是：notify()方法每次调用时都只是从所有处于wait状态的线程中<strong>随机选择一个</strong>线程进入就绪状态，而notifyAll()则是使所有处于wait状态的线程<strong>全部退出</strong>等待队列，<strong>全部进入</strong>就绪状态，此处唤醒不等于所有线程都获得该对象的monitor，此时优先级最高的那个线程优先执行(获得对象锁)，但也有可能是随机执行(获得对象锁)，这要取决于jvm实现</li>
</ol>
<h2 id="7-2、生产者消费者模式"><a href="#7-2、生产者消费者模式" class="headerlink" title="7.2、生产者消费者模式"></a>7.2、生产者消费者模式</h2><h3 id="7-2-1、-版本1产生假死-全部进入等待wait状态"><a href="#7-2-1、-版本1产生假死-全部进入等待wait状态" class="headerlink" title="7.2.1、 版本1产生假死(全部进入等待wait状态)"></a>7.2.1、 版本1产生假死(全部进入等待wait状态)</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/6/30 7:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumerVersion1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isProduced;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ProducerAndConsumerVersion1 version1 = <span class="keyword">new</span> ProducerAndConsumerVersion1();</span><br><span class="line">        Stream.of(<span class="string">"P1"</span>, <span class="string">"P2"</span>, <span class="string">"P3"</span>, <span class="string">"P4"</span>).forEach((item) ->{</span><br><span class="line">            <span class="keyword">new</span> Thread(() ->{</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                    version1.produce();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }, item).start();</span><br><span class="line">        });</span><br><span class="line">        Stream.of(<span class="string">"C1"</span>).forEach(item ->{</span><br><span class="line">            <span class="keyword">new</span> Thread(() ->{</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                    version1.consumer();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }, item).start();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"主线程执行结束"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK){</span><br><span class="line">            <span class="keyword">if</span> (isProduced){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    System.out.println(<span class="string">"["</span> + Thread.currentThread().getName() +<span class="string">"] produce wait"</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"["</span> + Thread.currentThread().getName() +<span class="string">"] produce wait after"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                num++;</span><br><span class="line">                System.out.println(<span class="string">"["</span> + Thread.currentThread().getName() + <span class="string">"] P ==>"</span>  + num);</span><br><span class="line">                isProduced=<span class="keyword">true</span>;</span><br><span class="line">                LOCK.notify();</span><br><span class="line">                System.out.println(<span class="string">"["</span> + Thread.currentThread().getName() + <span class="string">"] notify after"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isProduced){</span><br><span class="line">               </span><br><span class="line">                System.out.println(<span class="string">"["</span> + Thread.currentThread().getName() + <span class="string">"] C ==>"</span> + num);</span><br><span class="line">                isProduced = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                LOCK.notify();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"["</span> + Thread.currentThread().getName() + <span class="string">"] notify after"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    System.out.println(<span class="string">"["</span> + Thread.currentThread().getName() +<span class="string">"] consumer wait"</span>);</span><br><span class="line">                    LOCK.wait();</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"["</span> + Thread.currentThread().getName() +<span class="string">"] consumer wait after"</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-61ffa8e9956cd9e5d35d8924f1e114cb606.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-61ffa8e9956cd9e5d35d8924f1e114cb606.png" class="lazyload"></a></p>
<p>以上代码执行永远不会结束，所有线程最终都变为wait状态（没有发生死锁）</p>
<h3 id="7-2-2、多消费者、多生产者正确版本"><a href="#7-2-2、多消费者、多生产者正确版本" class="headerlink" title="7.2.2、多消费者、多生产者正确版本"></a>7.2.2、多消费者、多生产者正确版本</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/30 7:44</span><br><span class="line"> */</span><br><span class="line">public class ProducerAndConsumerVersion2 {</span><br><span class="line"></span><br><span class="line">    private final Object LOCK = new Object();</span><br><span class="line"></span><br><span class="line">    private boolean isProduced;</span><br><span class="line"></span><br><span class="line">    private int num = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        ProducerAndConsumerVersion2 version1 = new ProducerAndConsumerVersion2();</span><br><span class="line">        Stream.of("P1", "P2", "P3", "P4").forEach((item) ->{</span><br><span class="line">            new Thread(() ->{</span><br><span class="line">                while (true) {</span><br><span class="line">                    version1.produce();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }, item).start();</span><br><span class="line">        });</span><br><span class="line">        Stream.of("C1", "C2", "C3", "C4").forEach(item ->{</span><br><span class="line">            new Thread(() ->{</span><br><span class="line">                while (true) {</span><br><span class="line">                    version1.consumer();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }, item).start();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println("主线程执行结束");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void produce(){</span><br><span class="line">        synchronized (LOCK){</span><br><span class="line">            while (isProduced){</span><br><span class="line">                try {</span><br><span class="line">                    System.out.println("[" + Thread.currentThread().getName() +"] produce wait");</span><br><span class="line">                    LOCK.wait();</span><br><span class="line"></span><br><span class="line">                    System.out.println("[" + Thread.currentThread().getName() +"] produce wait after");</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            num++;</span><br><span class="line">            System.out.println("[" + Thread.currentThread().getName() + "] P ==>"  + num);</span><br><span class="line">            isProduced=true;</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line">            System.out.println("[" + Thread.currentThread().getName() + "] notify after");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void consumer(){</span><br><span class="line">        synchronized (LOCK){</span><br><span class="line">            while (!isProduced){</span><br><span class="line">                try {</span><br><span class="line">                    System.out.println("[" + Thread.currentThread().getName() +"] consumer wait");</span><br><span class="line">                    LOCK.wait();</span><br><span class="line"></span><br><span class="line">                    System.out.println("[" + Thread.currentThread().getName() +"] consumer wait after");</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            System.out.println("[" + Thread.currentThread().getName() + "] C ==>" + num);</span><br><span class="line">            isProduced = false;</span><br><span class="line"></span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line"></span><br><span class="line">            System.out.println("[" + Thread.currentThread().getName() + "] notify after");</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h3 id="7-2-3、多生产者、多消费者，-阻塞-错误版本，浪费执行机会"><a href="#7-2-3、多生产者、多消费者，-阻塞-错误版本，浪费执行机会" class="headerlink" title="7.2.3、多生产者、多消费者， 阻塞, 错误版本，浪费执行机会"></a>7.2.3、多生产者、多消费者， 阻塞, 错误版本，浪费执行机会</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/30 7:44</span><br><span class="line"> */</span><br><span class="line">public class ProducerAndConsumerVersion3 {</span><br><span class="line"></span><br><span class="line">    private final Object LOCK = new Object();</span><br><span class="line"></span><br><span class="line">    private boolean isProduced;</span><br><span class="line"></span><br><span class="line">    private int num = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Container container = new Container(10);</span><br><span class="line"></span><br><span class="line">        Producer producer = new Producer(container);</span><br><span class="line">        Consumer consumer = new Consumer(container);</span><br><span class="line">        Stream.of("P1", "P2", "P3", "P4").forEach((item) ->{</span><br><span class="line">            new Thread(() ->{</span><br><span class="line">                while (true) {</span><br><span class="line">                    producer.produce();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }, item).start();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        Stream.of("C1", "C2", "C3", "C4").forEach(item ->{</span><br><span class="line">            new Thread(() ->{</span><br><span class="line">                while (true) {</span><br><span class="line">                    consumer.consume();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }, item).start();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println("主线程执行结束");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Producer{</span><br><span class="line"></span><br><span class="line">    private Container container;</span><br><span class="line">    private int i = 0;</span><br><span class="line"></span><br><span class="line">    public Producer(Container container){</span><br><span class="line">        this.container = container;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void produce(){</span><br><span class="line">        while (true){</span><br><span class="line">            synchronized (container){</span><br><span class="line">                if (container.isOverflow()){</span><br><span class="line">                    try {</span><br><span class="line">                        container.wait();</span><br><span class="line">                    } catch (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                else{</span><br><span class="line">                    container.push(++i);</span><br><span class="line">                    System.out.println("[" + Thread.currentThread().getName() +"] produce " + i);</span><br><span class="line"></span><br><span class="line">                    container.notifyAll();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Consumer{</span><br><span class="line">    private Container container;</span><br><span class="line"></span><br><span class="line">    public Consumer(Container container){</span><br><span class="line">        this.container = container;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void consume(){</span><br><span class="line">        while (true){</span><br><span class="line">            synchronized (container){</span><br><span class="line">                if (container.isEmpty()){</span><br><span class="line">                    try {</span><br><span class="line">                        container.wait();</span><br><span class="line">                    } catch (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                // 这里其实是有问题的， 假设A、B线程都执行到container.wait();处于wait状态， 此时生产者执行了container.notifyAll();</span><br><span class="line">              // A线程获得了对象锁， 从container.wait();处往后执行，但是由于这里用的是if..else结构，</span><br><span class="line">              // 所以会导致A线程刚被唤醒获得了对象锁，又什么都不做，马上又释放了对象锁，假设A线程的CPU时间片刚好用完又让B获得了对象锁，</span><br><span class="line">            // 可能出现后续都一直是B获得CPU实现片获得对象锁，而A明明之前获得过一次对象锁却啥事也不干，白白浪费了一次执行机会</span><br><span class="line"></span><br><span class="line">                else {</span><br><span class="line">                    Object value = container.pop();</span><br><span class="line">                    System.out.println("[" + Thread.currentThread().getName() +"]  consume " + value);</span><br><span class="line"></span><br><span class="line">                    container.notifyAll();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Container{</span><br><span class="line"></span><br><span class="line">    private LinkedList<object> storage;<br><span class="line"></span><br><span class="line">    private int capticy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Container(int capticy){</span><br><span class="line">        this.storage = new LinkedList<>();</span><br><span class="line"></span><br><span class="line">        this.capticy = capticy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void push(Object obj){</span><br><span class="line">        this.storage.addLast(obj);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Object pop(){</span><br><span class="line">        return this.storage.removeFirst();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public int size(){</span><br><span class="line">        return this.storage.size();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public boolean isOverflow(){</span><br><span class="line">        return size() >= capticy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty(){</span><br><span class="line">        return this.storage.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></object></span></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-7042a92981b617b191f6ce2711936b2b0a8.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-7042a92981b617b191f6ce2711936b2b0a8.png" class="lazyload"></a></p>
<h3 id="7-2-4、完全正确版本"><a href="#7-2-4、完全正确版本" class="headerlink" title="7.2.4、完全正确版本"></a>7.2.4、完全正确版本</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">package 生产者消费者模式;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/6/30 7:44</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings("ALL")</span><br><span class="line">public class ProducerAndConsumerVersion4 {</span><br><span class="line"></span><br><span class="line">    private final Object LOCK = new Object();</span><br><span class="line"></span><br><span class="line">    private boolean isProduced;</span><br><span class="line"></span><br><span class="line">    private int num = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Container2 container = new Container2(10);</span><br><span class="line"></span><br><span class="line">        Producer2 producer = new Producer2(container);</span><br><span class="line">        Consumer2 consumer = new Consumer2(container);</span><br><span class="line">        Stream.of("P1", "P2", "P3", "P4").forEach((item) -> {</span><br><span class="line">            new Thread(() ->{</span><br><span class="line">                while (true) {</span><br><span class="line">                    producer.produce();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }, item).start();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        Stream.of("C1", "C2", "C3", "C4").forEach(item ->{</span><br><span class="line">            new Thread(() -> {</span><br><span class="line">                while (true) {</span><br><span class="line">                    consumer.consume();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }, item).start();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println("主线程执行结束");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@SuppressWarnings("ALL")</span><br><span class="line">class Producer2 {</span><br><span class="line"></span><br><span class="line">    private Container2 container;</span><br><span class="line">    private int i = 0;</span><br><span class="line"></span><br><span class="line">    public Producer2(Container2 container){</span><br><span class="line">        this.container = container;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void produce(){</span><br><span class="line">        </span><br><span class="line">        synchronized (container){</span><br><span class="line">            // 这里的while不能换成if</span><br><span class="line">            // 假设container现在是满的，C线程消费了一个个，然后调用container.notifyAll();通知A、B线程唤醒</span><br><span class="line">            // A、B线程从container.wait();这一行代码处唤醒后处于就绪状态， A获得锁， 往container.wait();后面执行，</span><br><span class="line">            // A执行 container.push(++i); 执行完后container满了，A执行完synchronized代码块释放锁， 紧接着B获取到锁一样从</span><br><span class="line">            // container.wait();往后执行，假如这里while换成if, 那么B就会又执行container.push(++i);</span><br><span class="line">            // 导致容器满了仍然向container push数据，这样就出现错误数据了</span><br><span class="line">            while (container.isOverflow()) {</span><br><span class="line">                try {</span><br><span class="line">                    container.wait();</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            container.push(++i);</span><br><span class="line">            System.out.println("[" + Thread.currentThread().getName() +"] produce " + i);</span><br><span class="line"></span><br><span class="line">            container.notifyAll();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@SuppressWarnings("ALL")</span><br><span class="line">class Consumer2{</span><br><span class="line">    private Container2 container;</span><br><span class="line"></span><br><span class="line">    public Consumer2(Container2 container){</span><br><span class="line">        this.container = container;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void consume(){</span><br><span class="line">        synchronized (container){</span><br><span class="line">            // 这里的while不能换成if</span><br><span class="line">            </span><br><span class="line">            // 假设A、B线程都执行到container.wait();这行代码处，A、B处于wait状态， 此时生产者执行了container.notifyAll();</span><br><span class="line">            // 然后A线程获得了对象锁， 从container.wait();处往后执行，A调用container.pop()后container变为空的</span><br><span class="line">            // 假设这里while换成if, 那么会出现紧接着B获得了对象锁，一样地从从container.wait();处往后执行，但是container已经是空的了</span><br><span class="line">            // 任然调用container.pop()就会报出ArrayIndeOutOfBoundExeption了</span><br><span class="line">            while (container.isEmpty()){</span><br><span class="line">                try {</span><br><span class="line">                    container.wait();</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line">            Object value = container.pop();</span><br><span class="line">            System.out.println("[" + Thread.currentThread().getName() +"]  consume " + value);</span><br><span class="line"></span><br><span class="line">            container.notifyAll();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Container2{</span><br><span class="line"></span><br><span class="line">    private LinkedList<object> storage;<br><span class="line"></span><br><span class="line">    private int capticy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Container2(int capticy){</span><br><span class="line">        this.storage = new LinkedList<>();</span><br><span class="line"></span><br><span class="line">        this.capticy = capticy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void push(Object obj){</span><br><span class="line">        this.storage.addLast(obj);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Object pop(){</span><br><span class="line">        return this.storage.removeFirst();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public int size(){</span><br><span class="line">        return this.storage.size();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public boolean isOverflow(){</span><br><span class="line">        return size() >= capticy;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty(){</span><br><span class="line">        return this.storage.isEmpty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></object></span></pre></td></tr></tbody></table></figure></div>

<h1 id="8-、捕获线程运行期间的异常"><a href="#8-、捕获线程运行期间的异常" class="headerlink" title="8 、捕获线程运行期间的异常"></a>8 、捕获线程运行期间的异常</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/7/1 22:03</span><br><span class="line"> */</span><br><span class="line">public class ExceptionCaught {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line"></span><br><span class="line">        Thread mythread = new Thread(() ->{</span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, "mythread");</span><br><span class="line"></span><br><span class="line">        // 捕获异常</span><br><span class="line">        mythread.setUncaughtExceptionHandler((thread, throwable) ->{</span><br><span class="line">            System.out.println(thread.getName());</span><br><span class="line"></span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        mythread.start();</span><br><span class="line"></span><br><span class="line">        mythread.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-6361eaa7ef6389561d072da8d0ccbf10187.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-6361eaa7ef6389561d072da8d0ccbf10187.png" class="lazyload"></a></p>
<h1 id="9、ThreadGroup"><a href="#9、ThreadGroup" class="headerlink" title="9、ThreadGroup"></a>9、ThreadGroup</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package chapter2;</span><br><span class="line"></span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/7/1 20:27</span><br><span class="line"> */</span><br><span class="line">public class ThreadGroupDemo {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        // main方法也是一个线程， 其名称为main</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        // main线程的线程组的名称是main</span><br><span class="line">        System.out.println(Thread.currentThread().getThreadGroup().getName());</span><br><span class="line"></span><br><span class="line">        // 创建线程组tg1</span><br><span class="line">        ThreadGroup tg1 = new ThreadGroup("tg1");</span><br><span class="line"></span><br><span class="line">        new Thread(tg1, "t1"){</span><br><span class="line">            @Override</span><br><span class="line">            public void run() {</span><br><span class="line">                    try {</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                        //获取当前线程组的名称</span><br><span class="line">                        System.out.println(this.getThreadGroup().getName());</span><br><span class="line">                        //获取当前线程组的父线程组</span><br><span class="line">                        System.out.println(this.getThreadGroup().getParent());</span><br><span class="line">                        //获取当前线程组的父线程组的名称</span><br><span class="line">                        System.out.println(this.getThreadGroup().getParent().getName());</span><br><span class="line">                        //评估当前线程组的父线程组及子级的线程数量</span><br><span class="line">                        System.out.println(this.getThreadGroup().getParent().activeCount());</span><br><span class="line">                        System.out.println("--------------");</span><br><span class="line">                    } catch (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">        // 创建线程组tg2</span><br><span class="line">        ThreadGroup tg2 = new ThreadGroup("tg2");</span><br><span class="line">        tg2.setDaemon(true);</span><br><span class="line">        Stream.of("T1", "T2", "T3").forEach(name ->{</span><br><span class="line">            new Thread(tg2, name){</span><br><span class="line">                @Override</span><br><span class="line">                public void run() {</span><br><span class="line">                    System.out.println(this.getThreadGroup().getName());</span><br><span class="line">                    System.out.println(tg1.getParent());</span><br><span class="line">                    System.out.println(this.getThreadGroup().getParent().getName());</span><br><span class="line">                    // 评估父线程组下的线程数量</span><br><span class="line">                    System.out.println(this.getThreadGroup().getParent().activeCount());</span><br><span class="line"></span><br><span class="line">                    Thread[] threads = new Thread[tg1.activeCount()];</span><br><span class="line">                    this.getThreadGroup().enumerate(threads);</span><br><span class="line">                    Stream.of(threads).forEach(System.out::println);</span><br><span class="line">                    System.out.println("***************");</span><br><span class="line"></span><br><span class="line">                    // 测试某个线程是parentOf(group)参数中group的父线程（直接或间接）</span><br><span class="line">                    System.out.println("parentOf: " + this.getThreadGroup().getParent().parentOf(this.getThreadGroup()));</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +" isDaemon:" + this.isDaemon());</span><br><span class="line"></span><br><span class="line">                    try {</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                    } catch (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        // 打断整个线程组下的所有线程</span><br><span class="line">        tg2.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-558774719105228a7681fd0f52957613efb.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-558774719105228a7681fd0f52957613efb.png" class="lazyload"></a></p>
<h1 id="10、单例设计模式"><a href="#10、单例设计模式" class="headerlink" title="10、单例设计模式"></a>10、单例设计模式</h1><h2 id="version1-（不好）"><a href="#version1-（不好）" class="headerlink" title="version1 （不好）"></a>version1 （不好）</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> package chapter3.singleton;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 问题是不能懒加载， 在类加载的时候就会初始化instance</span><br><span class="line"> *</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/7/4 19:47</span><br><span class="line"> */</span><br><span class="line">public class SingletonVersion1 {</span><br><span class="line"></span><br><span class="line">    private static final SingletonVersion1 instance = new SingletonVersion1();</span><br><span class="line"></span><br><span class="line">    public static SingletonVersion1 getInstance(){</span><br><span class="line">        return instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>


<h2 id="version2-错误"><a href="#version2-错误" class="headerlink" title="version2 (错误)"></a>version2 (错误)</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package chapter3.singleton;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/7/4 19:47</span><br><span class="line"> */</span><br><span class="line">public class SingletonVersion2 {</span><br><span class="line">    private static SingletonVersion2 instance ;</span><br><span class="line"></span><br><span class="line">    private SingletonVersion2(){</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 多线程并发访问时可能同时进入if代码里，造成多次实例化</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static SingletonVersion2 getInstance(){</span><br><span class="line">        if (instance == null){</span><br><span class="line">           instance = new SingletonVersion2();</span><br><span class="line">        }</span><br><span class="line">        return instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="version3-不好"><a href="#version3-不好" class="headerlink" title="version3 (不好)"></a>version3 (不好)</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package chapter3.singleton;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/7/4 19:47</span><br><span class="line"> */</span><br><span class="line">public class SingletonVersion3 {</span><br><span class="line">    private static SingletonVersion3 instance ;</span><br><span class="line"></span><br><span class="line">    private SingletonVersion3(){</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 会有性能问题， 实例化后每次读取都要同步</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static synchronized SingletonVersion3 getInstance(){</span><br><span class="line">        if (instance == null){</span><br><span class="line">           instance = new SingletonVersion3();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="version4-不好"><a href="#version4-不好" class="headerlink" title="version4 (不好)"></a>version4 (不好)</h2><p>jvm指令重排序可能NullPointerException</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package chapter3.singleton;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/7/4 19:47</span><br><span class="line"> */</span><br><span class="line">public class SingletonVersion4 {</span><br><span class="line">    private static SingletonVersion4 instance ;</span><br><span class="line"></span><br><span class="line">    private static Object LOCK = new Object();</span><br><span class="line"></span><br><span class="line">    private boolean init;</span><br><span class="line"></span><br><span class="line">    private SomeObject someObject = null;</span><br><span class="line"></span><br><span class="line">    private SingletonVersion4(){</span><br><span class="line">        init = true;</span><br><span class="line">//        try {</span><br><span class="line">//            Thread.sleep(3000);</span><br><span class="line">//        } catch (InterruptedException e) {</span><br><span class="line">//            e.printStackTrace();</span><br><span class="line">//        }</span><br><span class="line">        someObject = new SomeObject();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 貌似没问题，但是极端情况会有NPL空指针异常问题， 比如这个类里有一些变量， 这些变量在构造方法里初始化</span><br><span class="line">     * 当有多个线程调用getInstance时， 第一个线程访问时instance为null会进行实例化， 这是会在堆内存分配内存空间</span><br><span class="line">     * 分配完内存空间，但是构造方法并没有执行完， 此时第二个线程访问时instance不为null返回Instance实例，直接调用里面的方法</span><br><span class="line">     * new SingletonVersion4()</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static SingletonVersion4 getInstance(){</span><br><span class="line">        if (instance == null){</span><br><span class="line">            synchronized (LOCK){</span><br><span class="line">                if (instance == null){</span><br><span class="line">                    instance = new SingletonVersion4();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void print(){</span><br><span class="line">        this.someObject.doSomething();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Thread t1 = new Thread(() ->{</span><br><span class="line">            SingletonVersion4.getInstance();</span><br><span class="line">        }, "t1");</span><br><span class="line"></span><br><span class="line">        Thread t2 = new Thread(() ->{</span><br><span class="line">            SingletonVersion4.getInstance().print();</span><br><span class="line">        }, "t2");</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class SomeObject{</span><br><span class="line"></span><br><span class="line">    public void doSomething(){</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + " doSomething...");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-2c7d4a93a462c085f91b01792dbd97171a4.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-2c7d4a93a462c085f91b01792dbd97171a4.png" class="lazyload"></a></p>
<h4 id="version5-正确、推荐"><a href="#version5-正确、推荐" class="headerlink" title="version5 (正确、推荐)"></a>version5 (正确、推荐)</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package chapter3.singleton;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/7/4 19:47</span><br><span class="line"> */</span><br><span class="line">public class SingletonVersion5 {</span><br><span class="line"></span><br><span class="line">    private SingletonVersion5(){</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private static class Singleton{</span><br><span class="line">        private static final SingletonVersion5 INSTANCE = new SingletonVersion5();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 貌似没问题，但是极端情况会有NPL空指针异常问题， 比如这个类里有一些变量， 这些变量在构造方法里初始化</span><br><span class="line">     * 当有多个线程调用getInstance时， 第一个线程访问时instance为null会进行实例化， 这是会在堆内存分配内存空间</span><br><span class="line">     * 分配完内存空间，但是构造方法并没有执行完， 此时第二个线程访问时instance不为null返回Instance实例，直接调用里面的方法</span><br><span class="line">     * new SingletonVersion4()</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static SingletonVersion5 getInstance(){</span><br><span class="line">        return Singleton.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h4 id="version-6-（正确）"><a href="#version-6-（正确）" class="headerlink" title="version 6 （正确）"></a>version 6 （正确）</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package chapter3.singleton;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/7/4 19:47</span><br><span class="line"> */</span><br><span class="line">public class SingletonVersion6 {</span><br><span class="line"></span><br><span class="line">    private SingletonVersion6(){</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    enum Singleton{</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        private SingletonVersion6 singletonVersion6 = new SingletonVersion6();</span><br><span class="line"></span><br><span class="line">        public SingletonVersion6 getInstance(){</span><br><span class="line">            return singletonVersion6;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    public static SingletonVersion6 getInstance(){</span><br><span class="line">        return Singleton.INSTANCE.getInstance();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>


<h1 id="11、volatile关键字"><a href="#11、volatile关键字" class="headerlink" title="11、volatile关键字"></a>11、volatile关键字</h1><h2 id="11-1-高并发的三个特性"><a href="#11-1-高并发的三个特性" class="headerlink" title="11.1 高并发的三个特性"></a>11.1 高并发的三个特性</h2><ol>
<li><strong>原子性</strong></li>
</ol>
<p>例如 i = 9;  在16位计算机中 可能是16 16位分2次赋值的，比如低16位赋值成功、高16位赋值失败。</p>
<p>在一个或多个操作中，要么全部成功，要么全部失败，不能有中间状态。</p>
<p>a = 1;         保证原子性</p>
<p>a++;           <strong>非原子性</strong>，执行步骤：1：读取a; 2: 对a加1；  3：将结果赋值给a</p>
<p>a = 1+2      保证原子性， 编译期会确定值</p>
<p>a = a+1     ** 非原子性**，执行步骤：1：读取a; 2: 对a加1；  3：将结果赋值给a</p>
<p><strong>证明 ++value 操作不是原子性的</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package volatileDemo;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/7/8 22:01</span><br><span class="line"> */</span><br><span class="line">public class AtomDemo {</span><br><span class="line"></span><br><span class="line">    private static int initValue = 1;</span><br><span class="line"></span><br><span class="line">    private static int maxValue = 500;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 证明++initValue操作不是原子性的，</span><br><span class="line">     *</span><br><span class="line">     * 假设如下2种情况：</span><br><span class="line">     * 1、如果 ++initValue操作是原子性的， 那么输出一定不会有重复的</span><br><span class="line">     * 2、如果 ++initValue操作不熟原子性的，而是拆分成1、读取initValue; 2其他操作，那么可能多个线程读取到一样的initValue</span><br><span class="line">     *</span><br><span class="line">     * 那么可能出现如下情况：</span><br><span class="line">     * t1  -> 读取 initValue值为10， cpu执行权被切换到t2</span><br><span class="line">     * t2  -> 读取 initValue值为10,</span><br><span class="line">     * t2  -> 11 = 10 +1</span><br><span class="line">     * t2  -> initValue = 11</span><br><span class="line">     * t2  -> System.out.printf("t2 执行后结果 [%d] \n", 11);</span><br><span class="line">     * t1  -> 11 = 10 +1</span><br><span class="line">     * t1  -> initValue = 11</span><br><span class="line">     * t1  -> System.out.printf("t1 执行后结果 [%d] \n", 11);</span><br><span class="line">     *</span><br><span class="line">     * @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        new Thread(() ->{</span><br><span class="line">            while (initValue < maxValue){</span><br><span class="line">                System.out.printf("t1 执行后结果 [%d] \n", ++initValue);</span><br><span class="line">                try {</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() ->{</span><br><span class="line">            while (initValue < maxValue){</span><br><span class="line">                System.out.printf("t2 执行后结果 [%d] \n", ++initValue);</span><br><span class="line">                try {</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>


<p><a href="https://oscimg.oschina.net/oscnet/up-645cefb328584fe0e3435ef04978f461e22.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-645cefb328584fe0e3435ef04978f461e22.png" class="lazyload"></a></p>
<ol start="2">
<li><strong>可见性</strong></li>
</ol>
<p><strong>volatile关键字会保证多线程下的内存可见性及指令执行的有序性</strong></p>
<p><a href="https://www.cnblogs.com/yanlong300/p/8986041.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanlong300/p/8986041.html</a></p>
<p>例子：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package volatileDemo;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/7/8 21:25</span><br><span class="line"> */</span><br><span class="line">public class VolatileDemo {</span><br><span class="line"></span><br><span class="line">    private static int  initValue = 1;</span><br><span class="line"></span><br><span class="line">    private static int MAX_VALUE = 50;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        new Thread(() ->{</span><br><span class="line">            int localValue = initValue;</span><br><span class="line">            while (localValue < MAX_VALUE){</span><br><span class="line">//                System.out.printf("t1线程读取到initValue的值为 [%d] localValue：[%d]\n", initValue, localValue);</span><br><span class="line">                if (localValue != initValue){</span><br><span class="line">                    localValue = initValue;</span><br><span class="line">                    System.out.printf("initValue的值已被更新为 [%d]\n", initValue);</span><br><span class="line">                }</span><br><span class="line">//                else{</span><br><span class="line">//                    System.out.printf("t1线程读取到initValue的值为 [%d] localValue：[%d]\n", initValue, localValue);</span><br><span class="line">//                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            System.out.println("t1线程结束执行");</span><br><span class="line">        }, "t1").start();</span><br><span class="line"></span><br><span class="line">        new Thread(() ->{</span><br><span class="line">            int localValue = initValue;</span><br><span class="line">            while (initValue < MAX_VALUE){</span><br><span class="line">                localValue++;</span><br><span class="line">                initValue = localValue;</span><br><span class="line">                System.out.printf("更新initValue的值为 [%d]\n", initValue);</span><br><span class="line"></span><br><span class="line">                try {</span><br><span class="line">                    Thread.sleep(500);</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            System.out.println("t2线程结束执行");</span><br><span class="line">        }, "t2").start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>


<p><a href="https://oscimg.oschina.net/oscnet/up-ff3e395f5ddb81be58c8535fcdc5faa180b.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-ff3e395f5ddb81be58c8535fcdc5faa180b.png" class="lazyload"></a></p>
<p>当private static volatile int   *initValue *= 1; 这句代码加上volatile 关键字就是正确的结果了</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-c69faeca7d8a784c112d97a38928b55b5bb.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-c69faeca7d8a784c112d97a38928b55b5bb.png" class="lazyload"></a></p>
<ol start="3">
<li><strong>有序性</strong><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">value = 3；</span><br><span class="line"></span><br><span class="line">void exeToCPUA(){</span><br><span class="line">  value = 10;   # 可能发生重排序 value的赋值发生在isFinsh之后</span><br><span class="line">  isFinsh = true;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void exeToCPUB(){</span><br><span class="line">  if(isFinsh){</span><br><span class="line">    //value一定等于10？！</span><br><span class="line">    assert value == 10;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
试想一下开始执行时，CPU A保存着finished在E(独享)状态，而value并没有保存在它的缓存中。（例如，Invalid）。在这种情况下，value会比finished更迟地抛弃存储缓存。完全有可能CPU B读取finished的值为true，而value的值不等于10。</li>
</ol>
<p>**    即isFinsh的赋值在value赋值之前。**</p>
<p>这种在可识别的行为中发生的变化称为重排序（reordings）。注意，这不意味着你的指令的位置被恶意（或者好意）地更改。</p>
<p>它只是意味着其他的CPU会读到跟程序中写入的顺序不一样的结果。</p>
<p>为什么会有指令的重排序？</p>
<p>答案：因为为了使缓存能够得到更加合理地利用。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a=1</span><br><span class="line">int b=2</span><br></pre></td></tr></tbody></table></figure></div>
<h2 id="省略一万行代码…"><a href="#省略一万行代码…" class="headerlink" title="省略一万行代码…"></a>省略一万行代码…</h2><p>int c=a+b</p>
<p>最后一句放第三行就能让缓存更合理, 原因：cpu将a=1读入CPU高速缓存，然后将b=2读入高速缓存，由于CPU高速缓存的容量很小，所以当执行后面的一万行代码时CPU高速缓存满了，那么就会把a=1、b=2这2个缓存行覆盖掉，当真正执行int c= a+ b时由于CPU高速缓存里面没有数据那么CPU就要重新从主存读取数据然后计算，这样就出现了不必须的重复读取主存的操作，浪费CPU，通过重指令排序让int c=a+b放到第三行则可以缓存能够立即得到利用，将c=a+b的结果计算后可以立即回写主内存，避免后续a=1、b=2的缓存行被其他指令的缓存行覆盖</p>
<p>11.2、volatile的内存语义</p>
<h1 id="12、比较并交换（CAS"><a href="#12、比较并交换（CAS" class="headerlink" title="12、比较并交换（CAS)"></a>12、比较并交换（CAS)</h1><h2 id="12-1、使用CAS与使用锁相比的好处"><a href="#12-1、使用CAS与使用锁相比的好处" class="headerlink" title="12.1、使用CAS与使用锁相比的好处"></a>12.1、使用CAS与使用锁相比的好处</h2><p>与锁相比，使用比较并交换（CAS）会使程序看起来更复杂，但由于其非阻塞性，它对死锁问题天生免疫，并且线程间的影响也远远比基于锁的方式小的多。更为重要的是，<strong>使用无锁的方式</strong>完全没有锁竞争带来的开销，也没有线程间频繁调度调来的开销，因此它比基于锁的方式拥有更优越的性能。</p>
<h2 id="12-2、CAS原理"><a href="#12-2、CAS原理" class="headerlink" title="12.2、CAS原理"></a>12.2、CAS原理</h2><p>CAS算法的过程是：它包含3个参数CAS(realValue,  expectValue, newValue), 其中realValue表示要更新的变量，expectValue表示预期值，newValue表示新值。仅当realValue等与expectValue值时，才将realValue的值变更为newValue，如果realValue与expectValue不相等，说明有其他线程已经更新做了更新，则当前线程什么也不做，最后CAS返回当前realValue的真实值。CAS是抱着乐观的态度去进行的，它总是认为自己可以完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然允许失败的线程放弃操作。</p>
<p>简单的说，CAS需要你额外给出一个预期值，也就是你认为现在这个变量应该是什么样子的。如果变量不是你想象的那样，则说明已经被别人修改过了。你就重新读取，再次尝试修改就好了。</p>
<p><strong>在硬件层面大部分的处理器都已支持原子化的CAS指令</strong>。在JDK5后，虚拟机便可以使用这个指令来进行原子化操作。</p>
<h2 id="13-3、CAS实现计数器"><a href="#13-3、CAS实现计数器" class="headerlink" title="13.3、CAS实现计数器"></a>13.3、CAS实现计数器</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 自旋锁计数;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span><<span class="title">psvm</span>> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程安全方式计数， 内部的value子段声明为 private volatile int value;所以保证了内存可见性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">private</span> AtomicInteger atomic = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程不安全，非原子性操作计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>{</span><br><span class="line">		i++;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">			<span class="comment">// 1、多核处理器可能会同时运行到这行代码，单核处理器由于时间片分配算法T1执行到这行代码后CPU执行权被T2获取了， 线程T1、T2均通过get()方法返回0</span></span><br><span class="line">			<span class="comment">// 2、假如T1先执行atomic.compareAndSet(currentValue, ++currentValue)这行代码，</span></span><br><span class="line">			<span class="comment">//    由于currentValue和atomic的值一致，cas操作成功，atomic变成1，退出循环,</span></span><br><span class="line">			<span class="comment">// 3、然后T2继续执行atomic.compareAndSet(currentValue, ++currentValue);</span></span><br><span class="line">			<span class="comment">//    这行代码会发现atomic内部维护的value值1已经与currentValue的值0不相等，不会进行设置值操作</span></span><br><span class="line">			<span class="comment">//    T2继续下次循环, 又执行atomic.get();获取到的currentValue为1， 再次执行compareAndSet时，</span></span><br><span class="line">			<span class="comment">//    atomic为1和currentValue为1相等，成功进行cas操作，然后退出循环</span></span><br><span class="line">			<span class="keyword">int</span> currentValue = atomic.get();</span><br><span class="line">			<span class="keyword">boolean</span> success = atomic.compareAndSet(currentValue, ++currentValue);</span><br><span class="line">			<span class="keyword">if</span> (success){</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line">		List<thread> threadList = <span class="keyword">new</span> ArrayList<>(<span class="number">500</span>);</thread></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < <span class="number">500</span>; j++){</span><br><span class="line">			Thread thread = <span class="keyword">new</span> Thread(() ->{</span><br><span class="line">				<span class="keyword">try</span> {</span><br><span class="line">					Thread.sleep(<span class="number">100</span>);</span><br><span class="line">				} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				}</span><br><span class="line">				counter.count();</span><br><span class="line"></span><br><span class="line">				counter.safeCount();</span><br><span class="line">			});</span><br><span class="line"></span><br><span class="line">			threadList.add(thread);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		threadList.stream().forEach(thread -> thread.start());</span><br><span class="line"></span><br><span class="line">		threadList.forEach(thread -> {</span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">				thread.join();</span><br><span class="line">			} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			}</span><br><span class="line">		});</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"count: "</span> + counter.i);</span><br><span class="line">		System.out.println(<span class="string">"safeCount:"</span> + counter.atomic);</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="13-3、使用CAS实现无锁同步"><a href="#13-3、使用CAS实现无锁同步" class="headerlink" title="13.3、使用CAS实现无锁同步"></a>13.3、使用CAS实现无锁同步</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package atomic;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用cas实现无锁同步</span><br><span class="line"> *</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/23 19:46</span><br><span class="line"> */</span><br><span class="line">public class CasLock {</span><br><span class="line"></span><br><span class="line">    private AtomicInteger lock = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    //记录当前获取到锁的线程ID</span><br><span class="line">    private Long getLockThreadId;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void tryLock(){</span><br><span class="line">        while (true){</span><br><span class="line">            boolean success = lock.compareAndSet(0, 1);</span><br><span class="line">            if (success){</span><br><span class="line">                getLockThreadId = Thread.currentThread().getId();</span><br><span class="line">                break;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(1);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void unLock(){</span><br><span class="line">        long currentThreadId = Thread.currentThread().getId();</span><br><span class="line">        if (currentThreadId != getLockThreadId){</span><br><span class="line">            throw new IllegalStateException("未获取到锁，无需解锁");</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        int value = lock.get();</span><br><span class="line">        if (value == 1){</span><br><span class="line">            lock.set(0);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>


<p>测试示例：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package atomic;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.BitSet;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/23 19:50</span><br><span class="line"> */</span><br><span class="line">public class CasLockDemo {</span><br><span class="line"></span><br><span class="line">    private static int i = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        BitSet bitSet = new BitSet();</span><br><span class="line"></span><br><span class="line">        CasLock lock = new CasLock();</span><br><span class="line"></span><br><span class="line">        List<thread> threadList = new ArrayList<>(500);</thread></span><br><span class="line">        Random random = new Random();</span><br><span class="line"></span><br><span class="line">        for (int  j =0 ; j < 50000; j++){</span><br><span class="line">            Thread t = new Thread(() -> {</span><br><span class="line">                try {</span><br><span class="line">                    Thread.sleep(random.nextInt(20) + 200);</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                lock.tryLock();</span><br><span class="line">                i++;</span><br><span class="line">                if(bitSet.get(i)){</span><br><span class="line">                    throw new RuntimeException("lock有问题");</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                bitSet.set(i);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + " get lock, i=" + i);</span><br><span class="line"></span><br><span class="line">                lock.unLock();</span><br><span class="line">            }, "thread-" + j);</span><br><span class="line"></span><br><span class="line">            threadList.add(t);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        threadList.forEach(thread -> thread.start());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>


<h1 id="13、atomic包原子操作类（无锁CAS）"><a href="#13、atomic包原子操作类（无锁CAS）" class="headerlink" title="13、atomic包原子操作类（无锁CAS）"></a>13、atomic包原子操作类（无锁CAS）</h1><h2 id="13-1、AtomicInteger"><a href="#13-1、AtomicInteger" class="headerlink" title="13.1、AtomicInteger"></a>13.1、AtomicInteger</h2><p>主要方法：</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-751f793bc5ec254a0652d2f92b45fceecbb.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-751f793bc5ec254a0652d2f92b45fceecbb.png" class="lazyload"></a></p>
<p>示例：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package atomic;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/25 15:07</span><br><span class="line"> */</span><br><span class="line">public class AtomicIntegerDemo {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 线程安全方式计数， 内部的value子段声明为 private volatile int value;所以保证了内存可见性</span><br><span class="line">     */</span><br><span class="line">    private AtomicInteger atomic = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 线程不安全，非原子性操作计数</span><br><span class="line">     */</span><br><span class="line">    private int i = 0;</span><br><span class="line"></span><br><span class="line">    public void count(){</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void safeCount(){</span><br><span class="line">        atomic.incrementAndGet();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        AtomicIntegerDemo counter = new AtomicIntegerDemo();</span><br><span class="line"></span><br><span class="line">        List<thread> threadList = new ArrayList<>(500);</thread></span><br><span class="line"></span><br><span class="line">        for (int j = 0; j < 500; j++){</span><br><span class="line">            Thread thread = new Thread(() ->{</span><br><span class="line">                try {</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                counter.count();</span><br><span class="line"></span><br><span class="line">                counter.safeCount();</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            threadList.add(thread);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        threadList.stream().forEach(thread -> thread.start());</span><br><span class="line"></span><br><span class="line">        threadList.forEach(thread -> {</span><br><span class="line">            try {</span><br><span class="line">                thread.join();</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        System.out.println("count: " + counter.i);</span><br><span class="line">        System.out.println("safeCount:" + counter.atomic);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-2abc872153fcd998e98bea20be041400743.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-2abc872153fcd998e98bea20be041400743.png" class="lazyload"></a></p>
<h2 id="13-2、AtomicReference"><a href="#13-2、AtomicReference" class="headerlink" title="13.2、AtomicReference"></a>13.2、AtomicReference</h2><p>AtomicReference，顾名思义，就是以原子方式更新对象引用</p>
<p>可以看到，AtomicReference持有一个对象的引用——<strong>value</strong>，并通过Unsafe类来操作该引用:</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-9420164fbbd4a44d61338e10a1828a74d88.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-9420164fbbd4a44d61338e10a1828a74d88.png" class="lazyload"></a></p>
<blockquote>
<p>为什么需要AtomicReference？难道多个线程同时对一个引用变量赋值也会出现并发问题？<br>引用变量的赋值本身没有并发问题，也就是说对于引用变量var ，类似下面的赋值操作本身就是原子操作:<br>Foo var = … ;<br><strong>AtomicReference的引入是为了可以用一种类似乐观锁的方式操作共享资源，在某些情景下以提升性能。</strong></p>
</blockquote>
<p>我们知道，当多个线程同时访问共享资源时，一般需要以加锁的方式控制并发：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">volatile Foo sharedValue = value;</span><br><span class="line">Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line">try{</span><br><span class="line">    // 操作共享资源sharedValue</span><br><span class="line">}</span><br><span class="line">finally{</span><br><span class="line">    lock.unlock();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>上述访问方式其实是一种对共享资源加<strong>悲观锁</strong>的访问方式。<br>而AtomicReference提供了<strong>以无锁方式访问共享资源</strong>的能力，看看如何通过AtomicReference保证线程安全，来看个具体的例子：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package atomic;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/24 20:50</span><br><span class="line"> */</span><br><span class="line">public class AtomicReferenceCounter {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException {</span><br><span class="line">        AtomicReference<integer> ref = new AtomicReference<>(new Integer(0));</integer></span><br><span class="line"></span><br><span class="line">        List<thread> list = new ArrayList<>();</thread></span><br><span class="line">        for (int i = 0; i < 1000; i++) {</span><br><span class="line">            Thread t = new Thread(new Task(ref), "Thread-" + i);</span><br><span class="line">            list.add(t);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        for (Thread t : list) {</span><br><span class="line">            t.start();</span><br><span class="line">            t.join();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // 打印2000</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Task implements Runnable{</span><br><span class="line"></span><br><span class="line">    private AtomicReference<integer> reference;</integer></span><br><span class="line"></span><br><span class="line">    public Task(AtomicReference<integer> reference){</integer></span><br><span class="line">        this.reference = reference;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        while (true){</span><br><span class="line">            Integer oldValue = reference.get();</span><br><span class="line">            boolean success = reference.compareAndSet(oldValue, oldValue + 1);</span><br><span class="line">            if (success){</span><br><span class="line">                break;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-259bb67ab8c852ac92d4bcfa8306222fb9f.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-259bb67ab8c852ac92d4bcfa8306222fb9f.png" class="lazyload"></a></p>
<p>该示例并没有使用锁，而是使用<strong>自旋+CAS</strong>的无锁操作保证共享变量的线程安全。1000个线程，每个线程对金额增加1，最终结果为2000，如果线程不安全，最终结果应该会小于2000。</p>
<p>通过示例，可以总结出AtomicReference的一般使用模式如下</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AtomicReference<object> ref = new AtomicReference<>(new Object());<br><span class="line">Object oldCache = ref.get();</span><br><span class="line"></span><br><span class="line">// 对缓存oldCache做一些操作</span><br><span class="line">Object newCache  =  someFunctionOfOld(oldCache); </span><br><span class="line"></span><br><span class="line">// 如果期间没有其它线程改变了缓存值，则更新</span><br><span class="line">boolean success = ref.compareAndSet(oldCache , newCache);</span><br></object></span></pre></td></tr></tbody></table></figure></div>
<p>上面的代码模板就是AtomicReference的常见使用方式，看下<strong>compareAndSet</strong>方法：<br><a href="https://oscimg.oschina.net/oscnet/up-2d62cec526978d26a7758591f4bae7eafcf.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-2d62cec526978d26a7758591f4bae7eafcf.png" class="lazyload"></a></p>
<p>该方法会将入参的<strong>expect</strong>变量所指向的对象和AtomicReference中的引用对象进行比较，如果两者指向同一个对象，则将AtomicReference中的引用对象重新置为<strong>update</strong>，修改成功返回true，失败则返回false。也就是说，<strong><em>AtomicReference其实是比较对象的引用</em></strong>。</p>
<h2 id="13-2、CAS操作可能存在的ABA问题"><a href="#13-2、CAS操作可能存在的ABA问题" class="headerlink" title="13.2、CAS操作可能存在的ABA问题"></a>13.2、CAS操作可能存在的ABA问题</h2><h3 id="13-2-1、介绍"><a href="#13-2-1、介绍" class="headerlink" title="13.2.1、介绍"></a>13.2.1、介绍</h3><blockquote>
<p>CAS操作可能存在ABA的问题，就是说：<br>假如一个值原来是A，变成了B，又变成了A，那么CAS检查时会发现它的值没有发生变化，但是实际上却变化了。</p>
</blockquote>
<p>一般来讲这并不是什么问题，比如数值运算，线程其实根本不关心变量中途如何变化，只要最终的状态和预期值一样即可。</p>
<p>但是，有些操作会依赖于对象的变化过程，此时的解决思路一般就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A - 2B - 3A。</p>
<h3 id="13-2-3、贵宾充值卡问题（ABA示例）"><a href="#13-2-3、贵宾充值卡问题（ABA示例）" class="headerlink" title="13.2.3、贵宾充值卡问题（ABA示例）"></a>13.2.3、贵宾充值卡问题（ABA示例）</h3><p><strong>举例</strong>：有一家蛋糕店为了挽留客户，决定为贵宾卡里小于20元的客户一次性充值20元，刺激客户充值和消费，但条件是：每位客户只能被赠送一次。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">package atomic;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * cas ABA问题</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/25 15:30</span><br><span class="line"> */</span><br><span class="line">public class CasABAPromblem {</span><br><span class="line"></span><br><span class="line">    private static AtomicReference<integer> money = new AtomicReference<>(19);</integer></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line"></span><br><span class="line">        ChargeMoneyWorker chargeMoneyWorker = new ChargeMoneyWorker(money);</span><br><span class="line">        for (int i = 0; i < 3; i++){</span><br><span class="line">            new Thread(chargeMoneyWorker).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ConsumeMoneyWorker consumeMoneyWorker = new ConsumeMoneyWorker(money);</span><br><span class="line">        new Thread(consumeMoneyWorker).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class ChargeMoneyWorker implements Runnable{</span><br><span class="line"></span><br><span class="line">    private AtomicReference<integer> money;</integer></span><br><span class="line"></span><br><span class="line">    public ChargeMoneyWorker(AtomicReference<integer> money){</integer></span><br><span class="line">        this.money = money;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        while (true){</span><br><span class="line"></span><br><span class="line">            while (true){</span><br><span class="line">                Integer m = money.get();</span><br><span class="line">                if (m < 20){</span><br><span class="line">                    boolean success  = money.compareAndSet(m, m +20);</span><br><span class="line">                    if (success){</span><br><span class="line">                        System.out.println("余额小于20元，充值成功， 充值后余额：" + money.get());</span><br><span class="line">                        break;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                else {</span><br><span class="line">//                    System.out.println("余额大于20元，无需充值");</span><br><span class="line">                    break;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class ConsumeMoneyWorker implements Runnable{</span><br><span class="line">    private AtomicReference<integer> money;</integer></span><br><span class="line"></span><br><span class="line">    public ConsumeMoneyWorker(AtomicReference<integer> money){</integer></span><br><span class="line">        this.money = money;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        while (true){</span><br><span class="line"></span><br><span class="line">            while (true){</span><br><span class="line">                Integer m = money.get();</span><br><span class="line">                if (m > 10){</span><br><span class="line">                    boolean success  = money.compareAndSet(m, m - 10);</span><br><span class="line">                    if (success){</span><br><span class="line">                        System.out.println("成功消费10元， 余额：" + money.get());</span><br><span class="line">                        break;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                else {</span><br><span class="line">                    System.out.println("余额不足10元");</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-4dcaed85c641a37d145edfc18d4d84b9ed7.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-4dcaed85c641a37d145edfc18d4d84b9ed7.png" class="lazyload"></a></p>
<p>从上面的输出可以到用户的账户被先后反复充值，其原因是用户的账户余额被反复修改，导致修改后又满足的原充值条件，使得充值线程无法正确判断该用户是否已经充值过。</p>
<p>虽然这种情况出现的概率不大，但是依然也是由可能出现的，因此当业务中确实出现这种问题，我们需要注意是否是我们的业务本身就不合理。JDK为我们考虑到了这种情况，使用AtomicStampedReference可以很好的解决这个问题。</p>
<h2 id="13-3、AtomicStampedReference"><a href="#13-3、AtomicStampedReference" class="headerlink" title="13.3、AtomicStampedReference"></a>13.3、AtomicStampedReference</h2><p>AtomicStampedReference就是上面所说的加了版本号的AtomicReference。</p>
<h3 id="13-3-1、AtomicStampedReference原理"><a href="#13-3-1、AtomicStampedReference原理" class="headerlink" title="13.3.1、AtomicStampedReference原理"></a>13.3.1、AtomicStampedReference原理</h3><p>先来看下如何构造一个AtomicStampedReference对象，AtomicStampedReference只有一个构造器：</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-058d51af7f8886b2a7dc793d8f5db984ae2.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-058d51af7f8886b2a7dc793d8f5db984ae2.png" class="lazyload"></a></p>
<p>可以看到，除了传入一个初始的引用变量<strong>initialRef</strong>外，还有一个<strong>initialStamp</strong>变量，<strong>initialStamp</strong>其实就是版本号（或者说时间戳），用来唯一标识引用变量。</p>
<p>在构造器内部，实例化了一个<strong>Pair</strong>对象，<strong>Pair</strong>对象记录了对象引用和时间戳信息，采用int作为时间戳，实际使用的时候，要保证时间戳唯一（一般做成自增的），如果时间戳如果重复，还会出现<strong>ABA</strong>的问题。</p>
<blockquote>
<p>AtomicStampedReference的所有方法，其实就是Unsafe类针对这个Pair对象的操作。<br>和AtomicReference相比，AtomicStampedReference中的每个引用变量都带上了pair.stamp这个版本号，这样就可以解决CAS中的ABA问题了。</p>
</blockquote>
<h3 id="13-3-2、AtomicStampedReference使用示例"><a href="#13-3-2、AtomicStampedReference使用示例" class="headerlink" title="13.3.2、AtomicStampedReference使用示例"></a>13.3.2、AtomicStampedReference使用示例</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建AtomicStampedReference对象，持有Foo对象的引用，初始为null，版本为0</span><br><span class="line">AtomicStampedReference<foo>  asr = new AtomicStampedReference<>(null,0);  </foo></span><br><span class="line"></span><br><span class="line">int[] stamp=new  int[1];</span><br><span class="line">Foo  oldRef = asr.get(stamp);   // 调用get方法获取引用对象和对应的版本号</span><br></pre></td></tr></tbody></table></figure></div>
<p>int oldStamp=stamp[0];          // stamp[0]保存版本号</p>
<p>asr.compareAndSet(oldRef, null, oldStamp, oldStamp + 1)   //尝试以CAS方式更新引用对象，并将版本号+1</p>
<p>上述模板就是AtomicStampedReference的一般使用方式，注意下<strong><em>compareAndSet</em></strong>方法：<br><a href="https://oscimg.oschina.net/oscnet/up-6024fc1db40a826c6add3fa37148921f26b.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-6024fc1db40a826c6add3fa37148921f26b.png" class="lazyload"></a></p>
<p>我们知道，AtomicStampedReference内部保存了一个pair对象，该方法的逻辑如下：</p>
<ol>
<li>如果AtomicStampedReference内部pair的引用变量、时间戳 与 入参<strong>expectedReference</strong>、<strong>expectedStamp</strong>都一样，说明期间没有其它线程修改过AtomicStampedReference，可以进行修改。此时，会创建一个新的Pair对象（casPair方法，因为Pair是Immutable类）。</li>
</ol>
<p>但这里有段优化逻辑，就是如果 newReference == current.reference && newStamp == current.stamp，说明用户修改的新值和AtomicStampedReference中目前持有的值完全一致，那么其实不需要修改，直接返回true即可。</p>
<h3 id="13-3-3、AtomicStampedReference解决贵宾卡多次充值问题"><a href="#13-3-3、AtomicStampedReference解决贵宾卡多次充值问题" class="headerlink" title="13.3.3、AtomicStampedReference解决贵宾卡多次充值问题"></a><strong>13.3.3、</strong>AtomicStampedReference<strong>解决贵宾卡多次充值问题</strong></h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package atomic;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * cas ABA问题解决方案</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/25 15:30</span><br><span class="line"> */</span><br><span class="line">public class ResolveCasABAProblem {</span><br><span class="line"></span><br><span class="line">    private static AtomicStampedReference<integer> money = new AtomicStampedReference<>(19, 0);</integer></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line"></span><br><span class="line">        ResolveChargeMoneyWorker chargeMoneyWorker = new ResolveChargeMoneyWorker(money);</span><br><span class="line">        for (int i = 0; i < 3; i++){</span><br><span class="line">            new Thread(chargeMoneyWorker).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ResolveConsumeMoneyWorker consumeMoneyWorker = new ResolveConsumeMoneyWorker(money);</span><br><span class="line">        new Thread(consumeMoneyWorker).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class ResolveChargeMoneyWorker implements Runnable{</span><br><span class="line"></span><br><span class="line">    private AtomicStampedReference<integer> money;</integer></span><br><span class="line"></span><br><span class="line">    public ResolveChargeMoneyWorker(AtomicStampedReference<integer> money){</integer></span><br><span class="line">        this.money = money;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        while (true){</span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(400);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            while (true){</span><br><span class="line">                Integer m = money.getReference();</span><br><span class="line">                if (m < 20){</span><br><span class="line">                    boolean success  = money.compareAndSet(m, m +20, 0 , 1);</span><br><span class="line">                    if (success){</span><br><span class="line">                        System.out.println("余额小于20元，充值成功， 充值后余额：" + money.getReference());</span><br><span class="line">                        break;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                else {</span><br><span class="line">//                    System.out.println("余额大于20元，无需充值");</span><br><span class="line">                    break;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class ResolveConsumeMoneyWorker implements Runnable{</span><br><span class="line">    private AtomicStampedReference<integer> money;</integer></span><br><span class="line"></span><br><span class="line">    public ResolveConsumeMoneyWorker(AtomicStampedReference<integer> money){</integer></span><br><span class="line">        this.money = money;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        while (true){</span><br><span class="line"></span><br><span class="line">            while (true){</span><br><span class="line">                Integer m = money.getReference();</span><br><span class="line">                int stamp = money.getStamp();</span><br><span class="line">                if (m > 10){</span><br><span class="line">                    // 这里为什么不是给版本号加1呢？</span><br><span class="line">                    // 假如这里变成  boolean success  = money.compareAndSet(m, m - 10, stamp, stamp + 1);</span><br><span class="line">                    // 考虑一种情况，用户账户本身有19元钱， 初始充值状态为0表示为充值, 用户先消费了10元，stamp变为1</span><br><span class="line">                    // 这时用户还没有充值，账户金额也确实少于20元，这会导致充值线程扫描是发现stamp已变为1，就不会充值了</span><br><span class="line">                    // 根本原因是用户是否消费与是否充值过无关，充值的状态不能由于其他因素改变</span><br><span class="line">                    // 这个例子是《实战高并发程序设计》一书中的例子，书中例子没有考虑到这点，</span><br><span class="line">                    // 书中假想的情况是先充值后消费，但如果是先消费再充值就有问题了</span><br><span class="line">                    boolean success  = money.compareAndSet(m, m - 10, stamp, stamp);</span><br><span class="line">                    if (success){</span><br><span class="line">                        System.out.println("成功消费10元， 余额：" + money.getReference());</span><br><span class="line">                        break;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                else {</span><br><span class="line">                    System.out.println("余额不足10元");</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>


<p><strong>情况1：先充值后消费</strong></p>
<p><a href="https://oscimg.oschina.net/oscnet/up-a206538fda31fbac36ebf648e963233601b.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-a206538fda31fbac36ebf648e963233601b.png" class="lazyload"></a></p>
<p><strong>情况2：先消费，后充值</strong></p>
<p><a href="https://oscimg.oschina.net/oscnet/up-405901c6ff52d8dda3aa7cefff4a99d936c.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-405901c6ff52d8dda3aa7cefff4a99d936c.png" class="lazyload"></a></p>
<h2 id="13-4、AtomicMarkableReference"><a href="#13-4、AtomicMarkableReference" class="headerlink" title="13.4、AtomicMarkableReference"></a>13.4、AtomicMarkableReference</h2><p>AtomicMarkableReference是AtomicStampedReference的特殊化形式<strong>AtomicMarkableReference用于无需知道数据目前具体是哪个版本，只需要知道数据是否被更改过。</strong></p>
<p>前面的客户账户充值例子ABA问题使用AtomicMarkableReference解决的代码如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">package atomic;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/25 17:45</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicMarkableReference;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * cas ABA问题</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/25 15:30</span><br><span class="line"> */</span><br><span class="line">public class AtomicMarkableReferenceDemo {</span><br><span class="line"></span><br><span class="line">    private static AtomicMarkableReference<integer> money = new AtomicMarkableReference<>(19, false);</integer></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line"></span><br><span class="line">        MarkableChargeMoneyWorker chargeMoneyWorker = new MarkableChargeMoneyWorker(money);</span><br><span class="line">        for (int i = 0; i < 3; i++){</span><br><span class="line">            new Thread(chargeMoneyWorker).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        MarkableConsumeMoneyWorker consumeMoneyWorker = new MarkableConsumeMoneyWorker(money);</span><br><span class="line">        new Thread(consumeMoneyWorker).start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class MarkableChargeMoneyWorker implements Runnable{</span><br><span class="line"></span><br><span class="line">    private AtomicMarkableReference<integer> money;</integer></span><br><span class="line"></span><br><span class="line">    public MarkableChargeMoneyWorker(AtomicMarkableReference<integer> money){</integer></span><br><span class="line">        this.money = money;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        while (true){</span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(400);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            while (true){</span><br><span class="line">                Integer m = money.getReference();</span><br><span class="line">                if (m < 20){</span><br><span class="line">                    boolean success  = money.compareAndSet(m, m +20, false , true);</span><br><span class="line">                    if (success){</span><br><span class="line">                        System.out.println("余额小于20元，充值成功， 充值后余额：" + money.getReference());</span><br><span class="line">                        break;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                else {</span><br><span class="line">//                    System.out.println("余额大于20元，无需充值");</span><br><span class="line">                    break;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class MarkableConsumeMoneyWorker implements Runnable{</span><br><span class="line">    private AtomicMarkableReference<integer> money;</integer></span><br><span class="line"></span><br><span class="line">    public MarkableConsumeMoneyWorker(AtomicMarkableReference<integer> money){</integer></span><br><span class="line">        this.money = money;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        while (true){</span><br><span class="line"></span><br><span class="line">            while (true){</span><br><span class="line">                Integer m = money.getReference();</span><br><span class="line">                boolean isMarked = money.isMarked();</span><br><span class="line">                if (m > 10){</span><br><span class="line">                    // 消费不更改充值标识</span><br><span class="line">                    boolean success  = money.compareAndSet(m, m - 10, isMarked, isMarked);</span><br><span class="line">                    if (success){</span><br><span class="line">                        System.out.println("成功消费10元， 余额：" + money.getReference());</span><br><span class="line">                        break;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                else {</span><br><span class="line">                    System.out.println("余额不足10元");</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-a516122ec60a6795845b7a9dc818e324e5f.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-a516122ec60a6795845b7a9dc818e324e5f.png" class="lazyload"></a></p>
<h2 id="13-4、AtomicIntegerArray"><a href="#13-4、AtomicIntegerArray" class="headerlink" title="13.4、AtomicIntegerArray"></a>13.4、AtomicIntegerArray</h2><p>AtomicIntegerArray本质上是对int[]类型的封装，使用Unsafe类通过CAS的方式控制int[]在多线程下的安全性，它提供了以下几个核心API：</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-80e1c38cf5e8568fd7c040effcab4575837.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-80e1c38cf5e8568fd7c040effcab4575837.png" class="lazyload"></a></p>
<h3 id="13-4-1、如果没有AtomicIntegerArray的错误示例"><a href="#13-4-1、如果没有AtomicIntegerArray的错误示例" class="headerlink" title="13.4.1、如果没有AtomicIntegerArray的错误示例"></a>13.4.1、如果没有AtomicIntegerArray的错误示例</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">package atomic;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Increment任务：这个类使用vector[i]++方法增加数组中所有元素的值</span><br><span class="line"> * Decrement任务：这个类使用vector[i]--方法减少数组中所有元素的值</span><br><span class="line"> *</span><br><span class="line"> * 在main方法中创建了1000个元素的int[]数组，</span><br><span class="line"> * 执行了1000个Increment任务和1000个Decrement任务，在任务的结尾如果没有不一致的错误，</span><br><span class="line"> * 数组中所有元素的值不全为0，执行程序后会看到程序输出了一些不全为0的数值</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/25 12:22</span><br><span class="line"> */</span><br><span class="line">public class BadAtomiceIntegerArrayDemo {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException {</span><br><span class="line">        int[] vector = new int[1000];</span><br><span class="line">        for (int  i = 0; i < vector.length; i++){</span><br><span class="line">            vector[i] = 0;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        BadIncrement increment = new BadIncrement(vector);</span><br><span class="line">        BadDecrement decrement = new BadDecrement(vector);</span><br><span class="line"></span><br><span class="line">        Thread[] badThreadIncrements = new Thread[1000];</span><br><span class="line">        Thread[] badThreadDecrements = new Thread[1000];</span><br><span class="line"></span><br><span class="line">        for (int i =0 ; i < badThreadIncrements.length; i++){</span><br><span class="line">            badThreadIncrements[i] = new Thread(increment);</span><br><span class="line">            badThreadDecrements[i] = new Thread(decrement);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        for (int i =0 ; i < badThreadIncrements.length; i++){</span><br><span class="line">            badThreadIncrements[i].start();</span><br><span class="line">            badThreadDecrements[i].start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        for (int i =0 ; i < badThreadIncrements.length; i++){</span><br><span class="line">            badThreadIncrements[i].join();</span><br><span class="line">            badThreadDecrements[i].join();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        for (int i =0 ; i < vector.length; i++){</span><br><span class="line">           if (vector[i] != 0){</span><br><span class="line">               System.out.println("Vector["+i+"] : " + vector[i]);</span><br><span class="line">           }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println("main end");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class BadIncrement implements Runnable{</span><br><span class="line"></span><br><span class="line">    private int[] vector;</span><br><span class="line"></span><br><span class="line">    public BadIncrement(int[] vector){</span><br><span class="line">        this.vector = vector;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        for (int i = 0; i <vector.length; i++){< span><br><span class="line">            vector[i]++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class BadDecrement implements Runnable{</span><br><span class="line"></span><br><span class="line">    private int[] vector;</span><br><span class="line"></span><br><span class="line">    public BadDecrement(int[] vector){</span><br><span class="line">        this.vector = vector;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        for (int i = 0; i <vector.length; i++){< span><br><span class="line">            vector[i]--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></vector.length;></span></vector.length;></span></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-61d97c25f3f953b628729704a39df7590d0.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-61d97c25f3f953b628729704a39df7590d0.png" class="lazyload"></a></p>
<h3 id="13-4-2、atomicatintegerarray的正确使用"><a href="#13-4-2、atomicatintegerarray的正确使用" class="headerlink" title="13.4.2、atomicatintegerarray的正确使用"></a>13.4.2、atomicatintegerarray的正确使用</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> atomic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomiceIntegerArrayDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        AtomicIntegerArray vector = <span class="keyword">new</span> AtomicIntegerArray(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        Increment increment = <span class="keyword">new</span> Increment(vector);</span><br><span class="line">        Decrement decrement = <span class="keyword">new</span> Decrement(vector);</span><br><span class="line"></span><br><span class="line">        Thread[] threadIncrements = <span class="keyword">new</span> Thread[<span class="number">1000</span>];</span><br><span class="line">        Thread[] threadDecrements = <span class="keyword">new</span> Thread[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i < threadIncrements.length; i++){</span><br><span class="line">            threadIncrements[i] = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">            threadDecrements[i] = <span class="keyword">new</span> Thread(decrement);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i < threadIncrements.length; i++){</span><br><span class="line">            threadIncrements[i].start();</span><br><span class="line">            threadDecrements[i].start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i < threadIncrements.length; i++){</span><br><span class="line">            threadIncrements[i].join();</span><br><span class="line">            threadDecrements[i].join();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i < vector.length(); i++){</span><br><span class="line">           <span class="keyword">if</span> (vector.get(i) != <span class="number">0</span>){</span><br><span class="line">               System.out.println(<span class="string">"Vector["</span>+i+<span class="string">"] : "</span> + vector.get(i));</span><br><span class="line">           }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main end"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Increment</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray vector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Increment</span><span class="params">(AtomicIntegerArray vector)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.vector = vector;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i <vector.length(); i++){< span><br><span class="line">            vector.getAndIncrement(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decrement</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray vector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decrement</span><span class="params">(AtomicIntegerArray vector)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.vector = vector;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i <vector.length(); i++){< span><br><span class="line">            vector.getAndDecrement(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></vector.length();></span></vector.length();></span></pre></td></tr></tbody></table></figure></div>

<p>工作原理：<br>Increment任务：这个类使用getAndIncrement方法增加数组中所有元素的值<br>  Decrement任务：这个类使用getAndDecrement方法减少数组中所有元素的值</p>
<p>  在main方法中创建了1000个元素的AtomicIntegerArray数组，<br>  执行了1000个Increment任务和1000个Decrement任务，在任务的结尾如果没有不一致的错误，<br>  数组中所有元素的值都应该是0，执行程序后会看到程序只将最后的main end消息打印到控制台，因为所有元素值为0</p>
<h2 id="13-5、atomicreferencearray"><a href="#13-5、atomicreferencearray" class="headerlink" title="13.5、atomicreferencearray"></a>13.5、atomicreferencearray</h2><p><strong>atomicreferencearray是针对普通自定义对象的数组的原子更新类的通用形式</strong><br>下面的类实现了atomicintegerarray的功能 </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> atomic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/8/25 17:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceArrayDemo</span> </span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        AtomicReferenceArray<integer> vector = <span class="keyword">new</span> AtomicReferenceArray(<span class="number">1000</span>);</integer></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>  i =<span class="number">0</span>; i < vector.length(); i++){</span><br><span class="line">            vector.set(i, <span class="number">0</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ReferenceIncrement increment = <span class="keyword">new</span> ReferenceIncrement(vector);</span><br><span class="line">        ReferenceDecrement decrement = <span class="keyword">new</span> ReferenceDecrement(vector);</span><br><span class="line"></span><br><span class="line">        Thread[] threadIncrements = <span class="keyword">new</span> Thread[<span class="number">1000</span>];</span><br><span class="line">        Thread[] threadDecrements = <span class="keyword">new</span> Thread[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i < threadIncrements.length; i++){</span><br><span class="line">            threadIncrements[i] = <span class="keyword">new</span> Thread(increment);</span><br><span class="line">            threadDecrements[i] = <span class="keyword">new</span> Thread(decrement);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i < threadIncrements.length; i++){</span><br><span class="line">            threadIncrements[i].start();</span><br><span class="line">            threadDecrements[i].start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i < threadIncrements.length; i++){</span><br><span class="line">            threadIncrements[i].join();</span><br><span class="line">            threadDecrements[i].join();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i < vector.length(); i++){</span><br><span class="line">            <span class="keyword">if</span> (vector.get(i) != <span class="number">0</span>){</span><br><span class="line">                System.out.println(<span class="string">"Vector["</span>+i+<span class="string">"] : "</span> + vector.get(i));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main end"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReferenceIncrement</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReferenceArray<integer> vector;</integer></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceIncrement</span><span class="params">(AtomicReferenceArray<integer> vector)</integer></span></span>{</span><br><span class="line">        <span class="keyword">this</span>.vector = vector;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i <vector.length(); i++){< span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不能用set， 用了set后就是不管内存现有真实值是多少，直接设置为新值， 在cpu时间片切换时会有问题</span></span><br><span class="line">            <span class="comment">// 正确的应该是在原有值基础上加1</span></span><br><span class="line"><span class="comment">//            vector.set(i, current + 1);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">                <span class="keyword">int</span> current = vector.get(i);</span><br><span class="line">                <span class="keyword">if</span>(vector.compareAndSet(i, current, current + <span class="number">1</span>)){</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReferenceDecrement</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReferenceArray<integer> vector;</integer></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceDecrement</span><span class="params">(AtomicReferenceArray<integer> vector)</integer></span></span>{</span><br><span class="line">        <span class="keyword">this</span>.vector = vector;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i <vector.length(); i++){< span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">                <span class="keyword">int</span> current = vector.get(i);</span><br><span class="line">                <span class="keyword">if</span>(vector.compareAndSet(i, current, current - <span class="number">1</span>)){</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></vector.length();></span></vector.length();></span></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-3ea4ba16dc446b821f36372f0653a85ea3e.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-3ea4ba16dc446b821f36372f0653a85ea3e.png" class="lazyload"></a></p>
<h2 id="13-6、atomicintegerfieldupdater"><a href="#13-6、atomicintegerfieldupdater" class="headerlink" title="13.6、atomicintegerfieldupdater"></a>13.6、atomicintegerfieldupdater</h2><p>根据数据类型不同， updater有3种， 分别是atomicintegerfieldupdater、atomiclongfieldupdater、atomicreferencefieldupdater </p>
<p><strong>示例场景:</strong><br>假设某地要进行一次选举。现在模拟这个投票场景，如果选民投了候选人1票，就记为1，否则记为0，最终就是要统计某个选择被投票的次数。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">package atomic; </span><br><span class="line">import java.util.arrays; </span><br><span class="line">java.util.concurrent.atomic.atomicinteger;</span><br><span class="line">java.util.concurrent.atomic.atomicintegerfieldupdater; </span><br><span class="line">/** </span><br><span class="line">* @author calebzhao<9 3 9 4 7 5 0 @ qq.com></span><br><span class="line"> * 2019/8/25 18:01</span><br><span class="line"> */</span><br><span class="line">public class AtomicIntegerFieldUpdaterDemo {</span><br><span class="line"></span><br><span class="line">    private static AtomicIntegerFieldUpdater<candidate> scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, "score");</candidate></span><br><span class="line"></span><br><span class="line">    //作用是为了来验证AtomicIntegerFieldUpdater计算的正确性</span><br><span class="line">    private static AtomicInteger allScore = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException {</span><br><span class="line">        Candidate candidate = new Candidate();</span><br><span class="line"></span><br><span class="line">        Thread[] threads = new Thread[1000];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i < 1000; i++){</span><br><span class="line">            threads[i] = new Thread(() -> {</span><br><span class="line">                // 模拟投票过程随机</span><br><span class="line">                if (Math.random() > 0.5){</span><br><span class="line">                    scoreUpdater.incrementAndGet(candidate);</span><br><span class="line">                    allScore.incrementAndGet();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Arrays.stream(threads).forEach(thread -> thread.start());</span><br><span class="line"></span><br><span class="line">        for (int i =0 ; i < threads.length; i++){</span><br><span class="line">            threads[i].join();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println("scoreUpdater:" + scoreUpdater.get(candidate));</span><br><span class="line">        System.out.println("allScore:" +allScore.get());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class Candidate{</span><br><span class="line"></span><br><span class="line">    int id;</span><br><span class="line"></span><br><span class="line">     volatile int score;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-38be9d644b8863e160e1755f5364e798bef.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-38be9d644b8863e160e1755f5364e798bef.png" class="lazyload"></a></p>
<p>上述代码模拟了这个场景，候选人的得票数量记录在Candidate.score中，注意它是一个普通的volatile 变量，而volatile 变量并不会保证线程安全性，只会保证内存可见性和禁止重排序，代码中通过Math.random()来模拟随机投票过程， AtomicInteger allScore = new AtomicInteger(0);这一行代码用来验证 AtomicIntegerFieldUpdater计算的正确性， 运行这段程序会发现 allScore的值总是和scoreUpdater的值相等。</p>
<p><strong>AtomicIntegerFieldUpdater使用注意事项：</strong></p>
<ol>
<li>Updater只能修改它可见范围内的变量，因为Updater使用反射获得这个变量，如果变量不可见就会报错，比如score声明为private的，就不行。</li>
<li>为了保证变量在多线程环境被正确的读取，它必须是volatile修饰的，如果不修饰也会报错。</li>
<li>由于CAS操作通过对象实例中的偏移量直接进行赋值，因此它不支持static字段（<em>U</em>.objectFieldOffset(field)不支持静态变量），如果被static修饰了也会报错</li>
</ol>
<h1 id="14、Unsafe"><a href="#14、Unsafe" class="headerlink" title="14、Unsafe"></a>14、Unsafe</h1><h2 id="14-1、获取unsafe"><a href="#14-1、获取unsafe" class="headerlink" title="14.1、获取unsafe"></a>14.1、获取unsafe</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package 自旋锁计数;</span><br><span class="line"></span><br><span class="line">import sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/26 20:17</span><br><span class="line"> */</span><br><span class="line">public class UnsafeUtil</span><br><span class="line">{</span><br><span class="line">    public static Unsafe getUnsafe(){</span><br><span class="line">        try {</span><br><span class="line">            Field field = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            </span><br><span class="line">            // 这里是null是因为theUnsafe属性是static静态属性</span><br><span class="line">            return (Unsafe) field.get(null);</span><br><span class="line">        } catch (NoSuchFieldException | IllegalAccessException e) {</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>15、几种Couter计数的性能比较</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line">package 自旋锁计数;</span><br><span class="line"></span><br><span class="line">import sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class CounterDemo {</span><br><span class="line"></span><br><span class="line">    private  final int THREAD_COUNT = 1000;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        CounterDemo counterDemo =  new CounterDemo();</span><br><span class="line"></span><br><span class="line">        counterDemo.atomicCouterTest();</span><br><span class="line"></span><br><span class="line">        counterDemo.casCouterTest();</span><br><span class="line"></span><br><span class="line">        counterDemo.synchronizedCouterTest();</span><br><span class="line"></span><br><span class="line">        counterDemo.badCouterTest();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void atomicCouterTest(){</span><br><span class="line">        try{</span><br><span class="line">            AtomicIntegerCouter atomicIntegerCouter = new AtomicIntegerCouter();</span><br><span class="line">            CouterThread couterThread = new CouterThread(atomicIntegerCouter);</span><br><span class="line">            List<thread> threadList = new ArrayList<>();</thread></span><br><span class="line">            for (int j = 0; j < THREAD_COUNT; j++){</span><br><span class="line">                Thread thread = new Thread(couterThread);</span><br><span class="line">                threadList.add(thread);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            threadList.stream().forEach(thread -> thread.start());</span><br><span class="line"></span><br><span class="line">            threadList.forEach(thread -> {</span><br><span class="line">                try {</span><br><span class="line">                    thread.join();</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            long time = System.currentTimeMillis() - start;</span><br><span class="line"></span><br><span class="line">            System.out.println("atomicIntegerCouter: " + atomicIntegerCouter.getValue() + " 耗时： " + time);</span><br><span class="line">        }</span><br><span class="line">        catch (Exception e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void casCouterTest(){</span><br><span class="line">        try{</span><br><span class="line">            CasCounter casCounter = new CasCounter();</span><br><span class="line">            CouterThread couterThread = new CouterThread(casCounter);</span><br><span class="line">            List<thread> threadList = new ArrayList<>();</thread></span><br><span class="line">            for (int j = 0; j < THREAD_COUNT; j++){</span><br><span class="line">                Thread thread = new Thread(couterThread);</span><br><span class="line">                threadList.add(thread);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            threadList.stream().forEach(thread -> thread.start());</span><br><span class="line"></span><br><span class="line">            threadList.forEach(thread -> {</span><br><span class="line">                try {</span><br><span class="line">                    thread.join();</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            long time = System.currentTimeMillis() - start;</span><br><span class="line">            System.out.println("casCounter: " + casCounter.getValue() + " 耗时： " + time);</span><br><span class="line">        }</span><br><span class="line">        catch (Error e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void synchronizedCouterTest(){</span><br><span class="line">        try{</span><br><span class="line">            SynchronizedCouter synchronizedCouter = new SynchronizedCouter();</span><br><span class="line">            CouterThread couterThread = new CouterThread(synchronizedCouter);</span><br><span class="line">            List<thread> threadList = new ArrayList<>();</thread></span><br><span class="line">            for (int j = 0; j < THREAD_COUNT; j++){</span><br><span class="line">                Thread thread = new Thread(couterThread);</span><br><span class="line">                threadList.add(thread);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            threadList.stream().forEach(thread -> thread.start());</span><br><span class="line"></span><br><span class="line">            threadList.forEach(thread -> {</span><br><span class="line">                try {</span><br><span class="line">                    thread.join();</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            long time = System.currentTimeMillis() - start;</span><br><span class="line"></span><br><span class="line">            System.out.println("synchronizedCounter: " + synchronizedCouter.getValue() + " 耗时： " + time);</span><br><span class="line">        }</span><br><span class="line">        catch (Exception e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void badCouterTest(){</span><br><span class="line">        try{</span><br><span class="line">            BadCouter badCouter = new BadCouter();</span><br><span class="line">            CouterThread couterThread = new CouterThread(badCouter);</span><br><span class="line">            List<thread> threadList = new ArrayList<>();</thread></span><br><span class="line">            for (int j = 0; j < THREAD_COUNT; j++){</span><br><span class="line">                Thread thread = new Thread(couterThread);</span><br><span class="line">                threadList.add(thread);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            threadList.stream().forEach(thread -> thread.start());</span><br><span class="line"></span><br><span class="line">            threadList.forEach(thread -> {</span><br><span class="line">                try {</span><br><span class="line">                    thread.join();</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            long time = System.currentTimeMillis() - start;</span><br><span class="line">            System.out.println("badCouter: " + badCouter.getValue() + " 耗时： " + time);</span><br><span class="line">        }</span><br><span class="line">        catch (Exception e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class CouterThread implements Runnable{</span><br><span class="line"></span><br><span class="line">    private Counter counter;</span><br><span class="line"></span><br><span class="line">    public CouterThread(Counter counter){</span><br><span class="line">        this.counter = counter;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() {</span><br><span class="line">        try {</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        counter.incrementAndGet();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">interface Counter{</span><br><span class="line"></span><br><span class="line">    int incrementAndGet();</span><br><span class="line"></span><br><span class="line">    int getAndIncrement();</span><br><span class="line"></span><br><span class="line">    int getValue();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class AtomicIntegerCouter implements Counter{</span><br><span class="line">    /**</span><br><span class="line">     * 线程安全方式计数， 内部的value子段声明为 private volatile int value;所以保证了内存可见性</span><br><span class="line">     */</span><br><span class="line">    private AtomicInteger atomic = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int incrementAndGet(){</span><br><span class="line"></span><br><span class="line">        while (true){</span><br><span class="line">            // 1、多核处理器可能会同时运行到这行代码，单核处理器由于时间片分配算法T1执行到这行代码后CPU执行权被T2获取了， 线程T1、T2均通过get()方法返回0</span><br><span class="line">            // 2、假如T1先执行atomic.compareAndSet(currentValue, ++currentValue)这行代码，</span><br><span class="line">            //    由于currentValue和atomic的值一致，cas操作成功，atomic变成1，退出循环,</span><br><span class="line">            // 3、然后T2继续执行atomic.compareAndSet(currentValue, ++currentValue);</span><br><span class="line">            //    这行代码会发现atomic内部维护的value值1已经与currentValue的值0不相等，不会进行设置值操作</span><br><span class="line">            //    T2继续下次循环, 又执行atomic.get();获取到的currentValue为1， 再次执行compareAndSet时，</span><br><span class="line">            //    atomic为1和currentValue为1相等，成功进行cas操作，然后退出循环</span><br><span class="line">            int currentValue = atomic.get();</span><br><span class="line">            boolean success = atomic.compareAndSet(currentValue, ++currentValue);</span><br><span class="line">            if (success){</span><br><span class="line">                return atomic.get();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getAndIncrement() {</span><br><span class="line">        while (true){</span><br><span class="line">            int currentValue = atomic.get();</span><br><span class="line">            boolean success = atomic.compareAndSet(currentValue, ++currentValue);</span><br><span class="line">            if (success){</span><br><span class="line">                return currentValue;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getValue() {</span><br><span class="line">        return atomic.get();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class CasCounter implements Counter{</span><br><span class="line"></span><br><span class="line">    private volatile int count = 0;</span><br><span class="line"></span><br><span class="line">    private static final Unsafe unsafe = UnsafeUtil.getUnsafe();</span><br><span class="line"></span><br><span class="line">    private static long valueOffset;</span><br><span class="line"></span><br><span class="line">    static {</span><br><span class="line">        try {</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(CasCounter.class.getDeclaredField("count"));</span><br><span class="line">        }</span><br><span class="line">        catch (NoSuchFieldException e) {</span><br><span class="line">            throw new Error();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int incrementAndGet() {</span><br><span class="line">        while (true){</span><br><span class="line">            boolean success = unsafe.compareAndSwapInt(this, valueOffset, count, count + 1);</span><br><span class="line">            if (success){</span><br><span class="line">                return count;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getAndIncrement() {</span><br><span class="line">        while (true){</span><br><span class="line">            boolean success = unsafe.compareAndSwapInt(this, valueOffset, count, count + 1);</span><br><span class="line">            if (success){</span><br><span class="line">                return count;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getValue() {</span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class BadCouter implements Counter{</span><br><span class="line">    private volatile int count = 0;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int incrementAndGet() {</span><br><span class="line">        return ++count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getAndIncrement() {</span><br><span class="line">        return count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getValue() {</span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">class SynchronizedCouter implements Counter{</span><br><span class="line">    private volatile int count = 0;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized int incrementAndGet() {</span><br><span class="line">        return ++count;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized int getAndIncrement() {</span><br><span class="line">        return count++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getValue() {</span><br><span class="line">        return count;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-8dab2724597e9856028fb66370a4020241a.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-8dab2724597e9856028fb66370a4020241a.png" class="lazyload"></a></p>
<p>多次运行示例代码，会发现基本上每次synchronizedCouter的耗时最短，这也说明了synchronized使用锁的方式性能并不一定低。</p>
<h1 id="16、JUC"><a href="#16、JUC" class="headerlink" title="16、JUC"></a>16、JUC</h1><h2 id="16-1、CountDownLatch"><a href="#16-1、CountDownLatch" class="headerlink" title="16.1、CountDownLatch"></a>16.1、CountDownLatch</h2><h3 id="16-1-1、介绍"><a href="#16-1-1、介绍" class="headerlink" title="16.1.1、介绍"></a>16.1.1、介绍</h3><p>CountDownLatch简单理解为倒计数器，这个类通常用来控制线程等待，它可以让一个线程等待直到倒计数器的值为0，再开始执行</p>
<p>调用await()方法会调用调用线程被阻塞，直到CountDownLatch的值为0才会继续往后执行</p>
<p>调用countdown()方法会使计数器的值减1.</p>
<h3 id="16-1-2、入门示例"><a href="#16-1-2、入门示例" class="headerlink" title="16.1.2、入门示例"></a>16.1.2、入门示例</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> countdown;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/8/7 20:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCountDownLatchDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyCountDownLatch countDownLatch = <span class="keyword">new</span> MyCountDownLatch(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        IntStream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).forEach((i) -> {</span><br><span class="line">            <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" finished"</span>);</span><br><span class="line"></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            }, <span class="string">"Thread-"</span> + i).start();</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"main finished"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-e1b6773ada7f6283081e27fdb69bcb8f874.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-e1b6773ada7f6283081e27fdb69bcb8f874.png" class="lazyload"></a></p>
<p>main线程的输出一定会等到所有线程执行完毕后才会执行（类似thread.join()的作用）</p>
<h2 id="16-2、CyclicBarrer"><a href="#16-2、CyclicBarrer" class="headerlink" title="16.2、CyclicBarrer"></a>16.2、CyclicBarrer</h2><h3 id="16-2-1、简介"><a href="#16-2-1、简介" class="headerlink" title="16.2.1、简介"></a>16.2.1、简介</h3><p>CyclicBarrer的作用和<code>CountDownLatch</code>非常类似，它也可以<strong>实现线程间的计数等待</strong>，但它的作用比CountDownLatch更加强大和复杂。  </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><figcaption><span>```的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，**让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活**。CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">```CyclicBarrer```可以理解为循环栅栏，栅栏就是一种障碍物，比如通常在私人府邸的周围围上一圈栅栏，阻止闲杂人等入内。这里当然是用来阻止线程继续执行，要求线程在栅栏外等待。前面Cycli意为循环，也就是说这个计数器可以反复使用，比如我们将计数器的值设置10，那么当第一批执行线程报道(调用await()方法)后，计数就会归零，接着下一批执行线程报道，这是Cycli的含义。</span><br><span class="line"></span><br><span class="line">### 16.2.2、入门示例</span><br></pre></td></tr></tbody></table></figure></div>
<p>package cyclicBarrier;</p>
<p>import java.util.concurrent.BrokenBarrierException;<br>import java.util.concurrent.CyclicBarrier;</p>
<p>/**</p>
<ul>
<li><p>@author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></p>
</li>
<li><p>2019/8/27 22:18</p>
</li>
<li><p>/<br>public class CycliBarrerDemo2 {</p>
<p>  public static void main(String[] args) throws BrokenBarrierException, InterruptedException {</p>
<pre><code>CyclicBarrier cyclicBarrier = new CyclicBarrier(2);

new Thread(){
    @Override
    public void run() {
        try {
            cyclicBarrier.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        }

        System.out.println(1);
    }
}.start();

cyclicBarrier.await();
System.out.println(2);</code></pre><p>  }<br>}</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">![](https://oscimg.oschina.net/oscnet/up-d8dd855c66b695a99895493fdad3e1bcd66.png)</span><br><span class="line">![](https://oscimg.oschina.net/oscnet/up-54fbf8910c445c6eb6927df7386519b09ed.png)</span><br><span class="line"></span><br><span class="line">上面的示例有时输出12，有时输出21,</span><br><span class="line"></span><br><span class="line">如果把new CyclicBarrier(2)修改成new CyclicBarrier(3)则主线程和子线程会永远等待，因为没有第三个线程执行await方法，即没有第三个线程到达屏障，所以之前到达屏障的两个线程都不会继续执行。</span><br><span class="line"></span><br><span class="line">### 16.2.3、CyclicBarrier的构造函数，执行完成hook</span><br><span class="line">```CyclicBarrier```还提供一个更高级的构造函数```CyclicBarrier(int parties, Runnable barrierAction)```，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。代码如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package cyclicBarrier;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.BrokenBarrierException;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/27 22:18</span><br><span class="line"> */</span><br><span class="line">public class CycliBarrerDemo2 {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws BrokenBarrierException, InterruptedException {</span><br><span class="line">        CyclicBarrier cyclicBarrier = new CyclicBarrier(2, new BarrierAction());</span><br><span class="line"></span><br><span class="line">        new Thread(){</span><br><span class="line">            @Override</span><br><span class="line">            public void run() {</span><br><span class="line">                try {</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                } catch (BrokenBarrierException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                System.out.println(1);</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        System.out.println(2);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    static class BarrierAction implements Runnable{</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() {</span><br><span class="line">            System.out.println("执行完毕");</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-1b1e9651615b35ee0f8bfa320d89e03b64f.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-1b1e9651615b35ee0f8bfa320d89e03b64f.png" class="lazyload"></a></p>
</li>
</ul>
<h3 id="16-2-4、示例3"><a href="#16-2-4、示例3" class="headerlink" title="16.2.4、示例3"></a>16.2.4、示例3</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/8/27 21:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CycliBarrierDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"t1 finished"</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"t1 the other finished too"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"t2 finished"</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">"t2 the other finished too"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line">        </span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">          System.out.println(cyclicBarrier.getNumberWaiting());</span><br><span class="line">          System.out.println(cyclicBarrier.getParties());</span><br><span class="line">          System.out.println(cyclicBarrier.isBroken());</span><br><span class="line">          </span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">          System.out.println(cyclicBarrier.getNumberWaiting());</span><br><span class="line">          System.out.println(cyclicBarrier.getParties());</span><br><span class="line">          System.out.println(cyclicBarrier.isBroken());</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-8f87f400c85078a0ce21bbfd40a502dfe2f.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-8f87f400c85078a0ce21bbfd40a502dfe2f.png" class="lazyload"></a></p>
<h3 id="16-2-5、士兵报道示例"><a href="#16-2-5、士兵报道示例" class="headerlink" title="16.2.5、士兵报道示例"></a>16.2.5、士兵报道示例</h3><p>考虑如下场景：司令下达命令，要求10个士兵一起去完成一项任务，这是会要求10个士兵先集合报道，接着，一起雄赳赳，气昂昂地去执行任务。当10个士兵把自己手头上的任务全部执行完了，那么司令才能对外宣布，任务完成。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/8/27 23:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo4</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>, <span class="keyword">new</span> BarrierAction());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < <span class="number">11</span>; i++){</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Soldier(<span class="string">"士兵"</span> +i, cyclicBarrier)).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrierAction</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> wokrFinshed;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (wokrFinshed){</span><br><span class="line">                System.out.println(<span class="string">"\n全部士兵完成工作\n"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                System.out.println(<span class="string">"\n全部士兵报道完成\n"</span>);</span><br><span class="line">                wokrFinshed = <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String soldier;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(String soldier, CyclicBarrier cyclicBarrier)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.soldier = soldier;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">//等待所有士兵报道完成</span></span><br><span class="line">                System.out.println(soldier +<span class="string">"报道"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 所有士兵报道后开始做真正的工作</span></span><br><span class="line">                <span class="keyword">this</span>.doWork();</span><br><span class="line">                System.out.println(soldier +<span class="string">"完成工作"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待所有士兵完成工作</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(soldier +<span class="string">"等待其他士兵完成工作"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-09d3395a35a86cc96f2f2d961def1b27be9.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-09d3395a35a86cc96f2f2d961def1b27be9.png" class="lazyload"></a></p>
<h3 id="16-2-5、CyclicBarrier的应用场景"><a href="#16-2-5、CyclicBarrier的应用场景" class="headerlink" title="16.2.5、CyclicBarrier的应用场景"></a>16.2.5、CyclicBarrier的应用场景</h3><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个Excel保存了用户所有银行流水，每个Sheet保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。 </p>
<h3 id="16-2-6、CyclicBarrier和CountDownLatch的区别"><a href="#16-2-6、CyclicBarrier和CountDownLatch的区别" class="headerlink" title="16.2.6、CyclicBarrier和CountDownLatch的区别"></a>16.2.6、CyclicBarrier和CountDownLatch的区别</h3><ul>
<li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</li>
<li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道<strong>阻塞的线程是否被中断</strong>。比如以下代码执行完之后会返回true<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest3</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    c.await();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            c.await();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            System.out.println(c.isBroken());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

</li>
</ul>
<p>输出 true</p>
<h2 id="16-3、Exchanger"><a href="#16-3、Exchanger" class="headerlink" title="16.3、Exchanger"></a>16.3、Exchanger</h2><h3 id="16-3-1、介绍"><a href="#16-3-1、介绍" class="headerlink" title="16.3.1、介绍"></a>16.3.1、介绍</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">exchange方法交换数据，如果第一个线程先执行```exchange()```方法，它会一直等待第二个线程也</span><br><span class="line"></span><br><span class="line">执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产</span><br><span class="line"></span><br><span class="line">出来的数据传递给对方。</span><br><span class="line"></span><br><span class="line">### 16.3.2、Exchanger的应用场景</span><br><span class="line">Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致，代码如代码清单8-8所示。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package juc.exchanger;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Exchanger;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class ExchangerDemo {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Exchanger<string> exchanger = new Exchanger<>();</string></span><br><span class="line"></span><br><span class="line">        new Thread(){</span><br><span class="line">            @Override</span><br><span class="line">            public void run() {</span><br><span class="line">                System.out.println("银行流水A before exchange....");</span><br><span class="line"></span><br><span class="line">                String value = null;</span><br><span class="line">                try {</span><br><span class="line">                    value = exchanger.exchange("1111111");</span><br><span class="line">                    // value = exchanger.exchange("the value is from t1", 1, TimeUnit.SECONDS);</span><br><span class="line">                } catch (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                System.out.println("银行流水A，校验收到的银行流水B: " + value);</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">        new Thread(){</span><br><span class="line">            @Override</span><br><span class="line">            public void run() {</span><br><span class="line">                System.out.println("银行流水B before exchange....");</span><br><span class="line"></span><br><span class="line">                try {</span><br><span class="line">                    TimeUnit.SECONDS.sleep(2);</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                String value = null;</span><br><span class="line">                try {</span><br><span class="line">                    value = exchanger.exchange("2222222");</span><br><span class="line">                } catch (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                System.out.println("银行流水B，校验收到的银行流水A: " + value);</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">        System.out.println("main done");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-162554e02d7b939b77d897a8ce15d6e8351.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-162554e02d7b939b77d897a8ce15d6e8351.png" class="lazyload"></a></p>
<h3 id="16-3-3、exchage-超时控制"><a href="#16-3-3、exchage-超时控制" class="headerlink" title="16.3.3、exchage()超时控制"></a>16.3.3、exchage()超时控制</h3><p>如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，<strong>可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长</strong>。</p>
<p>当把银行流水A线程的exchage这一行代码改为如下超时参数，会导致A等待B超时，银行流水A线程抛出TimeoutException(因为银行流水B的exchage在2秒后才会执行，而银行流水A最多等待1秒)，而银行流水B线程在睡眠结束后执行exchage()方法后又等待银行流水A的数据，但是此时银行流水A线程早已结束，导致银行流水B线程由于一直交换不了数据而一直阻塞在exchage()方法这一行。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String value = exchanger.exchange("the value is from t1", 1, TimeUnit.SECONDS);</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-66adea3471e5101a8abfdee64bcc241dab8.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-66adea3471e5101a8abfdee64bcc241dab8.png" class="lazyload"></a></p>
<h2 id="16-4、Semaphore"><a href="#16-4、Semaphore" class="headerlink" title="16.4、Semaphore"></a>16.4、Semaphore</h2><h3 id="16-4-1、介绍"><a href="#16-4-1、介绍" class="headerlink" title="16.4.1、介绍"></a>16.4.1、介绍</h3><p>Semaphore的中文意思是信号、信号系统，在java中一般称为信号量，此类的主要作用是限制线程并发的数量，如果不限制线程并发的数据，则当有一大批任务要执行时（考虑Tomcat高并发请求的场景），如果不加以限制，为每个任务分配一个线程，那么CPU的资源（线程资源、CPU时间片）很快会被耗尽（系统资源被这些线程长期占据着，导致系统其他程序分配不到线程或时间片而无法执行或者非常卡顿），另外由于每个请求对应一个线程，导致操作系统中的线程数量非常大，而CPU时间片非常短，那么会导致CPU在成千上万个线程之间不断快速切换线程上下文，这样导致CPU的时间片大部分用于切换线程上下文了，而CPU时间片并没有用于线程实际的任务执行，这样就导致系统整体变得非常卡慢，另外由于系统中的线程已经耗尽，那么当有其他地方需要开启线程时，由于系统没有多余的可用线程，会导致其他程序，甚至是操作系统也挂掉（其实hystrix熔断的目的就是为了隔离线程池，控制并发量）。</p>
<p>Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假  如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库接。这个时候，就可以使用Semaphore来做流量控制。</p>
<h3 id="16-4-2、Semaphore实现同步锁"><a href="#16-4-2、Semaphore实现同步锁" class="headerlink" title="16.4.2、Semaphore实现同步锁"></a>16.4.2、Semaphore实现同步锁</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/8/28 21:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        AtomicReference<integer> counter = <span class="keyword">new</span> AtomicReference<>(<span class="number">0</span>);</integer></span><br><span class="line">        SemaphoreLock lock = <span class="keyword">new</span> SemaphoreLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">10</span>; i++){</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="string">"t"</span> + i){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    <span class="keyword">try</span>{</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" is running"</span>);</span><br><span class="line">                        lock.lock();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" get lock"</span>);</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">finally</span> {</span><br><span class="line">                        lock.unLock();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" release lock"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLock</span></span>{</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread current;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            semaphore.acquire();</span><br><span class="line"></span><br><span class="line">            current = Thread.currentThread();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (current == Thread.currentThread()){</span><br><span class="line">            semaphore.release();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-fc4e2d30bd448c42f4fc51894e38a321029.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-fc4e2d30bd448c42f4fc51894e38a321029.png" class="lazyload"></a></p>
<p>从输出可以看到一个线程必须要等待另一个线程释放锁后，获取到了锁才能往下执行</p>
<h3 id="16-4-3、构造方法permits参数作用"><a href="#16-4-3、构造方法permits参数作用" class="headerlink" title="16.4.3、构造方法permits参数作用"></a>16.4.3、构造方法permits参数作用</h3><p>数permits的作用是设置许可的个数，前面已经使用过代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = new Semaphore(1)</span><br></pre></td></tr></tbody></table></figure></div>
<p>来进行程序的设计，使同一时间内最多只有1个线程可以获取到锁，执行lock()和unLock()之间的代码，其实还可以传入大于1的数值，代表同一时间内最多运行有x个线程可以执行accquire()和release()之间的代码。<br>同一时间内最多允许运行2个线程同时运行代码示例：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/8/28 21:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3</span>; i++){</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="string">"t"</span> + i){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    <span class="keyword">try</span>{</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" is running"</span>);</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" get lock"</span>);</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">finally</span> {</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" release lock"</span>);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>


<p><a href="https://oscimg.oschina.net/oscnet/up-f286050c05c8bf9e13fe1eccbc17e64e7f1.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-f286050c05c8bf9e13fe1eccbc17e64e7f1.png" class="lazyload"></a></p>
<p>注意：当Semaphore的构造方法的参数permits的值大于1时，该类并不能保证线程安全性，因为可能会出现多个线程共同访问示例变量，导致出现脏数据的情况。</p>
<h3 id="16-4-4、acquire-permits-的作用"><a href="#16-4-4、acquire-permits-的作用" class="headerlink" title="16.4.4、acquire(permits)的作用"></a>16.4.4、acquire(permits)的作用</h3><p>有参方法acquire(int permits)的作用是每调用1次此方法，就使用X个许可</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package juc.semaphore;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/28 21:09</span><br><span class="line"> */</span><br><span class="line">public class SemaphoreDemo3 {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException {</span><br><span class="line">        Semaphore semaphore = new Semaphore(3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for (int i = 0; i < 2; i++){</span><br><span class="line">            new Thread("t" + i){</span><br><span class="line">                @Override</span><br><span class="line">                public void run() {</span><br><span class="line">                    try{</span><br><span class="line">                           System.out.println(Thread.currentThread().getName() + " is running");</span><br><span class="line"></span><br><span class="line">                        semaphore.acquire(2);</span><br><span class="line">                        System.out.println("\n" +</span><br><span class="line">Thread.currentThread().getName() + " get lock" + " , availablePermits:" + semaphore.availablePermits());</span><br><span class="line">                        System.out.println();</span><br><span class="line">                        try {</span><br><span class="line">                            TimeUnit.SECONDS.sleep(10);</span><br><span class="line">                        } catch (InterruptedException e) {</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    catch (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                    finally {</span><br><span class="line">                        semaphore.release(2);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + " release lock" + " , availablePermits:" + semaphore.availablePermits());</span><br><span class="line"></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-2342902b27eea0ae7d0c04d32b4bd8d33aa.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-2342902b27eea0ae7d0c04d32b4bd8d33aa.png" class="lazyload"></a></p>
<p>从输出可以看到t0线程获取到锁了，然后一直不释放，虽然t0只用了2个许可，还剩余1个许可，但是t1任务得不到继续执行，必须要等到过了10秒钟t0释放锁后t1才能得到继续执行。说明acquire(int permits)方法每次调用<strong>必须要获取到足够的许可才能继续往后执行</strong>，线程只获取到部分许可并不能让其继续往后执行。</p>
<h3 id="16-4-5、动态增加许可数量（release-）及drainPermits"><a href="#16-4-5、动态增加许可数量（release-）及drainPermits" class="headerlink" title="16.4.5、动态增加许可数量（release()）及drainPermits()"></a>16.4.5、动态增加许可数量（release()）及drainPermits()</h3><p><strong>每调用一次release(int permits)可增加x个许可，可一直重复调用</strong></p>
<ul>
<li><p>semaphore.availablePermits()获取当前可用的许可数量</p>
</li>
<li><p>semaphore.drainPermits()返回当前可用的许可数量，<strong>并将信号量的可用许可数量置为0</strong>，后续调用acquire()就无法获取到许可（除非调用release()增加许可）</p>
</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/8/28 22:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo4</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        System.out.println(<span class="string">"availablePermits:"</span> +semaphore.availablePermits());</span><br><span class="line"></span><br><span class="line">        semaphore.release();</span><br><span class="line">        semaphore.release();</span><br><span class="line">        semaphore.release();</span><br><span class="line">        System.out.println(<span class="string">"availablePermits:"</span> +semaphore.availablePermits());</span><br><span class="line"></span><br><span class="line">        semaphore.release(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"availablePermits:"</span> +semaphore.availablePermits());</span><br><span class="line">        System.out.println(semaphore.drainPermits() +<span class="string">", "</span> + semaphore.availablePermits());</span><br><span class="line"></span><br><span class="line">        semaphore.release();</span><br><span class="line">        semaphore.release();</span><br><span class="line">        System.out.println(semaphore.drainPermits() +<span class="string">", "</span> + semaphore.availablePermits());</span><br><span class="line">        semaphore.drainPermits();</span><br><span class="line">        System.out.println( semaphore.availablePermits());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-2b3303d5f4b5909ea0f88c8c2cf3f77f3db.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-2b3303d5f4b5909ea0f88c8c2cf3f77f3db.png" class="lazyload"></a></p>
<p><strong>实验说明构造函数new Semaphore(2)的参数值2并不是最终的许可值，仅仅是初始的状态值，每调用一次release(int permits)可增加x个许可。</strong></p>
<h3 id="16-4-6、acquireUninterruptibly-的作用"><a href="#16-4-6、acquireUninterruptibly-的作用" class="headerlink" title="16.4.6、acquireUninterruptibly()的作用"></a>16.4.6、acquireUninterruptibly()的作用</h3><p>方法acquireUninterruptibly(）是使进入acquire()方法的线程，<strong>不允许</strong>被中断。</p>
<ul>
<li>1、线程执行可以被中断</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/8/28 22:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptSemaphore</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"t1 wait permit"</span>);</span><br><span class="line">                semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"t1 get permit"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < Integer.MAX_VALUE / <span class="number">50</span>; i++){</span><br><span class="line">                    Math.random();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                semaphore.release();</span><br><span class="line">                System.out.println(<span class="string">"t1 release permit"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                System.out.print(<span class="string">"t1 被中断"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"t2 wait permit"</span>);</span><br><span class="line">                semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"t2 get permit"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < Integer.MAX_VALUE / <span class="number">50</span>; i++){</span><br><span class="line">                    Math.random();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                semaphore.release();</span><br><span class="line">                System.out.println(<span class="string">"t2 release permit"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                System.out.print(<span class="string">"t2 被中断"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        t2.interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main中断了"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-ebf9398948833140f1220a8b098a8f84526.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-ebf9398948833140f1220a8b098a8f84526.png" class="lazyload"></a></p>
<p>线程t1、t2都处于运行中， t1获得许可， t2等待许可，t2线程调用interrupt()方法，导致t2的等待被中断。</p>
<ul>
<li>2、线程执行不能被中断</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/8/28 22:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnInterruptSemaphore</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"t1 wait permit"</span>);</span><br><span class="line">                semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"t1 get permit"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < Integer.MAX_VALUE / <span class="number">50</span>; i++){</span><br><span class="line">                    Math.random();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                semaphore.release();</span><br><span class="line">                System.out.println(<span class="string">"t1 release permit"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                System.out.print(<span class="string">"t1 被中断"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"t2 wait permit"</span>);</span><br><span class="line">                semaphore.acquireUninterruptibly();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"t2 get permit"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < Integer.MAX_VALUE / <span class="number">50</span>; i++){</span><br><span class="line">                    Math.random();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                semaphore.release();</span><br><span class="line">                System.out.println(<span class="string">"t2 release permit"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                System.out.print(<span class="string">"t2 被中断"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        t2.interrupt();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main中断了"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>


<p><a href="https://oscimg.oschina.net/oscnet/up-2abc58686114903b3030dc75f1b4aa2ee55.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-2abc58686114903b3030dc75f1b4aa2ee55.png" class="lazyload"></a></p>
<p>线程t2是调用semaphore.acquireUninterruptibly();获取许可，在线程t2上调用interrupt()方法并没有导致线程t2被中断进入catch(Exception e){}代码块.</p>
<p>acquireUninterruptibly()还有重载方法<strong>acquireUninterruptibly(int permits)</strong>; 此方法的作用时等待指定数量的许可时不能被中断，如果成功获取锁，则获得指定数量的许可。</p>
<h3 id="16-4-7、getQueueLength-和hasQueueThreads"><a href="#16-4-7、getQueueLength-和hasQueueThreads" class="headerlink" title="16.4.7、getQueueLength()和hasQueueThreads()"></a>16.4.7、getQueueLength()和hasQueueThreads()</h3><p>getQueueLength()作用是获取当前正在等待获取许可的线程个数</p>
<p>hasQueueThread()作用是判断当前还有没有线程在等待获取许可。</p>
<p>这2个方法通常是用在判断当前有没有等待许可的线程信息时使用</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package juc.semaphore;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/29 20:06</span><br><span class="line"> */</span><br><span class="line">public class GetQueueLengthDemo {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Semaphore semaphore = new Semaphore(1);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i < 3; i++){</span><br><span class="line">            new Thread(){</span><br><span class="line">                @Override</span><br><span class="line">                public void run() {</span><br><span class="line">                    try {</span><br><span class="line"></span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() +"获取到许可");</span><br><span class="line">                        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                        System.out.println("还有" + semaphore.getQueueLength() + "个线程在等待");</span><br><span class="line">                        System.out.println("是否还有线程在等待" + semaphore.hasQueuedThreads());</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() +"释放许可\n");</span><br><span class="line">                    }</span><br><span class="line">                    catch (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-654bc52af76519285e7748c0ed9e97912c0.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-654bc52af76519285e7748c0ed9e97912c0.png" class="lazyload"></a></p>
<h3 id="16-4-8、获取许可的公平与非公平测试"><a href="#16-4-8、获取许可的公平与非公平测试" class="headerlink" title="16.4.8、获取许可的公平与非公平测试"></a>16.4.8、获取许可的公平与非公平测试</h3><p>有时候获取许可的顺序与线程启动的顺序有关，这时就要分为公平与非公平，new Semaphore(1, false);构造函数的第2个参数用于指定公平还是非公平获取许可， true表示公平获取许可，false表示非公平获取许可 。</p>
<p><strong>公平</strong>：线程获得许可的顺序与线程启动的顺序有关，先启动的线程优先获得许可，但不代表100%优先获得许可，仅仅是在概率上得到保障。</p>
<p><strong>非公平</strong>：线程获得许可的顺序与线程启动顺序无关，随机获取。</p>
<p>1、非公平获取许可</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package juc.semaphore;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/29 20:06</span><br><span class="line"> */</span><br><span class="line">public class FairDemo {</span><br><span class="line"></span><br><span class="line">    static class WorkerThread implements Runnable{</span><br><span class="line">        Semaphore semaphore = new Semaphore(1, false);</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() {</span><br><span class="line">            try {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +" is running");</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +"获取到许可");</span><br><span class="line"></span><br><span class="line">                semaphore.release();</span><br><span class="line">            }</span><br><span class="line">            catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        WorkerThread workerThread = new WorkerThread();</span><br><span class="line"></span><br><span class="line">        new Thread(workerThread).start();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i < 3; i++){</span><br><span class="line">            new Thread(workerThread, "线程" + i).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-957e56d103d9bc4f85ad7d4f2f890685b4f.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-957e56d103d9bc4f85ad7d4f2f890685b4f.png" class="lazyload"></a></p>
<p>可以看到线程是最后启动的，但是却优于线程1优先获取到了许可。</p>
<p>2、公平获取许可</p>
<p>当把构造方法的第二个参数new Semaphore(1, true)<strong>改为true</strong>时就是代表公平获取锁，此时再运行上面程序输出如下：</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-fecc237ed70d8346b8018b352a657a8768e.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-fecc237ed70d8346b8018b352a657a8768e.png" class="lazyload"></a></p>
<p>如果反复运行程序会发现绝大部分情况下，线程获取许可的顺序是按照器启动的顺序获取到许可的</p>
<h3 id="16-4-9、tryAcquire"><a href="#16-4-9、tryAcquire" class="headerlink" title="16.4.9、tryAcquire()"></a>16.4.9、tryAcquire()</h3><p>tryAcquire() 以非阻塞方式尝试获取许可，如果获取不到则立即返回false</p>
<p>tryAcquire(int permits) 同上，只是一次尝试获取多个许可</p>
<p>tryAcquire(long timeout, TimeUnit unit) 在指定的时间内尝试获取1个许可，如果没到超时时间则等待获取许可，如果到达超时时间则立即返回true或false</p>
<p>tryAcquire(int permits, long timeout, TimeUnit unit)  同上，一次获取多个许可</p>
<h2 id="16-5、ReentrantLock"><a href="#16-5、ReentrantLock" class="headerlink" title="16.5、ReentrantLock"></a>16.5、ReentrantLock</h2><h3 id="16-5-1、介绍"><a href="#16-5-1、介绍" class="headerlink" title="16.5.1、介绍"></a>16.5.1、介绍</h3><p>在java多线程中可以使用synchronized关键字来实现线程同步互斥执行，但在JDK1.5中增加了ReentrantLock可达到同样的目的，并且在扩展功能上也更加强大，比如具有公平与非公平、嗅探锁定（tryLock()非阻塞）、多路通知(一个锁产生多个Condition)等功能，而且在使用上比synchonrized更加灵活。</p>
<h3 id="16-5-2、线程间同步"><a href="#16-5-2、线程间同步" class="headerlink" title="16.5.2、线程间同步"></a>16.5.2、线程间同步</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package juc.lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/29 21:29</span><br><span class="line"> */</span><br><span class="line">public class ReentrantLockDemo {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        ReentrantLock reentrantLock = new ReentrantLock(false);</span><br><span class="line"></span><br><span class="line">        for (int  i = 0; i < 5; i++){</span><br><span class="line">            new Thread("thread-" + i){</span><br><span class="line">                @Override</span><br><span class="line">                public void run() {</span><br><span class="line">                    try{</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + " is running");</span><br><span class="line">                        reentrantLock.lock();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + " get lock");</span><br><span class="line">                        try {</span><br><span class="line">                            TimeUnit.MILLISECONDS.sleep(200);</span><br><span class="line">                        } catch (InterruptedException e) {</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    finally {</span><br><span class="line">                        reentrantLock.unlock();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + " release lock");</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-c338c507497a92f02bae823a4bbc7a2f32f.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-c338c507497a92f02bae823a4bbc7a2f32f.png" class="lazyload"></a></p>
<p>可以看到多个线程都在运行中，一个线程必须要等待另一个线程释放后获得了锁才能打印</p>
<h3 id="16-5-2、公平与非公平获取锁、isFair-、isLock"><a href="#16-5-2、公平与非公平获取锁、isFair-、isLock" class="headerlink" title="16.5.2、公平与非公平获取锁、isFair()、isLock()"></a>16.5.2、公平与非公平获取锁、isFair()、isLock()</h3><p>new ReentrantLock(true)的构造方法的参数可以控制是线程获取锁的顺序是公平的还是非公平的获取锁，</p>
<p>设置为true时表示使用公平锁，多个线程获得许可的顺序与线程启动的顺序有关，先启动的线程优先获得许可，但不代表100%优先获取到锁，只是从概率上保证<br>false表示非公平地获取锁，即多个线程随机获取锁<br>lock.isFair()返回是否使用的是公平锁<br>返回true表示使用的是公平锁<br>返回false表示使用的是非公平锁</p>
<p>lock.isLock()返回是否有任意线程正持有锁</p>
<p>lock.isHeldByCurrentThread()返回当前线程是否正持有此锁定</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/8/30 21:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsLockDemo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        System.out.println(<span class="string">"是否有任意线程获取此锁定："</span> + lock.isLocked());</span><br><span class="line">        System.out.println(<span class="string">"main是否持有此锁定: "</span> + lock.isHeldByCurrentThread());</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"是否有任意线程获取此锁定："</span> + lock.isLocked());</span><br><span class="line">        System.out.println(<span class="string">"main是否持有此锁定: "</span> + lock.isHeldByCurrentThread());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        lock.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"t is running"</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"main是否持有此锁定: "</span> + lock.isHeldByCurrentThread());</span><br><span class="line">        System.out.println(<span class="string">"是否有任意线程获取此锁定："</span> + lock.isLocked());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-186951e406a0f74d8c222f3c3609349a7eb.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-186951e406a0f74d8c222f3c3609349a7eb.png" class="lazyload"></a></p>
<h3 id="16-5-3、Condition"><a href="#16-5-3、Condition" class="headerlink" title="16.5.3、Condition"></a>16.5.3、Condition</h3><p>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、   wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式,但是它比synchonrized的wait、notiify更加灵活，可以实现多路通知功能，也就是在一个Lock对象里创建多个Condition(即对象监视器)实例，线程对象可以注册在指定的Condition中，从而可以有选择的进行线程通知，在调度线程上更加灵活。</p>
<p>在使用notify() / notifyAll()方法进行通知时时，被通知的线程是由jvm随机选择的，但使用ReentrantLock可以实现前面介绍过的“选择性通知”，这个功能在Condition中默认提供的。</p>
<p>而synchronized相当于整个Lock对象中只有一个单一的Condition对象，所有线程都注册在它一个对象的身上。线程开始notifyAll时，会通知所有处于WAITING状态的线程，没有选择权，会出现相当大的效率问题。</p>
<p>注意：condition.signal() / signalAll()方法只是让调用await()方法的线程退出等待队列，调用signal的线程不释放锁，虽然await()方法所在线程被唤醒，但是由于获得锁，也不会得到执行（阻塞在获取锁的临界区处）。</p>
<ul>
<li>示例1：</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/9/1 12:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionLockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">"t1"</span>){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    System.out.println(<span class="string">"t1 await..."</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                    System.out.println(<span class="string">"t1 get lock"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">finally</span> {</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">"t1 unlock"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"main locked"</span>);</span><br><span class="line"></span><br><span class="line">                condition.signalAll();</span><br><span class="line">                System.out.println(<span class="string">"main signal"</span>);</span><br><span class="line"><span class="comment">//                lock.unlock();</span></span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-b5637bd628069d90bc367cfcb223c185027.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-b5637bd628069d90bc367cfcb223c185027.png" class="lazyload"></a></p>
<p>可以看到虽然线程t2调用了signalAll()方法唤醒线程t1, 但是线程t1并没有从await()处唤醒继续向后执行</p>
<ul>
<li>示例2、交替输出数字</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/8/29 22:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWrite</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> hasIncrement = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>{</span><br><span class="line">                    <span class="keyword">while</span> (!hasIncrement){</span><br><span class="line">                        condition.await();</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 代表一些耗时的操作</span></span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()  + <span class="string">" read: "</span> + count);</span><br><span class="line"></span><br><span class="line">                    hasIncrement = <span class="keyword">false</span>;</span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (Exception e){</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">finally</span> {</span><br><span class="line">                    lock.unlock();</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>{</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">               lock.lock();</span><br><span class="line">               <span class="keyword">try</span>{</span><br><span class="line">                   <span class="keyword">while</span> (hasIncrement){</span><br><span class="line">                       condition.await();</span><br><span class="line">                   }</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 代表一些耗时的操作</span></span><br><span class="line">                   TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                   count++;</span><br><span class="line">                   hasIncrement = <span class="keyword">true</span>;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName()  + <span class="string">" write: "</span> + count);</span><br><span class="line">                   condition.signalAll();</span><br><span class="line">               }</span><br><span class="line">               <span class="keyword">catch</span> (Exception e){</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               }</span><br><span class="line">               <span class="keyword">finally</span> {</span><br><span class="line">                   lock.unlock();</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ReadWrite readWrite = <span class="keyword">new</span> ReadWrite();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">50</span>; i++){</span><br><span class="line">            <span class="keyword">new</span> Thread(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    readWrite.read();</span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">50</span>; i++){</span><br><span class="line">            <span class="keyword">new</span> Thread(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    readWrite.write();</span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-7331f3f4ca30a6468f4ee8b40f4aee14e23.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-7331f3f4ca30a6468f4ee8b40f4aee14e23.png" class="lazyload"></a></p>
<ul>
<li>3、多生产者、多消费者示例：锁实现有界阻塞队列</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/8/29 22:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduerAndConsumerDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ArrayBlockingContainer<integer> container = <span class="keyword">new</span> ArrayBlockingContainer<>();</integer></span><br><span class="line"></span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(container);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(container);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i < <span class="number">5</span>; i++){</span><br><span class="line">            <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingContainer</span><<span class="title">e</span>></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> LinkedList<e> storage;</e></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> capticy;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingContainer</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">this</span>(<span class="number">16</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingContainer</span><span class="params">(<span class="keyword">int</span> capticy)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.storage = <span class="keyword">new</span> LinkedList<>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.capticy = capticy;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brpush</span><span class="params">(E value)</span></span>{</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">this</span>.isOverflow()){</span><br><span class="line">                    condition.await();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.storage.addLast(value);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" brpush value: "</span> + value);</span><br><span class="line">                condition.signalAll();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Exception e){</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">finally</span> {</span><br><span class="line">                lock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">blpop</span><span class="params">()</span></span>{</span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">this</span>.isEmpty()){</span><br><span class="line">                    condition.await();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                E value = <span class="keyword">this</span>.storage.removeFirst();</span><br><span class="line">                condition.signalAll();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" blpop value: "</span> +value);</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">finally</span> {</span><br><span class="line">                lock.unlock();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.storage.size();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOverflow</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">return</span> size() >= capticy;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.storage.isEmpty();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">        ArrayBlockingContainer container;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(ArrayBlockingContainer container)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.container = container;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = count.incrementAndGet();</span><br><span class="line">                    <span class="keyword">this</span>.container.brpush(value);</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">        ArrayBlockingContainer container;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(ArrayBlockingContainer container)</span></span>{</span><br><span class="line">            <span class="keyword">this</span>.container = container;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    Object value = <span class="keyword">this</span>.container.blpop();</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-eb7ae5c1e0f1a503c8ccb0aa864ce5d26b9.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-eb7ae5c1e0f1a503c8ccb0aa864ce5d26b9.png" class="lazyload"></a></p>
<p>从输出可以看到读写是有顺序的（pop的一定是之前被push进去的，读出来的没有出现重复的），但是读读、写写是没有顺序的，因为只保证了容器的读写正确性，并没有线程保证线程读写的有序性。</p>
<h3 id="16-5-4、getHolderCount"><a href="#16-5-4、getHolderCount" class="headerlink" title="16.5.4、getHolderCount()"></a>16.5.4、getHolderCount()</h3><p>查询当前线程持有此锁定的次数，也就是lock()方法被调用的次数</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package juc.lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/30 20:00</span><br><span class="line"> */</span><br><span class="line">public class ReentrantLockHolderDemo {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line">        </span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(lock.getHoldCount());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-3f5df07bd8cd8bf6f738a2d788ceb307143.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-3f5df07bd8cd8bf6f738a2d788ceb307143.png" class="lazyload"></a></p>
<h3 id="16-5-5、getQueuedLength-、hasQueueuedThreads"><a href="#16-5-5、getQueuedLength-、hasQueueuedThreads" class="headerlink" title="16.5.5、getQueuedLength()、hasQueueuedThreads()"></a>16.5.5、getQueuedLength()、hasQueueuedThreads()</h3><p>lock.getQueuedLength() 返回当前正在等待获取此锁定的线程的个数</p>
<p>lock.hasQueueuedThreads() 返回当前是否还有线程等待获取此锁定</p>
<p>lock.hasQueuedThread(Thread t) 返回指定的线程t是否正在等待获取此锁定</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package juc.lock;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">/**</span><br><span class="line"> * @author calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span><br><span class="line"> * 2019/8/30 20:03</span><br><span class="line"> */</span><br><span class="line">public class GetQueueLegth {</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException {</span><br><span class="line">        ReentrantLock lock = new ReentrantLock();</span><br><span class="line">        Thread[] threads = new Thread[5];</span><br><span class="line">        for (int  i = 0; i < 3; i++){</span><br><span class="line">            threads[i] = new Thread(){</span><br><span class="line">                @Override</span><br><span class="line">                public void run() {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + " is running");</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +" get lock");</span><br><span class="line">                    try {</span><br><span class="line">                        TimeUnit.SECONDS.sleep(3);</span><br><span class="line">                    } catch (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +" unlock");</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                }</span><br><span class="line">            };</span><br><span class="line">            threads[i].start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        System.out.println("Thread-0 wait lock: " +lock.hasQueuedThread(threads[0]));</span><br><span class="line">        System.out.println("Thread-1 wait lock: " + lock.hasQueuedThread(threads[1]));</span><br><span class="line">        System.out.println("lock wait: " + lock.hasQueuedThreads());</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(10);</span><br><span class="line">        System.out.println("lock wait: " + lock.hasQueuedThreads());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-369ff3a523f8f0461d47dff48b2da2fe42f.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-369ff3a523f8f0461d47dff48b2da2fe42f.png" class="lazyload"></a></p>
<h3 id="16-5-6、getWaitQueueLength-Condition-c-、hasWaiters-Condition-c"><a href="#16-5-6、getWaitQueueLength-Condition-c-、hasWaiters-Condition-c" class="headerlink" title="16.5.6、getWaitQueueLength(Condition c)、hasWaiters(Condition c)"></a>16.5.6、getWaitQueueLength(Condition c)、hasWaiters(Condition c)</h3><ul>
<li>lock.getWaitQueueLength(Condition c)：</li>
</ul>
<p>返回在给定Condition上等待的线程估计数（即有多少个线程在这个Condition上正处于WAITING等待状态），比如3个线程在同一个Condition上都调用了await()方法，此时另一个线程获取锁后，再调用getWaitQueueLength(Condition condition)则返回3。</p>
<ul>
<li>hasWaiters(Condition c)<br>返回是否有线程正在此Condition上处于WAITING等待状态</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/8/30 20:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetWaitQueueLengt</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRunnable</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitMethod</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" is running"</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" await"</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 被唤醒"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">finally</span> {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" unlock"</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyMethod</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.println(<span class="string">"\nnotifyMethod is running"</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"has waiter:"</span> + lock.hasWaiters(condition)  + <span class="string">", wait length:"</span> + lock.getWaitQueueLength(condition));</span><br><span class="line">            condition.signal();</span><br><span class="line">            System.out.println(<span class="string">"notifyMethod signalAll"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">"notifyMethod unlock\n"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ServiceRunnable serviceRunnable = <span class="keyword">new</span> ServiceRunnable();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3</span>; i++){</span><br><span class="line">            <span class="keyword">new</span> Thread(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    serviceRunnable.waitMethod();</span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保所有线程都已经处于运行中</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        serviceRunnable.notifyMethod();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        serviceRunnable.notifyMethod();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-9cb2fc1a46847da1311bf9c219ea15efc00.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-9cb2fc1a46847da1311bf9c219ea15efc00.png" class="lazyload"></a></p>
<p><strong>第一次调用</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 确保所有线程都已经处于运行中</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">serviceRunnable.notifyMethod();</span><br></pre></td></tr></tbody></table></figure></div>
<p>时由于有3个线程在这个Condition上正处于WAITING状态，所以getWaitQueueLength(Condition c)返回数字3，此时由于notifyMethod()中调用了一次signal(),所以会导致3个线程中的某个线程被唤醒（这里是Thread-0被唤醒）</p>
<p><strong>第二次调用</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(3000);</span><br><span class="line">serviceRunnable.notifyMethod();</span><br></pre></td></tr></tbody></table></figure></div>
<p>时，由于之前Thread-0已经被唤醒，此时在Conition上只有2个线程处于WAITING状态，所以notifyMethod()方法中getWaitQueueLength(Condition c)返回数字2，此时由于notifyMethod()中调用了一次signal(),所以会导致2个线程中的某个线程被唤醒（这里是Thread-2被唤醒），此时Thread-1还处于WAITING状态，但是由于没有被signal()通知，所以导致Thread-1一直处于等待状态，导致看到的结果就是控制台一直不停止。</p>
<h3 id="16-5-7、lock-、lockInterruptibly"><a href="#16-5-7、lock-、lockInterruptibly" class="headerlink" title="16.5.7、lock()、lockInterruptibly()"></a>16.5.7、lock()、lockInterruptibly()</h3><ol>
<li>lockInterruptibly()的作用是当前线程等待获取锁定的过程中，如果被中断则抛出异常InterruptedException， lock()方法所在的线程等待获取锁定的过程中，如果被中断也不会抛出异常，而是正常等待直到获取锁定。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/9/1 10:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockInterruptDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="string">"thread1"</span>){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"thread1 is running"</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"thread1 get lock"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i < Integer.MAX_VALUE / <span class="number">50</span>; i ++){</span><br><span class="line">                    Math.random();</span><br><span class="line">                }</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"thread1 unlock"</span>);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保thread1先运行</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="string">"thread2"</span>){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"thread2 is running"</span>);</span><br><span class="line">                <span class="comment">// 即使被中断，也不抛出异常，继续执行</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"thread2 get lock"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i < Integer.MAX_VALUE / <span class="number">50</span>; i ++){</span><br><span class="line">                    Math.random();</span><br><span class="line">                }</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"thread2 unlock"</span>);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread2.interrupt();</span><br><span class="line"></span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(<span class="string">"thread3"</span>){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"thread3 is running"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 在等待锁的过程中，如果被中断则抛出异常</span></span><br><span class="line">                    lock.lockInterruptibly();</span><br><span class="line">                     System.out.println(<span class="string">"thread3 get lock"</span>);</span><br><span class="line"></span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i < Integer.MAX_VALUE / <span class="number">50</span>; i ++){</span><br><span class="line">                    Math.random();</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 由于线程被中断，抛出了异常，但是异常被捕获了，只是打印了，而这里打印出调用lock.unlock()</span></span><br><span class="line">                <span class="comment">// 抛出IllegalMonitorStateException，说明线程被中断没有获取到锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"thread3 unlock"</span>);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        thread3.start();</span><br><span class="line">        thread3.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

</li>
</ol>
<p><a href="https://oscimg.oschina.net/oscnet/up-4f9afffe9e660c2766acb1acb9a06a79c7e.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-4f9afffe9e660c2766acb1acb9a06a79c7e.png" class="lazyload"></a></p>
<p>从输出可以看到：</p>
<p>线程t1先启动，持有锁定还没有释放的时候，线程t2调用lock()方法等待获取锁定时，在main线程调用thread2.interrupt()方法并没有导致线程thread2抛出异常，而是等到线程thread1释放锁后线程thread2依然获得了锁，说明**thead.interrupt()方法并不能打断lock.lock()方法。<br>线程t3调用lock.lockInterruptibly();方法在等待获取锁定的过程中，在main线程中调用thread3.interrupt()方法，可以看到抛出了异常，但是由于异常被捕获了，所以导致thread3的代码继续往后执行，当执行到lock.unlock()方法时，抛出了IllegalMonitorStateException，说明thread3并没有获取到锁。</p>
<h3 id="16-5-8、tryLock"><a href="#16-5-8、tryLock" class="headerlink" title="16.5.8、tryLock()"></a>16.5.8、tryLock()</h3><ul>
<li>tryLock()是lock()的非阻塞版本， tryLock()调用后会立即返回true或false，表示是否获取到锁</li>
<li>tryLock(long timeout, TimeUnit unit)是tryLock()的非阻塞超时版本，可以指定在没有获取到锁时最多等待多长时间，如果到了指定超时时间还没有获取到锁则返回false, 如果在等待过程中线程被中断，则抛出异常。<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/9/1 11:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryLockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="string">"thread1"</span>){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"thread1 is running"</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"thread1 get lock"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">"thread1 unlock"</span>);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保thread1先运行,已经持有锁</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="string">"thread2"</span>){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"thread2 is running"</span>);</span><br><span class="line">                <span class="keyword">if</span> (lock.tryLock()){</span><br><span class="line">                    System.out.println(<span class="string">"thread2 get lock"</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i < Integer.MAX_VALUE / <span class="number">50</span>; i ++){</span><br><span class="line">                        Math.random();</span><br><span class="line">                    }</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">"thread2 unlock"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span>{</span><br><span class="line">                    System.out.println(<span class="string">"thread2 没有获取到锁"</span>);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(<span class="string">"thread3"</span>){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"thread3 is running"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">if</span> (lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS)){</span><br><span class="line">                        System.out.println(<span class="string">"thread3 get lock"</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i < Integer.MAX_VALUE / <span class="number">50</span>; i ++){</span><br><span class="line">                            Math.random();</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        lock.unlock();</span><br><span class="line">                        System.out.println(<span class="string">"thread3 unlock"</span>);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span>{</span><br><span class="line">                        System.out.println(<span class="string">"thread3 等待3秒仍然没有获取到锁"</span>);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

</li>
</ul>
<p><a href="https://oscimg.oschina.net/oscnet/up-9a6d2538f7ff1d70612ec6421ab3bf37074.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-9a6d2538f7ff1d70612ec6421ab3bf37074.png" class="lazyload"></a></p>
<p>如果把线程thread3的lock.tryLock(3, TimeUnit.SECONDS)的超时时间改为1，则会导致thread3到了超时时间仍然获取不到锁，修改后的输出如下：</p>
<p><a href="https://oscimg.oschina.net/oscnet/up-32fdd175414b64b89f9265bc219b5434eb1.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-32fdd175414b64b89f9265bc219b5434eb1.png" class="lazyload"></a></p>
<h3 id="16-5-8、Contition-awaitUninterrupyibly"><a href="#16-5-8、Contition-awaitUninterrupyibly" class="headerlink" title="16.5.8、Contition.awaitUninterrupyibly()"></a>16.5.8、Contition.awaitUninterrupyibly()</h3><p>Contition.await()方法等待过程中<strong>可以</strong>被thread.interrupt()中断</p>
<p>Contition.awaitUninterrupyibly()等待过程中<strong>不能</strong>被thread.interrupt()中断</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/9/1 12:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionInterruptDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">"t1"</span>){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    System.out.println(<span class="string">"t1 await..."</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    System.out.println(<span class="string">"t1被中断"</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">finally</span> {</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">"t1 unlock"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="string">"t2"</span>){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"t2 is running..."</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    System.out.println(<span class="string">"t2 await..."</span>);</span><br><span class="line">                    condition.awaitUninterruptibly();</span><br><span class="line">                    System.out.println(<span class="string">"t2 get lock"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (Exception e){</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">finally</span> {</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">"t2 unlock"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        t2.interrupt();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(<span class="string">"main locked"</span>);</span><br><span class="line"></span><br><span class="line">                condition.signalAll();</span><br><span class="line">                System.out.println(<span class="string">"main signal"</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-c8a9ccc09ebe912b14b3b44c38de0cb2245.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-c8a9ccc09ebe912b14b3b44c38de0cb2245.png" class="lazyload"></a></p>
<p>从输出可以看到：</p>
<ol>
<li>Condition.await()可以被thread.interrupt()中断。</li>
<li>线程t2调用awaitUninterruptibly()处于等待状态，然后线程在main线程中调用t2.interrupt()方法并没有导致线程t2被中断，当线程t3调用signalAll()并释放锁后，线程t2正常获得了锁。<h3 id="16-5-9、condition-awaitUntil-Date-deadlineDate"><a href="#16-5-9、condition-awaitUntil-Date-deadlineDate" class="headerlink" title="16.5.9、condition.awaitUntil(Date deadlineDate)"></a>16.5.9、condition.awaitUntil(Date deadlineDate)</h3>condition.awaitUntil(Date deadlineDate) 是await()的等待超时版本，表示线程最多等待指定的时间，如果到了指定的超时时间则还没有被唤醒则立即返回false, 如果未到超时时间就被唤醒了则立即返回true</li>
</ol>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/9/1 13:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitUntil</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="string">"t1"</span>){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    System.out.println(<span class="string">"t1 await..."</span>);</span><br><span class="line">                    LocalDateTime deadlineDate = LocalDateTime.now().plusSeconds(<span class="number">1</span>);</span><br><span class="line">                    Instant instant = deadlineDate.atZone(ZoneId.systemDefault()).toInstant();</span><br><span class="line">                    <span class="keyword">boolean</span> success = condition.awaitUntil(Date.from(instant));</span><br><span class="line">                    <span class="keyword">if</span> (success){</span><br><span class="line">                        System.out.println(<span class="string">"t1 do something..."</span>);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span>{</span><br><span class="line">                        System.out.println(<span class="string">"t1 wait timeout"</span>);</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    System.out.println(<span class="string">"t1被中断"</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">finally</span> {</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">"t1 unlock"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main sleep"</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"main before signal"</span>);</span><br><span class="line">        condition.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(<span class="string">"main signal"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>
<p><a href="https://oscimg.oschina.net/oscnet/up-3f39b63b50f9baa9f01d287b3a159d70c9e.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-3f39b63b50f9baa9f01d287b3a159d70c9e.png" class="lazyload"></a></p>
<h3 id="16-6-1、可重入功能"><a href="#16-6-1、可重入功能" class="headerlink" title="16.6.1、可重入功能"></a>16.6.1、可重入功能</h3><p>ReentrantLock拥有锁重入的功能，也就是在使用lock()方法时，当一个线程获得一个锁，再次请求该锁时是可以获得该锁的。表现在一个lock()及unlock()方法 包围的代码块的内部调用本类的其他lock()及unlock()方法块时，是永远可以得到锁的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/9/1 15:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"methodA invoked "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.methodB();</span><br><span class="line"></span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>{</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"methodB invoked "</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ReentrantDemo demo = <span class="keyword">new</span> ReentrantDemo();</span><br><span class="line"></span><br><span class="line">        demo.methodA();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-c013940cb6ee6b6a11eb8c67ee7e9d7b757.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-c013940cb6ee6b6a11eb8c67ee7e9d7b757.png" class="lazyload"></a></p>
<h2 id="16-6、ReentrantReadWriteLock"><a href="#16-6、ReentrantReadWriteLock" class="headerlink" title="16.6、ReentrantReadWriteLock"></a>16.6、ReentrantReadWriteLock</h2><p><strong>ReentrantReadWriteLock表示可重入的读写锁，他有2个锁，一个是读操作相关的共享锁，另一个是写相关的排他锁。多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。</strong></p>
<p>在没有线程进行进行写入操作时，进行读取操作的多个Thread都可以获取到读锁，而进行写入操作的Thread只有在获取到写锁后才能进行写入操作，即多个Thread可以同时进行读操作，但是同一时刻只允许一个线程进行写操作。</p>
<h3 id="16-6-1、读读共享"><a href="#16-6-1、读读共享" class="headerlink" title="16.6.1、读读共享"></a>16.6.1、读读共享</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock.readWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/9/1 15:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadReadLockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5</span>; i++){</span><br><span class="line">            <span class="keyword">new</span> Thread(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    lock.readLock().lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" read"</span>);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    lock.readLock().unlock();</span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-7f435a3360ae11a994eba3f004878d29ad3.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-7f435a3360ae11a994eba3f004878d29ad3.png" class="lazyload"></a></p>
<p>可以每个线程运行时获取到锁后，都睡眠了1秒钟，1秒钟后才释放锁，但是控制台的输出却是一瞬间全部输出完成的，说明多个线程之间并没有互斥执行（即读读共享）。</p>
<h3 id="16-6-2、写写互斥"><a href="#16-6-2、写写互斥" class="headerlink" title="16.6.2、写写互斥"></a>16.6.2、写写互斥</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock.readWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/9/1 15:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteWriteLockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5</span>; i++){</span><br><span class="line">            <span class="keyword">new</span> Thread(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" wait write lock"</span>);</span><br><span class="line">                    lock.writeLock().lock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" write"</span>);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    lock.writeLock().unlock();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" release write lock"</span>);</span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-8385d953e8dd64fcb2a3970d5e9063d5d4a.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-8385d953e8dd64fcb2a3970d5e9063d5d4a.png" class="lazyload"></a></p>
<p>从输出可以看到多个线程几乎同时执行到线程内的第一行打印，等待获取锁，而多个线程之间互斥获取锁（必须要等待前一个线程释放了锁，下一个线程才能获取到锁）</p>
<h3 id="16-6-3、读写互斥-先读后写"><a href="#16-6-3、读写互斥-先读后写" class="headerlink" title="#16.6.3、读写互斥(先读后写)"></a>#16.6.3、读写互斥(先读后写)</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock.readWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/9/1 15:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" wait read lock"</span>);</span><br><span class="line">                lock.readLock().lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" read"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                lock.readLock().unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" release read lock"</span>);</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保读锁已经被占据</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" wait write lock"</span>);</span><br><span class="line">                lock.writeLock().lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" write"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                lock.writeLock().unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" release write lock"</span>);</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-07cde93123d6ddf2a26a7b14d20d03b8896.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-07cde93123d6ddf2a26a7b14d20d03b8896.png" class="lazyload"></a></p>
<h3 id="16-6-4、写读互斥（先写后读）"><a href="#16-6-4、写读互斥（先写后读）" class="headerlink" title="16.6.4、写读互斥（先写后读）"></a>16.6.4、写读互斥（先写后读）</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock.readWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/9/1 15:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteReadLockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" wait write lock"</span>);</span><br><span class="line">                lock.writeLock().lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" write"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                lock.writeLock().unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" release write lock"</span>);</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保写锁已经被占据</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" wait read lock"</span>);</span><br><span class="line">                lock.readLock().lock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" read"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                lock.readLock().unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" release read lock"</span>);</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-b4fb138b10a6100aa06b095adc94e8a56d6.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-b4fb138b10a6100aa06b095adc94e8a56d6.png" class="lazyload"></a></p>
<h2 id="16-7、StampedLock"><a href="#16-7、StampedLock" class="headerlink" title="16.7、StampedLock"></a>16.7、StampedLock</h2><h3 id="16-7-1、介绍"><a href="#16-7-1、介绍" class="headerlink" title="16.7.1、介绍"></a>16.7.1、介绍</h3><p>StampedLock类，在JDK1.8时引入，是对读写锁ReentrantReadWriteLock的增强，该类提供了一些功能，优化了读锁、写锁的访问，同时使读写锁之间可以互相转换，更细粒度控制并发。</p>
<p>首先明确下，该类的设计初衷是作为一个内部工具类，用于辅助开发其它线程安全组件，用得好，该类可以提升系统性能，用不好，容易产生死锁和其它莫名其妙的问题。</p>
<p><strong>先来看下，为什么有了ReentrantReadWriteLock，还要引入StampedLock？</strong></p>
<p>ReentrantReadWriteLock使得多个读线程同时持有读锁（只要写锁未被占用），而写锁是独占的。</p>
<p>但是，读写锁如果使用不当，很容易产生“饥饿”问题：</p>
<p>比如在读线程非常多，写线程很少的情况下，很容易导致写线程“饥饿”，虽然使用“公平”策略可以一定程度上缓解这个问题，但是“公平”策略是以牺牲系统吞吐量为代价的。</p>
<h3 id="16-7-2、-StampedLock的特点"><a href="#16-7-2、-StampedLock的特点" class="headerlink" title="16.7.2、 StampedLock的特点"></a>16.7.2、 StampedLock的特点</h3><p>StampedLock的主要特点概括一下，有以下几点：</p>
<ol>
<li>所有获取锁的方法，都返回一个邮戳（Stamp），Stamp为0表示获取失败，其余都表示成功；</li>
<li>所有释放锁的方法，都需要一个邮戳（Stamp），这个Stamp必须是和成功获取锁时得到的Stamp一致；</li>
<li>StampedLock是<strong>不可重入的</strong>；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）</li>
<li>StampedLock有三种访问模式：<br>①Reading（读模式）：功能和ReentrantReadWriteLock的读锁类似<br>②Writing（写模式）：功能和ReentrantReadWriteLock的写锁类似<br>③Optimistic reading（乐观读模式）：这是一种优化的读模式。</li>
<li>StampedLock支持读锁和写锁的相互转换<br>我们知道RRW中，当线程获取到写锁后，可以降级为读锁，但是读锁是不能直接升级为写锁的。<br>StampedLock提供了读锁和写锁相互转换的功能，使得该类支持更多的应用场景。</li>
<li>无论写锁还是读锁，都不支持Conditon等待</li>
</ol>
<h3 id="16-7-3、oracle官方示例"><a href="#16-7-3、oracle官方示例" class="headerlink" title="16.7.3、oracle官方示例"></a>16.7.3、oracle官方示例</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> juc.lock.stampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> calebzhao<9 3 9 3 4 7 5 0 7 @ qq.com></span></span><br><span class="line"><span class="comment"> * 2019/9/1 16:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>{</span><br><span class="line">        <span class="keyword">private</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> deltaX, <span class="keyword">int</span> deltaY)</span></span>{</span><br><span class="line">            <span class="keyword">long</span> stamp = stampedLock.writeLock();</span><br><span class="line">            <span class="keyword">this</span>.x += deltaX;</span><br><span class="line">            <span class="keyword">this</span>.y += deltaY;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"write: ("</span> + <span class="keyword">this</span>.x +<span class="string">","</span> + <span class="keyword">this</span>.y +<span class="string">") = ("</span> + (<span class="keyword">this</span>.x - deltaX) + <span class="string">" + "</span> +deltaX+<span class="string">", "</span> + (<span class="keyword">this</span>.y - deltaY) + <span class="string">" + "</span> + deltaY +<span class="string">")"</span>);</span><br><span class="line">            stampedLock.unlockWrite(stamp);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">read</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead();</span><br><span class="line">            <span class="keyword">int</span> currentX = x;</span><br><span class="line">            <span class="keyword">int</span> currentY = y;</span><br><span class="line">            <span class="comment">// 判断这个时间戳的数据是否被修改过，如果发生过修改，则说明读取到的x和y不一致</span></span><br><span class="line">            <span class="comment">// 有可能读取完x后， y被另一个线程修改了，导致读取到的x和y不是成对的，出现脏数据，validate()返回true说明数据没有被另一个线程修改过，如果返回true说读取过程中，数据被另一个线程修改了，出现了数据不一致的情况</span></span><br><span class="line">            <span class="keyword">if</span> (!stampedLock.validate(stamp)){</span><br><span class="line">                <span class="comment">// 数据被修改了，升级锁为悲观锁</span></span><br><span class="line">                stamp = stampedLock.readLock();</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">                stampedLock.unlockRead(stamp);</span><br><span class="line">            }</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Point point = <span class="keyword">new</span> Point();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i < <span class="number">100</span>; i++){</span><br><span class="line">            <span class="keyword">new</span> Thread(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">double</span> value = point.read();</span><br><span class="line">                        System.out.println(<span class="string">"read: "</span> +value);</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        AtomicInteger counter = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i < <span class="number">2</span>; i++){</span><br><span class="line">            <span class="keyword">new</span> Thread(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">                        <span class="keyword">int</span> c = counter.incrementAndGet();</span><br><span class="line">                        point.write(c, c);</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p><a href="https://oscimg.oschina.net/oscnet/up-cdf01af501f36b6ebf577f646ca322acff8.png" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://oscimg.oschina.net/oscnet/up-cdf01af501f36b6ebf577f646ca322acff8.png" class="lazyload"></a></p>
<p>可以看到，上述示例最特殊的其实是<strong>distanceFromOrigin</strong>方法，这个方法中使用了“Optimistic reading”乐观读锁，使得读写可以并发执行，但是<code>Optimistic reading</code>的使用必须遵循以下模式：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead();  <span class="comment">// 非阻塞获取版本信息</span></span><br><span class="line">copyVaraibale2ThreadMemory();           <span class="comment">// 拷贝变量到线程本地堆栈</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp)){              <span class="comment">// 校验</span></span><br><span class="line">    <span class="keyword">long</span> stamp = lock.readLock();       <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        copyVaraibale2ThreadMemory();   <span class="comment">// 拷贝变量到线程本地堆栈</span></span><br><span class="line">     } <span class="keyword">finally</span> {</span><br><span class="line">       lock.unlock(stamp);              <span class="comment">// 释放悲观锁</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">useThreadMemoryVarables();              <span class="comment">// 使用线程本地堆栈里面的数据进行操作</span></span><br></pre></td></tr></tbody></table></figure></div>
<h3 id="16-7-4、实现原理"><a href="#16-7-4、实现原理" class="headerlink" title="16.7.4、实现原理"></a>16.7.4、实现原理</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fg</span><br></pre></td></tr></tbody></table></figure></div>

</body></html></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">calebzhao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://calebzhao.github.io/2019/12/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/">https://calebzhao.github.io/2019/12/29/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://calebzhao.github.io">calebzhao的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java    </a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发    </a><a class="post-meta__tags" href="/tags/juc/">juc    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/calebzhao/cdn/img/20191229151714.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://cdn.jsdelivr.net/gh/calebzhao/cdn/img/20191229152519.jpg" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/12/29/Feign%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Feign源码学习</span></div></a></div><div class="next-post pull_right"><a href="/2019/12/29/spring-cloud-openfeign%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>spring-cloud-openfeign源码分析</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/12/30/深入理解jvm/" title="深入理解jvm"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-10</div><div class="relatedPosts_title">深入理解jvm</div></div></a></div><div class="relatedPosts_item"><a href="/2019/12/29/Java中的Type详解/" title="Java中的Type详解"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-10</div><div class="relatedPosts_title">Java中的Type详解</div></div></a></div><div class="relatedPosts_item"><a href="/2019/12/29/Class对象的getXXXClass和getXXXName/" title="Class对象的getXXXClass和getXXXName"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-10</div><div class="relatedPosts_title">Class对象的getXXXClass和getXXXName</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = '昵称,邮箱,链接'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'HgchHaGng3F6hbefP0mcTaYh-gzGzoHsz',
  appKey:'j47kWakblNYEeDic8riu7flK',
  placeholder:'请留下你的足迹',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By calebzhao</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div><img src="https://api.travis-ci.com/calebzhao/calebzhao.github.io.svg?branch=hexo"></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>